{"version":3,"sources":["sentio.js","util.js","util_extent.js","util_multi_extent.js","model.js","model_bins.js","controller.js","controller_realtime_bins.js","chart.js","chart_donut.js","chart_matrix.js","chart_vertical_bars.js","timeline.js","timeline_line.js","realtime.js","realtime_timeline.js"],"names":[],"mappings":"AAAA;ACAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtFA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1XA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5JA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxMA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9gBA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sentio.js","sourcesContent":["if(null == sentio) { var sentio = {}; }","var sentio_util = sentio.util = {};","sentio.util.extent = sentio_util_extent;\n\nfunction sentio_util_extent(config) {\n\t'use strict';\n\n\t/**\n\t * Private variables\n\t */\n\t// Configuration\n\tvar _config = {\n\t\tdefaultValue: [0, 10],\n\t\toverrideValue: undefined\n\t};\n\n\tvar _fn = {\n\t\tgetValue: function(d, i) { return d; },\n\t\tfilter: function(d, i) { return true; }\n\t};\n\n\n\t/**\n\t * Private Functions\n\t */\n\n\tfunction setDefaultValue(v) {\n\t\tif(null == v || 2 !== v.length || isNaN(v[0]) || isNaN(v[1]) || v[0] >= v[1]) {\n\t\t\tthrow new Error('Default extent must be a two element ordered array of numbers');\n\t\t}\n\t\t_config.defaultValue = v;\n\t}\n\n\tfunction setOverrideValue(v) {\n\t\tif(null != v && 2 !== v.length) {\n\t\t\tthrow new Error('Extent override must be a two element array or null/undefined');\n\t\t}\n\t\t_config.overrideValue = v;\n\t}\n\n\tfunction setGetValue(v) {\n\t\tif(typeof v !== 'function') {\n\t\t\tthrow new Error('Value getter must be a function');\n\t\t}\n\n\t\t_fn.getValue = v;\n\t}\n\n\tfunction setFilter(v) {\n\t\tif(typeof v !== 'function') {\n\t\t\tthrow new Error('Filter must be a function');\n\t\t}\n\n\t\t_fn.filter = v;\n\t}\n\n\t/*\n\t * Constructor/initialization method\n\t */\n\tfunction _instance(extentConfig) {\n\t\tif(null != extentConfig) {\n\t\t\tif(null != extentConfig.defaultValue) { setDefaultValue(extentConfig.defaultValue); }\n\t\t\tif(null != extentConfig.overrideValue) { setOverrideValue(extentConfig.overrideValue); }\n\t\t\tif(null != extentConfig.getValue) { setGetValue(extentConfig.getValue); }\n\t\t\tif(null != extentConfig.filter) { setFilter(extentConfig.filter); }\n\t\t}\n\t}\n\n\n\t/**\n\t * Public API\n\t */\n\n\t/*\n\t * Get/Set the default value for the extent\n\t */\n\t_instance.defaultValue = function(v) {\n\t\tif(!arguments.length) { return _config.defaultValue; }\n\t\tsetDefaultValue(v);\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Get/Set the override value for the extent\n\t */\n\t_instance.overrideValue = function(v) {\n\t\tif(!arguments.length) { return _config.overrideValue; }\n\t\tsetOverrideValue(v);\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Get/Set the value accessor for the extent\n\t */\n\t_instance.getValue = function(v) {\n\t\tif(!arguments.length) { return _fn.getValue; }\n\t\tsetGetValue(v);\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Get/Set the filter fn for the extent\n\t */\n\t_instance.filter = function(v) {\n\t\tif(!arguments.length) { return _fn.filter; }\n\t\tsetFilter(v);\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Calculate the extent given some data.\n\t * - Default values are used in the absence of data\n\t * - Override values are used to clamp or extend the extent\n\t */\n\t_instance.getExtent = function(data) {\n\t\tvar toReturn;\n\t\tvar ov = _config.overrideValue;\n\n\t\t// Check to see if we need to calculate the extent\n\t\tif(null == ov || null == ov[0] || null == ov[1]) {\n\t\t\t// Since the override isn't complete, we need to calculate the extent\n\t\t\ttoReturn = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n\t\t\tvar foundData = false;\n\n\t\t\tif(null != data) {\n\t\t\t\t// Iterate over each element of the data\n\t\t\t\tdata.forEach(function(element, i) {\n\t\t\t\t\t// If the element passes the filter, then update the extent\n\t\t\t\t\tif(_fn.filter(element, i)) {\n\t\t\t\t\t\tfoundData = true;\n\t\t\t\t\t\tvar v = _fn.getValue(element, i);\n\t\t\t\t\t\ttoReturn[0] = Math.min(toReturn[0], v);\n\t\t\t\t\t\ttoReturn[1] = Math.max(toReturn[1], v);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// If we didn't find any data, use the default values\n\t\t\tif(!foundData) {\n\t\t\t\ttoReturn = _config.defaultValue;\n\t\t\t}\n\n\t\t\t// Apply the overrides\n\t\t\t// - Since we're in this conditional, only one or zero overrides were specified\n\t\t\tif(null != ov) {\n\t\t\t\tif(null != ov[0]) {\n\t\t\t\t\t// Set the lower override\n\t\t\t\t\ttoReturn[0] = ov[0];\n\t\t\t\t\tif(toReturn[0] > toReturn[1]) {\n\t\t\t\t\t\ttoReturn[1] = toReturn[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(null != ov[1]) { \n\t\t\t\t\ttoReturn[1] = ov[1];\n\t\t\t\t\tif(toReturn[1] < toReturn[0]) {\n\t\t\t\t\t\ttoReturn[0] = toReturn[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Since the override is fully specified, use it\n\t\t\ttoReturn = ov;\n\t\t}\n\n\t\treturn toReturn;\n\t};\n\n\n\t// Initialize the model\n\t_instance(config);\n\n\treturn _instance;\n}","sentio.util.multiExtent = sentio_util_multi_extent;\n\nfunction sentio_util_multi_extent(config) {\n\t'use strict';\n\n\t/**\n\t * Private variables\n\t */\n\n\tvar _fn = {\n\t\tvalues: function(d) { return d.values; }\n\t};\n\n\tvar _extent = sentio.util.extent();\n\n\t/**\n\t * Private Functions\n\t */\n\n\tfunction setExtent(v) {\n\t\t_extent = v;\n\t}\n\n\t/*\n\t * Constructor/initialization method\n\t */\n\tfunction _instance(config) {\n\t\tif(null != config && null != config.extent) {\n\t\t\tsetExtent(config.extent);\n\t\t}\n\t}\n\n\n\t/**\n\t * Public API\n\t */\n\n\t/*\n\t * Get/Set the extent to use \n\t */\n\t_instance.extent = function(v) {\n\t\tif(!arguments.length) { return _extent; }\n\t\tsetExtent(v);\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Get/Set the values accessor function\n\t */\n\t_instance.values = function(v) {\n\t\tif(!arguments.length) { return _fn.values; }\n\t\t_fn.values = v;\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Calculate the extent given some data.\n\t * - Default values are used in the absence of data\n\t * - Override values are used to clamp or extend the extent\n\t */\n\t_instance.getExtent = function(data) {\n\t\tvar toReturn;\n\n\t\tdata.forEach(function(e) {\n\t\t\tvar tExtent = _extent.getExtent(_fn.values(e));\n\t\t\tif(null == toReturn) {\n\t\t\t\ttoReturn = tExtent;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttoReturn[0] = Math.min(toReturn[0], tExtent[0]);\n\t\t\t\ttoReturn[1] = Math.max(toReturn[1], tExtent[1]);\n\t\t\t}\n\t\t});\n\n\t\t// In case there was no data\n\t\tif(null == toReturn) {\n\t\t\ttoReturn = _extent.getExtent([]);\n\t\t}\n\n\t\treturn toReturn;\n\t};\n\n\t// Initialize the model\n\t_instance(config);\n\n\treturn _instance;\n}","var sentio_model = sentio.model = {};","sentio.model.bins = sentio_model_bins;\n\nfunction sentio_model_bins(config) {\n\t'use strict';\n\n\t/**\n\t * Private variables\n\t */\n\t// Configuration\n\tvar _config = {\n\t\t// The number of bins in our model\n\t\tcount: 1,\n\n\t\t// The size of a bin in key value units\n\t\tsize: undefined,\n\n\t\t// The min and max bins\n\t\tlwm: undefined,\n\t\thwm: undefined\n\t};\n\n\tvar _fn = {\n\t\t// The default function for creating the seed value for a bin\n\t\tcreateSeed: function() { return []; },\n\n\t\t// The default key function\n\t\tgetKey: function(d) { return d; },\n\n\t\t// The default value function\n\t\tgetValue: function(d) { return d; },\n\n\t\t// The default function for updating a bin given a new value\n\t\tupdateBin: function(bin, d) { bin[1].push(d); },\n\n\t\t// The default function for counting the contents of the bins (includes code for backward compatibility)\n\t\tcountBin: function(bin) {\n\t\t\t// If the bin contains a number, just return it\n\t\t\tif (typeof bin[1] === 'number') {\n\t\t\t\treturn bin[1];\n\t\t\t}\n\t\t\t// If the bin contains an array of data, return the number of items\n\t\t\tif (bin[1].hasOwnProperty('length')) {\n\t\t\t\treturn bin[1].length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\t// The default function to be called after items are added to the bins\n\t\tafterAdd: function(bins, currentCount, previousCount) {},\n\n\t\t// The default function to be called after the bins are updated\n\t\tafterUpdate: function(bins, currentCount, previousCount) {}\n\t};\n\n\t// The data (an array of object containers)\n\tvar _data = [];\n\n\t// A cached total count of all the objects in the bins\n\tvar _dataCount = 0;\n\n\n\t/**\n\t * Private Functions\n\t */\n\n\t// Get the index given the value\n\tfunction getIndex(v) {\n\t\tif(null == _config.size || null == _config.lwm) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.floor((v - _config.lwm)/_config.size);\n\t}\n\n\tfunction calculateHwm() {\n\t\t_config.hwm = _config.lwm + (_config.count * _config.size);\n\t}\n\n\tfunction updateState() {\n\t\tvar bin;\n\t\tvar prevCount = _dataCount;\n\n\t\t// drop stuff below the lwm\n\t\twhile(_data.length > 0 && _data[0][0] < _config.lwm) {\n\t\t\tbin = _data.shift();\n\t\t\t_dataCount -= _fn.countBin(bin);\n\t\t}\n\n\t\t// drop stuff above the hwm\n\t\twhile(_data.length > 0 && _data[_data.length - 1][0] >= _config.hwm) {\n\t\t\tbin = _data.pop();\n\t\t\t_dataCount -= _fn.countBin(bin);\n\t\t}\n\n\t\t// if we emptied the array, add an element for the lwm\n\t\tif(_data.length === 0) {\n\t\t\t_data.push([_config.lwm, _fn.createSeed()]);\n\t\t}\n\n\t\t// fill in any missing values from the lowest bin to the lwm\n\t\tfor(var i=_data[0][0] - _config.size; i >= _config.lwm; i -= _config.size) {\n\t\t\t_data.unshift([i, _fn.createSeed()]);\n\t\t}\n\n\t\t// pad above the hwm\n\t\twhile(_data[_data.length - 1][0] < _config.hwm - _config.size) {\n\t\t\t_data.push([_data[_data.length-1][0] + _config.size, _fn.createSeed()]);\n\t\t}\n\t\tif (_fn.afterUpdate) {\n\t\t\t_fn.afterUpdate.call(model, _data, _dataCount, prevCount);\n\t\t}\n\t}\n\n\tfunction addData(dataToAdd) {\n\t\tvar prevCount = _dataCount;\n\n\t\tdataToAdd.forEach(function(element) {\n\t\t\tvar i = getIndex(_fn.getKey(element));\n\t\t\tif(i >= 0 && i < _data.length) {\n\t\t\t\tvar value = _fn.getValue(element);\n\t\t\t\tvar prevBinCount = _fn.countBin(_data[i]);\n\t\t\t\t_fn.updateBin.call(model, _data[i], value);\n\t\t\t\t_dataCount += _fn.countBin(_data[i]) - prevBinCount;\n\t\t\t}\n\t\t});\n\t\tif (_fn.afterAdd) {\n\t\t\t_fn.afterAdd.call(model, _data, _dataCount, prevCount);\n\t\t}\n\t}\n\n\tfunction clearData() {\n\t\t_data.length = 0;\n\t\t_dataCount = 0;\n\t}\n\n\n\t/*\n\t * Constructor/initialization method\n\t */\n\tfunction model(binConfig) {\n\t\tif(null == binConfig || null == binConfig.size || null == binConfig.count || null == binConfig.lwm) {\n\t\t\tthrow new Error('You must provide an initial size, count, and lwm');\n\t\t}\n\t\t_config.size = binConfig.size;\n\t\t_config.count = binConfig.count;\n\t\t_config.lwm = binConfig.lwm;\n\n\t\tif(null != binConfig.createSeed) { _fn.createSeed = binConfig.createSeed; }\n\t\tif(null != binConfig.getKey) { _fn.getKey = binConfig.getKey; }\n\t\tif(null != binConfig.getValue) { _fn.getValue = binConfig.getValue; }\n\t\tif(null != binConfig.updateBin) { _fn.updateBin = binConfig.updateBin; }\n\t\tif(null != binConfig.countBin) { _fn.countBin = binConfig.countBin; }\n\t\tif(null != binConfig.afterAdd) { _fn.afterAdd = binConfig.afterAdd; }\n\t\tif(null != binConfig.afterUpdate) { _fn.afterUpdate = binConfig.afterUpdate; }\n\n\t\tcalculateHwm();\n\t\tupdateState();\n\t}\n\n\n\t/**\n\t * Public API\n\t */\n\n\t/**\n\t * Resets the model with the new data\n\t */\n\tmodel.set = function(data) {\n\t\tclearData();\n\t\tupdateState();\n\t\taddData(data);\n\t\treturn model;\n\t};\n\n\t/**\n\t * Clears the data currently in the bin model\n\t */\n\tmodel.clear = function() {\n\t\tclearData();\n\t\tupdateState();\n\t\treturn model;\n\t};\n\n\t/**\n\t * Add an array of data objects to the bins\n\t */\n\tmodel.add = function(dataToAdd) {\n\t\taddData(dataToAdd);\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the low water mark value\n\t */\n\tmodel.lwm = function(v) {\n\t\tif(!arguments.length) { return _config.lwm; }\n\n\t\tvar oldLwm = _config.lwm;\n\t\t_config.lwm = Number(v);\n\n\t\tcalculateHwm();\n\n\t\tif((oldLwm - _config.lwm) % _config.size !== 0) {\n\t\t\t// the difference between watermarks is not a multiple of the bin size, so we need to reset\n\t\t\tclearData();\n\t\t}\n\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get the high water mark\n\t */\n\tmodel.hwm = function() {\n\t\treturn _config.hwm;\n\t};\n\n\t/**\n\t * Get/Set the key function used to determine the key value for indexing into the bins\n\t */\n\tmodel.getKey = function(v) {\n\t\tif(!arguments.length) { return _fn.getKey; }\n\t\t_fn.getKey = v;\n\n\t\tclearData();\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the value function for determining what value is added to the bin\n\t */\n\tmodel.getValue = function(v) {\n\t\tif(!arguments.length) { return _fn.getValue; }\n\t\t_fn.getValue = v;\n\n\t\tclearData();\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it\n\t */\n\tmodel.updateBin = function(v) {\n\t\tif(!arguments.length) { return _fn.updateBin; }\n\t\t_fn.updateBin = v;\n\n\t\tclearData();\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the seed function for populating\n\t */\n\tmodel.createSeed = function(v) {\n\t\tif(!arguments.length) { return _fn.createSeed; }\n\t\t_fn.createSeed = v;\n\n\t\tclearData();\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the countBin function for populating\n\t */\n\tmodel.countBin = function(v) {\n\t\tif(!arguments.length) { return _fn.countBin; }\n\t\t_fn.countBin = v;\n\n\t\tclearData();\n\t\tupdateState();\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the afterAdd callback function\n\t */\n\tmodel.afterAdd = function(v) {\n\t\tif(!arguments.length) { return _fn.afterAdd; }\n\t\t_fn.afterAdd = v;\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the afterAdd callback function\n\t */\n\tmodel.afterUpdate = function(v) {\n\t\tif(!arguments.length) { return _fn.afterUpdate; }\n\t\t_fn.afterUpdate = v;\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the bin size configuration\n\t */\n\tmodel.size = function(v) {\n\t\tif(!arguments.length) { return _config.size; }\n\n\t\tif(Number(v) < 1) {\n\t\t\tthrow new Error('Bin size must be a positive integer');\n\t\t}\n\n\t\t// Only change stuff if the size actually changes\n\t\tif(Number(v) !== _config.size) {\n\t\t\t_config.size = Number(v);\n\t\t\tcalculateHwm();\n\t\t\tclearData();\n\t\t\tupdateState();\n\t\t}\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Get/Set the bin count configuration\n\t */\n\tmodel.count = function(v) {\n\t\tif(!arguments.length) { return _config.count; }\n\n\t\tif(Number(v) < 1) {\n\t\t\tthrow new Error('Bin count must be a positive integer');\n\t\t}\n\n\t\t// Only change stuff if the count actually changes\n\t\tif(Number(v) !== _config.count) {\n\t\t\t_config.count = Math.floor(Number(v));\n\t\t\tcalculateHwm();\n\t\t\tupdateState();\n\t\t}\n\n\t\treturn model;\n\t};\n\n\t/**\n\t * Accessor for the bins of data\n\t * @returns {Array} Returns the complete array of bins\n\t */\n\tmodel.bins = function() {\n\t\treturn _data;\n\t};\n\n\t/**\n\t * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function\n\t * @returns {number} The count of data in the bins\n\t */\n\tmodel.itemCount = function() {\n\t\treturn _dataCount;\n\t};\n\n\t/**\n\t * Clears all the data in the bin with the given index\n\t * @param {number} i The index into the bins array of the bin to clear\n\t * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function\n\t */\n\tmodel.clearBin = function(i) {\n\t\tif (i >= 0 && i < _data.length) {\n\t\t\tvar count = _fn.countBin(_data[i]);\n\t\t\t_dataCount -= count;\n\t\t\t_data[i][1] = _fn.createSeed();\n\t\t\treturn count;\n\t\t}\n\t\treturn 0;\n\t};\n\n\t// Initialize the model\n\tmodel(config);\n\n\treturn model;\n}","var sentio_controller = sentio.controller = {};","sentio.controller.rtBins = sentio_controller_rtBins;\n\n/*\n * Controller wrapper for the bin model. Assumes binSize is in milliseconds.\n * Every time binSize elapses, updates the lwm to keep the bins shifting.\n */\nfunction sentio_controller_rtBins(config) {\n\t'use strict';\n\n\t/**\n\t * Private variables\n\t */\n\tvar _config = {\n\t\tdelay: 0,\n\t\tbinSize: 0,\n\t\tbinCount: 0\n\t};\n\n\t// The bins\n\tvar _model;\n\tvar _running;\n\n\t/**\n\t * Private Functions\n\t */\n\n\tfunction _calculateLwm() {\n\t\t// Assume the hwm is now plus two binSize\n\t\tvar hwm = Date.now() + 2*_model.size();\n\n\t\t// Trunc the hwm down to a round value based on the binSize\n\t\thwm = Math.floor(hwm/_model.size()) * _model.size();\n\n\t\t// Derive the lwm from the hwm\n\t\tvar lwm = hwm - _model.size() * _model.count();\n\n\t\treturn lwm;\n\t}\n\n\tfunction _update() {\n\t\tif(_running === true) {\n\t\t\t// need to update the lwm\n\t\t\t_model.lwm(_calculateLwm());\n\t\t\twindow.setTimeout(_update, _model.size());\n\t\t}\n\t}\n\n\tfunction _start() {\n\t\tif(!_running) {\n\t\t\t// Start the update loop\n\t\t\t_running = true;\n\t\t\t_update();\n\t\t}\n\t}\n\n\tfunction _stop() {\n\t\t// Setting running to false will stop the update loop\n\t\t_running = false;\n\t}\n\n\t// create/init method\n\tfunction controller(rtConfig) {\n\t\tif(null == rtConfig || null == rtConfig.binCount || null == rtConfig.binSize) {\n\t\t\tthrow new Error('You must provide an initial binSize and binCount');\n\t\t}\n\n\t\t_config.binSize = rtConfig.binSize;\n\t\t_config.binCount = rtConfig.binCount;\n\n\t\tif(null != rtConfig.delay) {\n\t\t\t_config.delay = rtConfig.delay;\n\t\t}\n\n\t\t_model = sentio.model.bins({\n\t\t\tsize: _config.binSize,\n\t\t\tcount: _config.binCount + 2,\n\t\t\tlwm: 0\n\t\t});\n\t\t_model.lwm(_calculateLwm());\n\n\t\t_start();\n\t}\n\n\n\n\t/**\n\t * Public API\n\t */\n\n\t/*\n\t * Get the model bins\n\t */\n\tcontroller.model = function() {\n\t\treturn _model;\n\t};\n\n\tcontroller.bins = function() {\n\t\treturn _model.bins();\n\t};\n\n\tcontroller.start = function() {\n\t\t_start();\n\t\treturn controller;\n\t};\n\n\tcontroller.stop = function() {\n\t\t_stop();\n\t\treturn controller;\n\t};\n\n\tcontroller.running = function() {\n\t\treturn _running;\n\t};\n\n\tcontroller.add = function(v) {\n\t\t_model.add(v);\n\t\treturn controller;\n\t};\n\n\tcontroller.clear = function() {\n\t\t_model.clear();\n\t\treturn controller;\n\t};\n\n\tcontroller.binSize = function(v) {\n\t\tif(!arguments.length) { return _config.binSize; }\n\n\t\tif(Number(v) < 1) {\n\t\t\tthrow new Error('Bin size must be a positive integer');\n\t\t}\n\n\t\t_config.binSize = v;\n\t\t_model.size(v);\n\t\t_model.lwm(_calculateLwm());\n\n\t\treturn controller;\n\t};\n\n\tcontroller.binCount = function(v) {\n\t\tif(!arguments.length) { return _config.binCount; }\n\n\t\tif(Number(v) < 1) {\n\t\t\tthrow new Error('Bin count must be a positive integer');\n\t\t}\n\n\t\t_config.binCount = v;\n\t\t_model.count(v + 2);\n\t\t_model.lwm(_calculateLwm());\n\n\t\treturn controller;\n\t};\n\n\t// Initialize the layout\n\tcontroller(config);\n\n\treturn controller;\n}","var sentio_chart = sentio.chart = {};","sentio.chart.donut = sentio_chart_donut;\n\nfunction sentio_chart_donut() {\n\t'use strict';\n\n\t// Chart height/width\n\tvar _width = 400;\n\tvar _height = 400;\n\tvar _margin = { top: 2, bottom: 2, right: 2, left: 2 };\n\n\t// Inner and outer radius settings\n\tvar _radius;\n\tvar _innerRadiusRatio = 0.7;\n\n\t// Transition duration\n\tvar _duration = 500;\n\n\t// Legend configuration\n\tvar _legend = {\n\t\tenabled: true,\n\t\tmarkSize: 16,\n\t\tmarkMargin: 8,\n\t\tlabelOffset: 2,\n\t\tposition: 'center', // only option right now\n\t\tlayout: 'vertical'\n\t};\n\n\t// d3 dispatcher for handling events\n\tvar _dispatch = d3.dispatch('onMouseOver', 'onMouseOut', 'onClick');\n\n\t// Function handlers\n\tvar _fn = {\n\t\tupdateActiveElement: function(d) {\n\t\t\tvar legendEntries = _element.gLegend.selectAll('g.entry');\n\t\t\tvar arcs = _element.gChart.selectAll('path.arc');\n\n\t\t\tif(null != d && null != d.data) {\n\t\t\t\td = d.data;\n\t\t\t}\n\n\t\t\tif(null != d) {\n\t\t\t\t// Set the highlight on the row\n\t\t\t\tvar key = _fn.key(d);\n\t\t\t\tlegendEntries.classed('active', function(e){\n\t\t\t\t\treturn _fn.key(e) == key;\n\t\t\t\t});\n\t\t\t\tarcs.classed('active', function(e){\n\t\t\t\t\treturn _fn.key(e.data) == key;\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlegendEntries.classed('active', false);\n\t\t\t\tarcs.classed('active', false);\n\t\t\t}\n\t\t},\n\t\tonMouseOver: function(d, i) {\n\t\t\t_fn.updateActiveElement(d);\n\t\t\t_dispatch.onMouseOver(d, this);\n\t\t},\n\t\tonMouseOut: function(d, i) {\n\t\t\t_fn.updateActiveElement();\n\t\t\t_dispatch.onMouseOut(d, this);\n\t\t},\n\t\tonClick: function(d, i) {\n\t\t\t_dispatch.onClick(d, this);\n\t\t},\n\t\tkey: function(d, i) { return d.key; },\n\t\tvalue: function(d, i) { return d.value; },\n\t\tlabel: function(d, i) { return d.key + ' (' + d.value + ')'; }\n\t};\n\n\n\t// Extents\n\tvar _extent = {\n\t};\n\n\tvar _scale = {\n\t\tcolor: d3.scale.category10()\n\t};\n\n\tvar _layout = {\n\t\tarc: d3.svg.arc(),\n\t\tpie: d3.layout.pie().value(_fn.value).sort(null)\n\t};\n\n\t// elements\n\tvar _element = {\n\t\tdiv: undefined,\n\t\tsvg: undefined,\n\t\tgChart: undefined,\n\t\tlegend: undefined\n\t};\n\n\tvar _data = [];\n\n\t// Chart create/init method\n\tfunction _instance(selection){}\n\n\t/*\n\t * Initialize the chart (should only call this once). Performs all initial chart\n\t * creation and setup\n\t */\n\t_instance.init = function(container){\n\t\t// Create the DIV element\n\t\t_element.div = container.append('div').attr('class', 'sentio donut');\n\n\t\t// Create the svg element\n\t\t_element.svg = _element.div.append('svg');\n\n\t\t// Create the main chart group\n\t\t_element.gChart = _element.svg.append('g').attr('class', 'chart');\n\n\t\t// Create a group for the legend\n\t\t_element.gLegend = _element.svg.append('g').attr('class', 'legend');\n\n\t\t_instance.resize();\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Set the _instance data\n\t */\n\t_instance.data = function(v) {\n\t\tif(!arguments.length) { return _data; }\n\t\t_data = v || [];\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Updates all the elements that depend on the size of the various components\n\t */\n\t_instance.resize = function() {\n\t\tvar chartWidth = _width - _margin.right - _margin.left;\n\t\tvar chartHeight = _height - _margin.top - _margin.bottom;\n\t\t_radius = (Math.min(chartHeight, chartWidth))/2;\n\n\t\t_element.svg\n\t\t\t.attr('width', _width)\n\t\t\t.attr('height', _height);\n\n\t\t_element.gChart\n\t\t\t.attr('transform', 'translate(' + (_margin.left + _radius) + ',' + (_margin.top + _radius) + ')');\n\n\t\t// The outer radius is half of the lesser of the two (chartWidth/chartHeight)\n\t\t_layout.arc.innerRadius(_radius * _innerRadiusRatio).outerRadius(_radius);\n\n\t\t// Update legend positioning\n\t\t_element.gLegend.attr('transform', legendTransform());\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Redraw the graphic\n\t */\n\t_instance.redraw = function() {\n\n\t\tredrawChart();\n\n\t\tif (_legend.enabled) {\n\t\t\tredrawLegend();\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\t/**\n\t * Private functions\n\t */\n\tfunction redrawChart() {\n\t\t/*\n\t\t * Join the data\n\t\t */\n\t\tvar g = _element.gChart.selectAll('path.arc')\n\t\t\t.data(_layout.pie(_data), function(d, i) { return _fn.key(d.data, i); });\n\n\t\t/*\n\t\t * Update Only\n\t\t */\n\n\t\t/*\n\t\t * Enter Only\n\t\t * Create the path, add the arc class, register the callbacks\n\t\t * Grow from 0 for both start and end angles\n\t\t */\n\t\tvar gEnter = g.enter().append('path')\n\t\t\t.attr('class', 'arc')\n\t\t\t.on('mouseover', _fn.onMouseOver)\n\t\t\t.on('mouseout', _fn.onMouseOut)\n\t\t\t.on('click', _fn.onClick)\n\t\t\t.each(function(d) { this._current = { startAngle: 0, endAngle: 0 }; });\n\n\t\t/*\n\t\t * Enter + Update\n\t\t * Apply the update from current angle to next angle\n\t\t */\n\t\tg.transition().duration(_duration)\n\t\t\t.attrTween('d', function(d) {\n\t\t\t\tvar interpolate = d3.interpolate(this._current, d);\n\t\t\t\tthis._current = interpolate(0);\n\t\t\t\treturn function(t) {\n\t\t\t\t\treturn _layout.arc(interpolate(t));\n\t\t\t\t};\n\t\t\t});\n\n\t\tg.attr('key', function(d, i) { return _fn.key(d.data, i); })\n\t\t\t.attr('fill', function(d, i) { return _scale.color(_fn.key(d.data, i)); });\n\n\t\tg.exit().remove();\n\t}\n\n\tfunction legendTransform() {\n\t\tvar entrySpan = _legend.markSize + _legend.markMargin;\n\n\t\t// Only option is 'center' for now\n\t\tif (_legend.position === 'center') {\n\t\t\t// The center position of the chart\n\t\t\tvar centerX = _margin.left + _radius;\n\t\t\tvar centerY = _margin.top + _radius;\n\t\t\tvar legendWidth = (null == _element.gLegend._maxWidth)? 0 : _element.gLegend._maxWidth;\n\t\t\tvar legendHeight = entrySpan*_data.length + _legend.markMargin;\n\n\t\t\tvar offsetX = legendWidth/2;\n\t\t\tvar offsetY = legendHeight/2;\n\n\t\t\treturn 'translate(' + (centerX - offsetX) + ',' + (centerY - offsetY) + ')';\n\t\t} else {\n\t\t\t// TODO\n\t\t}\n\t}\n\n\tfunction redrawLegend() {\n\t\t/*\n\t\t * Join the data\n\t\t */\n\t\tvar gLegendGroup = _element.gLegend.selectAll('g.entry')\n\t\t\t.data(_data, function(d, i) { return _fn.key(d, i); });\n\n\t\t/*\n\t\t * Enter Only\n\t\t * Create a g (gLegendGroup) to add the rect & text label,\n\t\t * register the callbacks, apply the transform to position each gLegendGroup\n\t\t */\n\t\tvar gLegendGroupEnter = gLegendGroup.enter().append('g')\n\t\t\t.attr('class', 'entry')\n\t\t\t.attr('transform', function(d, i) { return 'translate(0, ' + (i*(_legend.markSize + _legend.markMargin)) + ')'; } )\n\t\t\t.on('mouseover', _fn.onMouseOver)\n\t\t\t.on('mouseout', _fn.onMouseOut)\n\t\t\t.on('click', _fn.onClick);\n\n\t\t// Add the legend's rect\n\t\tvar rect = gLegendGroupEnter\n\t\t\t.append('rect')\n\t\t\t.attr('width', _legend.markSize)\n\t\t\t.attr('height', _legend.markSize);\n\n\t\t// Add the legend text\n\t\tgLegendGroupEnter\n\t\t\t.append('text')\n\t\t\t.attr('x', _legend.markSize + _legend.markMargin)\n\t\t\t.attr('y', _legend.markSize - _legend.labelOffset);\n\n\t\t/*\n\t\t * Enter + Update\n\t\t */\n\t\tgLegendGroup.select('text')\n\t\t\t.text(function(d, i) { return _fn.label(d, i); });\n\n\t\tgLegendGroup.select('rect')\n\t\t\t.style('fill', function(d) { return _scale.color(_fn.key(d)); });\n\n\t\t// Position each rect on both enter and update to fully account for changing widths and sizes\n\t\tgLegendGroup\n\t\t\t// Iterate over all the legend keys to get the max width and store it in gLegendGroup._maxWidth\n\t\t\t.each(function(d, i) {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// Reset\n\t\t\t\t\t_element.gLegend._maxWidth = this.getBBox().width;\n\t\t\t\t} else {\n\t\t\t\t\t_element.gLegend._maxWidth = Math.max(this.getBBox().width, _element.gLegend._maxWidth);\n\t\t\t\t}\n\t\t\t});\n\n\t\t// Reassert the legend position\n\t\t_element.gLegend.attr('transform', legendTransform());\n\n\t\tgLegendGroup.exit().remove();\n\t}\n\n\t// Basic Getters/Setters\n\t_instance.width = function(v) {\n\t\tif(!arguments.length) { return _width; }\n\t\t_width = v;\n\t\treturn _instance;\n\t};\n\t_instance.height = function(v) {\n\t\tif(!arguments.length) { return _height; }\n\t\t_height = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.innerRadiusRatio = function(v) {\n\t\tif(!arguments.length) { return _innerRadiusRatio; }\n\t\t_innerRadiusRatio = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.duration = function(v) {\n\t\tif(!arguments.length) { return _duration; }\n\t\t_duration = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.key = function(v) {\n\t\tif(!arguments.length) { return _fn.key; }\n\t\t_fn.key = v;\n\t\treturn _instance;\n\t};\n\t_instance.value = function(v) {\n\t\tif(!arguments.length) { return _fn.value; }\n\t\t_fn.value = v;\n\t\t_layout.pie.value(v);\n\t\treturn _instance;\n\t};\n\t_instance.label = function(v) {\n\t\tif(!arguments.length) { return _fn.label; }\n\t\t_fn.label = v;\n\t\treturn _instance;\n\t};\n\t_instance.color = function(v) {\n\t\tif(!arguments.length) { return _scale.color; }\n\t\t_scale.color = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.dispatch = function(v) {\n\t\tif(!arguments.length) { return _dispatch; }\n\t\treturn _instance;\n\t};\n\n\t_instance.legend = function(v) {\n\t\tif(!arguments.length) { return _legend; }\n\t\t_legend = v;\n\t\treturn _instance;\n\t};\n\n\treturn _instance;\n}","sentio.chart.matrix = sentio_chart_matrix;\n\nfunction sentio_chart_matrix() {\n\t'use strict';\n\n\t// Chart dimensions\n\tvar _cellSize = 16;\n\tvar _cellMargin = 1;\n\tvar _margin = { top: 20, right: 2, bottom: 2, left: 64 };\n\n\t// Transition duration\n\tvar _duration = 500;\n\n\t// d3 dispatcher for handling events\n\tvar _dispatch = d3.dispatch('onMouseOverCell', 'onMouseOutCell', 'onClickCell', 'onMouseOverRow', 'onMouseOutRow', 'onClickRow');\n\n\t// Function handlers\n\tvar _fn = {\n\t\tupdateActiveSeries: function(d) {\n\t\t\tvar seriesLabels = _element.g.chart.selectAll('.row text');\n\n\t\t\tif(null != d) {\n\t\t\t\t// Set the highlight on the row\n\t\t\t\tvar seriesKey = _fn.seriesKey(d);\n\t\t\t\tseriesLabels.classed('active', function(series, i){ return _fn.seriesKey(series) == seriesKey; });\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Now update the style\n\t\t\t\tseriesLabels.classed('active', false);\n\t\t\t}\n\t\t},\n\t\tonMouseOverRow: function(d, i) {\n\t\t\t_fn.updateActiveSeries(d);\n\t\t\t_dispatch.onMouseOverRow(d, this);\n\t\t},\n\t\tonMouseOutRow: function(d, i) {\n\t\t\t_fn.updateActiveSeries();\n\t\t\t_dispatch.onMouseOutRow(d, this);\n\t\t},\n\t\tonClickRow: function(d, i) {\n\t\t\t_dispatch.onClickRow(d, this);\n\t\t},\n\t\tonMouseOverCell: function(d, i) {\n\t\t\t_dispatch.onMouseOverCell(d, this);\n\t\t},\n\t\tonMouseOutCell: function(d, i) {\n\t\t\t_dispatch.onMouseOutCell(d, this);\n\t\t},\n\t\tonClickCell: function(d, i) {\n\t\t\t_dispatch.onClickCell(d, this);\n\t\t},\n\t\tseriesKey: function(d, i) { return d.key; },\n\t\tseriesLabel: function(d, i) { return d.label; },\n\t\tseriesValues: function(d, i) { return d.values; },\n\t\tkey: function(d, i) { return d.key; },\n\t\tvalue: function(d, i) { return d.value; }\n\t};\n\n\t// Extents\n\tvar _extent = {\n\t\tx: sentio.util.extent().getValue(_fn.key),\n\t\tvalue: sentio.util.extent().getValue(_fn.value),\n\t\tmulti: sentio.util.multiExtent()\n\t};\n\n\t// Scales for x, y, and color\n\tvar _scale = {\n\t\tx: d3.scale.linear(),\n\t\ty: d3.scale.ordinal(),\n\t\tcolor: d3.scale.linear().range(['#e7e7e7', '#008500'])\n\t};\n\n\tvar _axis = {\n\t\tx: d3.svg.axis().scale(_scale.x).orient('top').outerTickSize(0).innerTickSize(2)\n\t};\n\n\tvar _element = {\n\t\tdiv: undefined,\n\t\tsvg: undefined,\n\t\tg: {\n\t\t\tchart: undefined,\n\t\t\txAxis: undefined\n\t\t}\n\t};\n\n\tvar _data = [];\n\n\tvar _instance = function () {};\n\n\t_instance.init = function(d3Container) {\n\t\t// Add the svg element\n\t\t_element.div = d3Container.append('div').attr('class', 'sentio matrix');\n\t\t_element.svg = _element.div.append('svg');\n\n\t\t// Add the axis\n\t\t_element.g.xAxis = _element.svg.append('g').attr('class', 'x axis');\n\n\t\t// Add a group for the chart itself\n\t\t_element.g.chart = _element.svg.append('g').attr('class', 'chart');\n\n\t\t_instance.resize();\n\n\t\treturn _instance;\n\t};\n\n\t_instance.data = function(d) {\n\t\tif(!arguments.length) {\n\t\t\treturn _data;\n\t\t}\n\t\t_data = d || [];\n\t\treturn _instance;\n\t};\n\n\t_instance.resize = function() { };\n\n\t_instance.redraw = function() {\n\t\t// Determine the number of rows to render\n\t\tvar rowCount = _data.length;\n\n\t\t// Determine the number of boxes to render (assume complete data)\n\t\tvar boxes = [];\n\t\tif(rowCount > 0) {\n\t\t\tboxes = _fn.seriesValues(_data[0]);\n\t\t}\n\t\tvar boxCount = boxes.length;\n\n\t\t// Dimensions of the visualization\n\t\tvar cellSpan = _cellMargin + _cellSize;\n\n\t\t// calculate the width/height of the svg\n\t\tvar width = boxCount*cellSpan + _cellMargin,\n\t\t\theight = rowCount*cellSpan + _cellMargin;\n\n\t\t// scale the svg to the right size\n\t\t_element.svg\n\t\t\t.attr('width', width + _margin.left + _margin.right)\n\t\t\t.attr('height', height + _margin.top + _margin.bottom);\n\n\t\t// Configure the scales\n\t\t_scale.x.domain(_extent.x.getExtent(boxes)).range([0, width - _cellMargin - cellSpan]);\n\t\t_scale.color.domain(_extent.multi.values(_fn.seriesValues).extent(_extent.value).getExtent(_data));\n\n\t\t// Draw the x axis\n\t\t_element.g.xAxis.attr('transform', 'translate(' + (_margin.left + _cellMargin + _cellSize/2) + \",\" + _margin.top + \")\");\n\t\t_element.g.xAxis.call(_axis.x);\n\n\t\t/**\n\t\t * Chart Manipulation\n\t\t */\n\n\t\t/*\n\t\t * Row Join\n\t\t */\n\t\tvar row = _element.g.chart.selectAll('g.row').data(_data, _fn.seriesKey);\n\n\t\t/*\n\t\t * Row Update Only\n\t\t */\n\n\t\t/*\n\t\t * Row Enter Only\n\t\t * Build the row structure\n\t\t */\n\t\tvar rowEnter = row.enter().append('g');\n\t\trowEnter\n\t\t\t.style('opacity', 0.1)\n\t\t\t.attr('class', 'row')\n\t\t\t.attr('transform', function(d, i) { return 'translate(' + _margin.left + ',' + (_margin.top + (cellSpan*i)) + ')'; })\n\t\t\t.on('mouseover', _fn.onMouseOverRow)\n\t\t\t.on('mouseout', _fn.onMouseOutRow)\n\t\t\t.on('click', _fn.onClickRow);\n\n\t\t// Also must append the label of the row\n\t\trowEnter.append('text')\n\t\t\t.attr('class', 'series label')\n\t\t\t.style('text-anchor', 'end')\n\t\t\t.attr('x', -6)\n\t\t\t.attr('y', _cellMargin + (_cellSize/2))\n\t\t\t.attr('dy', '.32em');\n\n\t\t// Also must append a line\n\t\trowEnter.append('line')\n\t\t\t.attr('class', 'series tick')\n\t\t\t.attr('x1', -3)\n\t\t\t.attr('x2', 0)\n\t\t\t.attr('y1', _cellMargin + (_cellSize/2))\n\t\t\t.attr('y2', _cellMargin + (_cellSize/2));\n\n\t\t/*\n\t\t * Row Enter + Update\n\t\t */\n\t\t// Transition rows to their new positions\n\t\trow.transition().duration(_duration)\n\t\t\t.style('opacity', 1)\n\t\t\t.attr('transform', function(d, i){\n\t\t\t\treturn 'translate(' + _margin.left + ',' + (_margin.top + (cellSpan*i)) + ')';\n\t\t\t});\n\n\t\t// Update the series labels in case they changed\n\t\trow.select('text.series.label')\n\t\t\t.text(_fn.seriesLabel);\n\n\t\t/*\n\t\t * Row Exit\n\t\t */\n\t\trow.exit()\n\t\t\t.transition().duration(_duration)\n\t\t\t.style('opacity', 0.1)\n\t\t\t.remove();\n\n\n\t\t/*\n\t\t * Cell Join - Will be done on row enter + exit\n\t\t */\n\t\tvar rowCell = row.selectAll('rect.cell').data(_fn.seriesValues, _fn.key);\n\n\t\t/*\n\t\t * Cell Update Only\n\t\t */\n\n\t\t/*\n\t\t * Cell Enter Only\n\t\t */\n\t\trowCell.enter().append('rect')\n\t\t\t.attr('class', 'cell')\n\t\t\t.style('opacity', 0.1)\n\t\t\t.style('fill', function(d, i) { return _scale.color(_fn.value(d, i)); })\n\t\t\t.attr('x', function(d, i){ return _scale.x(_fn.key(d, i)) + _cellMargin; })\n\t\t\t.attr('y', _cellMargin)\n\t\t\t.attr('height', _cellSize)\n\t\t\t.attr('width', _cellSize)\n\t\t\t.on('mouseover', _fn.onMouseOverCell)\n\t\t\t.on('mouseout', _fn.onMouseOutCell)\n\t\t\t.on('click', _fn.onClickCell);\n\n\t\t/*\n\t\t * Cell Enter + Update\n\t\t * Update fill, move to proper x coordinate\n\t\t */\n\t\trowCell.transition().duration(_duration)\n\t\t\t.style('opacity', 1)\n\t\t\t.attr('x', function(d, i){ return _scale.x(_fn.key(d, i)) + _cellMargin; })\n\t\t\t.style('fill', function(d, i) { return _scale.color(_fn.value(d, i)); });\n\n\t\t/*\n\t\t * Cell Remove\n\t\t */\n\t\trowCell.exit().transition().duration(_duration)\n\t\t\t.attr('width', 0)\n\t\t\t.style('opacity', 0.1)\n\t\t\t.remove();\n\n\t\treturn _instance;\n\t};\n\n\n\t_instance.cellSize = function(v) {\n\t\tif(!arguments.length) { return _cellSize; }\n\t\t_cellSize = v;\n\t\treturn _instance;\n\t};\n\t_instance.cellMargin = function(v) {\n\t\tif(!arguments.length) { return _cellMargin; }\n\t\t_cellMargin = v;\n\t\treturn _instance;\n\t};\n\t_instance.margin = function(v) {\n\t\tif(!arguments.length) { return _margin; }\n\t\t_margin = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.duration = function(v) {\n\t\tif(!arguments.length) { return _duration; }\n\t\t_duration = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.seriesKey = function(v) {\n\t\tif(!arguments.length) { return _fn.seriesKey; }\n\t\t_fn.seriesKey = v;\n\t\treturn _instance;\n\t};\n\t_instance.seriesLabel = function(v) {\n\t\tif(!arguments.length) { return _fn.seriesLabel; }\n\t\t_fn.seriesLabel = v;\n\t\treturn _instance;\n\t};\n\t_instance.seriesValues = function(v) {\n\t\tif(!arguments.length) { return _fn.seriesValues; }\n\t\t_fn.seriesValues = v;\n\t\treturn _instance;\n\t};\n\t_instance.key = function(v) {\n\t\tif(!arguments.length) { return _fn.key; }\n\t\t_extent.x.getValue(v);\n\t\t_fn.key = v;\n\t\treturn _instance;\n\t};\n\t_instance.value = function(v) {\n\t\tif(!arguments.length) { return _fn.value; }\n\t\t_fn.value = v;\n\t\t_extent.value.getValue(v);\n\t\treturn _instance;\n\t};\n\n\t_instance.colorScale = function(v) {\n\t\tif(!arguments.length) { return _scale.color; }\n\t\t_scale.color = v;\n\t\treturn _instance;\n\t};\n\t_instance.xScale = function(v) {\n\t\tif(!arguments.length) { return _scale.xScale; }\n\t\t_scale.xScale = v;\n\t\t_axis.x.scale(v);\n\t\treturn _instance;\n\t};\n\t_instance.yScale = function(v) {\n\t\tif(!arguments.length) { return _scale.yScale; }\n\t\t_scale.yScale = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.xExtent = function(v) {\n\t\tif(!arguments.length) { return _extent.x; }\n\t\t_extent.x = v;\n\t\treturn _instance;\n\t};\n\t_instance.yExtent = function(v) {\n\t\tif(!arguments.length) { return _extent.y; }\n\t\t_extent.y = v;\n\t\treturn _instance;\n\t};\n\t_instance.valueExtent = function(v) {\n\t\tif(!arguments.length) { return _extent.value; }\n\t\t_extent.value = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.dispatch = function(v) {\n\t\tif(!arguments.length) { return _dispatch; }\n\t\treturn _instance;\n\t};\n\n\treturn _instance;\n}","sentio.chart.verticalBars = sentio_chart_vertical_bars;\n\nfunction sentio_chart_vertical_bars() {\n\t'use strict';\n\n\t// Layout properties\n\tvar _id = 'vertical_bars_' + Date.now();\n\tvar _margin = { top: 0, right: 0, bottom: 0, left: 0 };\n\tvar _width = 100;\n\tvar _barHeight = 24;\n\tvar _barPadding = 2;\n\tvar _duration = 500;\n\n\t// d3 dispatcher for handling events\n\tvar _dispatch = d3.dispatch('onmouseover', 'onmouseout', 'onclick');\n\tvar _fn = {\n\t\tonMouseOver: function(d, i) {\n\t\t\t_dispatch.onmouseover(d, this);\n\t\t},\n\t\tonMouseOut: function(d, i) {\n\t\t\t_dispatch.onmouseout(d, this);\n\t\t},\n\t\tonClick: function(d, i) {\n\t\t\t_dispatch.onclick(d, this);\n\t\t}\n\t};\n\n\t// Default accessors for the dimensions of the data\n\tvar _value = {\n\t\tkey: function(d, i) { return d.key; },\n\t\tvalue: function(d, i) { return d.value; },\n\t\tlabel: function(d, i) { return d.key + ' (' + d.value + ')'; }\n\t};\n\n\t// Default scales for x and y dimensions\n\tvar _scale = {\n\t\tx: d3.scale.linear(),\n\t\ty: d3.scale.linear()\n\t};\n\n\t// Extents\n\tvar _extent = {\n\t\twidth: sentio.util.extent({\n\t\t\tdefaultValue: [0, 10],\n\t\t\tgetValue: _value.value\n\t\t})\n\t};\n\n\t// elements\n\tvar _element = {\n\t\tdiv: undefined\n\t};\n\n\tvar _data = [];\n\n\t// Chart create/init method\n\tfunction _instance(selection){}\n\n\t/*\n\t * Initialize the chart (should only call this once). Performs all initial chart\n\t * creation and setup\n\t */\n\t_instance.init = function(container){\n\t\t// Create the DIV element\n\t\t_element.div = container.append('div').attr('class', 'sentio bars-vertical');\n\t\t_instance.resize();\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Set the _instance data\n\t */\n\t_instance.data = function(v) {\n\t\tif(!arguments.length) { return _data; }\n\t\t_data = v || [];\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Updates all the elements that depend on the size of the various components\n\t */\n\t_instance.resize = function() {\n\t\t// Set up the x scale (y is fixed)\n\t\t_scale.x.range([0, _width - _margin.right - _margin.left]);\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Redraw the graphic\n\t */\n\t_instance.redraw = function() {\n\n\t\t// Update the x domain\n\t\t_scale.x.domain(_extent.width.getExtent(_data));\n\n\t\t// Update the y domain (based on configuration and data)\n\t\t_scale.y.domain([0, _data.length]);\n\t\t_scale.y.range([0, (_barHeight + _barPadding) * _data.length]);\n\n\t\t// Data Join\n\t\tvar div = _element.div.selectAll('div.bar')\n\t\t\t.data(_data, _value.key);\n\n\t\t// Update Only\n\n\t\t// Enter\n\t\tvar bar = div.enter().append('div')\n\t\t\t.attr('class', 'bar')\n\t\t\t.style('top', (_scale.y.range()[1] + _margin.top + _margin.bottom - _barHeight) + 'px')\n\t\t\t.style('height', _barHeight + 'px')\n\t\t\t.on('mouseover', _fn.onMouseOver)\n\t\t\t.on('mouseout', _fn.onMouseOut)\n\t\t\t.on('click', _fn.onClick)\n\t\t\t.style('opacity', 0.01);\n\n\t\tbar.append('div')\n\t\t\t.attr('class', 'bar-label');\n\n\t\t// Enter + Update\n\t\tdiv.transition().duration(_duration)\n\t\t\t.style('opacity', 1)\n\t\t\t.style('width', function(d, i) { return _scale.x(_value.value(d, i)) + 'px'; })\n\t\t\t.style('top', function(d, i) { return (_scale.y(i) + _margin.top) + 'px'; })\n\t\t\t.style('left', _margin.left + 'px');\n\n\t\tdiv.select('div.bar-label')\n\t\t\t.html(_value.label)\n\t\t\t.style('max-width', (_scale.x.range()[1] - 10) + 'px');\n\n\t\t// Exit\n\t\tdiv.exit()\n\t\t\t.transition().duration(_duration)\n\t\t\t.style('opacity', 0.01)\n\t\t\t.style('top', (_scale.y.range()[1] + _margin.top + _margin.bottom - _barHeight) + 'px' )\n\t\t\t.remove();\n\n\t\t// Update the size of the parent div\n\t\t_element.div\n\t\t\t.style('height', (_margin.bottom + _margin.top + _scale.y.range()[1]) + 'px');\n\n\t\treturn _instance;\n\t};\n\n\n\t// Basic Getters/Setters\n\t_instance.width = function(v) {\n\t\tif(!arguments.length) { return _width; }\n\t\t_width = v;\n\t\treturn _instance;\n\t};\n\t_instance.barHeight = function(v) {\n\t\tif(!arguments.length) { return _barHeight; }\n\t\t_barHeight = v;\n\t\treturn _instance;\n\t};\n\t_instance.barPadding = function(v) {\n\t\tif(!arguments.length) { return _barPadding; }\n\t\t_barPadding = v;\n\t\treturn _instance;\n\t};\n\t_instance.margin = function(v) {\n\t\tif(!arguments.length) { return _margin; }\n\t\t_margin = v;\n\t\treturn _instance;\n\t};\n\t_instance.key = function(v) {\n\t\tif(!arguments.length) { return _value.key; }\n\t\t_value.key = v;\n\t\treturn _instance;\n\t};\n\t_instance.value = function(v) {\n\t\tif(!arguments.length) { return _value.value; }\n\t\t_value.value = v;\n\t\t_extent.width.getValue(v);\n\t\treturn _instance;\n\t};\n\t_instance.label = function(v) {\n\t\tif(!arguments.length) { return _value.label; }\n\t\t_value.label = v;\n\t\treturn _instance;\n\t};\n\t_instance.widthExtent = function(v) {\n\t\tif(!arguments.length) { return _extent.width; }\n\t\t_extent.width = v;\n\t\treturn _instance;\n\t};\n\t_instance.dispatch = function(v) {\n\t\tif(!arguments.length) { return _dispatch; }\n\t\treturn _instance;\n\t};\n\t_instance.duration = function(v) {\n\t\tif(!arguments.length) { return _duration; }\n\t\t_duration = v;\n\t\treturn _instance;\n\t};\n\n\treturn _instance;\n}","var sentio_timeline = sentio.timeline = {};","sentio.timeline.line = sentio_timeline_line;\n\nfunction sentio_timeline_line() {\n\t'use strict';\n\n\t// Layout properties\n\tvar _id = 'timeline_line_' + Date.now();\n\tvar _margin = { top: 10, right: 10, bottom: 20, left: 40 };\n\tvar _height = 100, _width = 600;\n\n\t/*\n\t * Callback function for hovers over the markers. Invokes this function\n\t * with the data from the marker payload\n\t */\n\tvar _markerHoverCallback = null;\n\n\t// Default accessors for the dimensions of the data\n\tvar _value = {\n\t\tx: function(d, i) { return d[0]; },\n\t\ty: function(d, i) { return d[1]; }\n\t};\n\n\t// Accessors for the positions of the markers\n\tvar _markerValue = {\n\t\tx: function(d, i) { return d[0]; },\n\t\tlabel: function(d, i) { return d[1]; }\n\t};\n\n\tvar now = Date.now();\n\tvar _extent = {\n\t\tx: sentio.util.extent({\n\t\t\tdefaultValue: [now - 60000*5, now],\n\t\t\tgetValue: function(d) { return d[0]; }\n\t\t}),\n\t\ty: sentio.util.extent({\n\t\t\tgetValue: function(d) { return d[1]; }\n\t\t})\n\t};\n\tvar _multiExtent = sentio.util.multiExtent().values(function(d) { return d.data; });\n\n\t// Default scales for x and y dimensions\n\tvar _scale = {\n\t\tx: d3.time.scale(),\n\t\ty: d3.scale.linear()\n\t};\n\n\t// Default Axis definitions\n\tvar _axis = {\n\t\tx: d3.svg.axis().scale(_scale.x).orient('bottom'),\n\t\ty: d3.svg.axis().scale(_scale.y).orient('left').ticks(3)\n\t};\n\n\t// g elements\n\tvar _element = {\n\t\tsvg: undefined,\n\t\tg: {\n\t\t\tcontainer: undefined,\n\t\t\tplots: undefined,\n\t\t\txAxis: undefined,\n\t\t\tyAxis: undefined,\n\t\t\tmarkers: undefined,\n\t\t\tbrush: undefined\n\t\t},\n\t\tplotClipPath: undefined,\n\t\tmarkerClipPath: undefined\n\t};\n\n\t// Line generator for the plot\n\tvar _line = d3.svg.line().interpolate('linear');\n\t_line.x(function(d, i) {\n\t\treturn _scale.x(_value.x(d, i));\n\t});\n\t_line.y(function(d, i) {\n\t\treturn _scale.y(_value.y(d, i));\n\t});\n\n\t// Area generator for the plot\n\tvar _area = d3.svg.area().interpolate('linear');\n\t_area.x(function(d, i) {\n\t\treturn _scale.x(_value.x(d, i));\n\t});\n\t_area.y1(function(d, i) {\n\t\treturn _scale.y(_value.y(d, i));\n\t});\n\n\t// Brush filter\n\tvar _filter = {\n\t\tenabled: false,\n\t\tbrush: d3.svg.brush(),\n\t\tdispatch: d3.dispatch('filter', 'filterstart', 'filterend')\n\t};\n\n\tvar _data = [];\n\n\tvar _markers = {\n\t\tvalues: [],\n\t\tdispatch: d3.dispatch('onclick')\n\t};\n\n\tfunction brushstart() {\n\t\tvar extent = getFilter();\n\t\tvar isEmpty = (null == extent);\n\n\t\tvar min = (isEmpty)? undefined : extent[0];\n\t\tvar max = (isEmpty)? undefined : extent[1];\n\n\t\t_filter.dispatch.filterstart([isEmpty, min, max]);\n\t}\n\tfunction brush() {\n\t\tvar extent = getFilter();\n\t\tvar isEmpty = (null == extent);\n\n\t\tvar min = (isEmpty)? undefined : extent[0];\n\t\tvar max = (isEmpty)? undefined : extent[1];\n\n\t\t_filter.dispatch.filter([isEmpty, min, max]);\n\t}\n\tfunction brushend() {\n\t\tvar extent = getFilter();\n\t\tvar isEmpty = (null == extent);\n\n\t\tvar min = (isEmpty)? undefined : extent[0];\n\t\tvar max = (isEmpty)? undefined : extent[1];\n\n\t\t_filter.dispatch.filterend([isEmpty, min, max]);\n\t}\n\n\t// Chart create/init method\n\tfunction _instance(selection){}\n\n\t/*\n\t * Initialize the chart (should only call this once). Performs all initial chart\n\t * creation and setup\n\t */\n\t_instance.init = function(container){\n\t\t// Create a container div\n\t\t_element.div = container.append('div').attr('class', 'sentio timeline');\n\n\t\t// Create the SVG element\n\t\t_element.svg = _element.div.append('svg');\n\n\t\t// Add the defs and add the clip path definition\n\t\t_element.plotClipPath = _element.svg.append('defs').append('clipPath').attr('id', 'plot_' + _id).append('rect');\n\t\t_element.markerClipPath = _element.svg.append('defs').append('clipPath').attr('id', 'marker_' + _id).append('rect');\n\n\t\t// Append a container for everything\n\t\t_element.g.container = _element.svg.append('g');\n\n\t\t// Append the path group (which will have the clip path and the line path\n\t\t_element.g.plots = _element.g.container.append('g').attr('class', 'plots').attr('clip-path', 'url(#plot_' + _id + ')');\n\n\t\t// If the filter is enabled, add it\n\t\tif(_filter.enabled) {\n\t\t\t_element.g.brush = _element.g.container.append('g').attr('class', 'x brush');\n\t\t\t_element.g.brush.call(_filter.brush)\n\t\t\t\t.selectAll('rect').attr('y', -6);\n\t\t\t_filter.brush\n\t\t\t\t.on('brushend', brushend)\n\t\t\t\t.on('brushstart', brushstart)\n\t\t\t\t.on('brush', brush);\n\t\t}\n\n\t\t// Append a group for the markers\n\t\t_element.g.markers = _element.g.container.append('g').attr('class', 'markers').attr('clip-path', 'url(#marker_' + _id + ')');\n\n\t\t// Append groups for the axes\n\t\t_element.g.xAxis = _element.g.container.append('g').attr('class', 'x axis');\n\t\t_element.g.yAxis = _element.g.container.append('g').attr('class', 'y axis');\n\n\t\t_instance.resize();\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Set the _instance data\n\t */\n\t_instance.data = function(v) {\n\t\tif(!arguments.length) { return _data; }\n\t\t_data = v;\n\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Set the markers data\n\t */\n\t_instance.markers = function(v) {\n\t\tif(!arguments.length) { return _markers.dispatch; }\n\t\t_markers.values = v;\n\t\treturn _instance;\n\t};\n\n\t/*\n\t * Accepts the hovered element and conditionally invokes\n\t * the marker hover callback if both the function and data\n\t * are non-null\n\t */\n\tfunction invokeMarkerCallback(d) {\n\t\t// fire an event with the payload\n\t\tif(null != _markerHoverCallback) {\n\t\t\t_markerHoverCallback(d);\n\t\t}\n\t}\n\n\tfunction markerClicked(d) {\n\t\t_markers.dispatch.onclick(d);\n\t}\n\n\t/*\n\t * Updates all the elements that depend on the size of the various components\n\t */\n\t_instance.resize = function() {\n\t\tvar now = Date.now();\n\n\t\t// Set up the scales\n\t\t_scale.x.range([0, Math.max(0, _width - _margin.left - _margin.right)]);\n\t\t_scale.y.range([Math.max(0, _height - _margin.top - _margin.bottom), 0]);\n\n\t\t// Append the clip path\n\t\t_element.plotClipPath\n\t\t\t.attr('transform', 'translate(0, -' + _margin.top + ')')\n\t\t\t.attr('width', Math.max(0, _width - _margin.left - _margin.right))\n\t\t\t.attr('height', Math.max(0, _height - _margin.bottom));\n\t\t_element.markerClipPath\n\t\t\t.attr('transform', 'translate(0, -' + _margin.top + ')')\n\t\t\t.attr('width', Math.max(0, _width - _margin.left - _margin.right))\n\t\t\t.attr('height', Math.max(0, _height - _margin.bottom));\n\n\t\t// Now update the size of the svg pane\n\t\t_element.svg.attr('width', _width).attr('height', _height);\n\n\t\t// Update the positions of the axes\n\t\t_element.g.xAxis.attr('transform', 'translate(0,' + _scale.y.range()[0] + ')');\n\t\t_element.g.yAxis.attr('class', 'y axis');\n\n\t\t// update the margins on the main draw group\n\t\t_element.g.container.attr('transform', 'translate(' + _margin.left + ',' + _margin.top + ')');\n\n\t\treturn _instance;\n\t};\n\n\t// Multi Extent Combiner\n\tfunction multiExtent(data, extent) {\n\t\treturn _multiExtent.extent(extent).getExtent(data);\n\t}\n\n\t/*\n\t * Redraw the graphic\n\t */\n\t_instance.redraw = function() {\n\t\t// Need to grab the filter extent before we change anything\n\t\tvar filterExtent = getFilter();\n\n\t\t// Update the x domain (to the latest time window)\n\t\t_scale.x.domain(multiExtent(_data, _extent.x));\n\n\t\t// Update the y domain (based on configuration and data)\n\t\t_scale.y.domain(multiExtent(_data, _extent.y));\n\n\t\t// Update the plot elements\n\t\tupdateAxes();\n\t\tupdateLine();\n\t\tupdateMarkers();\n\t\tupdateFilter(filterExtent);\n\n\t\treturn _instance;\n\t};\n\n\tfunction updateAxes() {\n\t\tif(null != _axis.x) {\n\t\t\t_element.g.xAxis.call(_axis.x);\n\t\t}\n\t\tif(null != _axis.y) {\n\t\t\t_element.g.yAxis.call(_axis.y);\n\t\t}\n\t}\n\n\tfunction updateLine() {\n\t\t// Join\n\t\tvar plotJoin = _element.g.plots\n\t\t\t.selectAll('.plot')\n\t\t\t.data(_data, function(d) { \n\t\t\t\treturn d.key; \n\t\t\t});\n\n\t\t// Enter\n\t\tvar plotEnter = plotJoin.enter().append('g')\n\t\t\t.attr('class', 'plot');\n\n\t\tplotEnter.append('g').append('path').attr('class', function(d) { return ((d.cssClass)? d.cssClass : '') + ' line'; });\n\t\tplotEnter.append('g').append('path').attr('class', function(d) { return ((d.cssClass)? d.cssClass : '') + ' area'; });\n\n\t\tvar lineUpdate = plotJoin.select('.line');\n\t\tvar areaUpdate = plotJoin.select('.area');\n\n\t\t// Update\n\t\tlineUpdate.datum(function(d) { return d.data; }).attr('d', _line);\n\t\tareaUpdate.datum(function(d) { return d.data; }).attr('d', _area.y0(_scale.y.range()[0]));\n\n\t\t// Exit\n\t\tvar plotExit = plotJoin.exit();\n\t\tplotExit.remove();\n\n\t}\n\n\tfunction updateMarkers() {\n\t\t// Join\n\t\tvar markerJoin = _element.g.markers\n\t\t\t.selectAll('.marker')\n\t\t\t.data(_markers.values, function(d) {\n\t\t\t\treturn _markerValue.x(d); \n\t\t\t});\n\n\t\t// Enter\n\t\tvar markerEnter = markerJoin.enter().append('g')\n\t\t\t.attr('class', 'marker')\n\t\t\t.on('mouseover', invokeMarkerCallback)\n\t\t\t.on('click', markerClicked);\n\n\t\tvar lineEnter = markerEnter.append('line');\n\t\tvar textEnter = markerEnter.append('text');\n\n\t\tvar lineUpdate = markerJoin.select('line');\n\t\tvar textUpdate = markerJoin.select('text');\n\n\t\tlineEnter\n\t\t\t.attr('y1', function(d) { return _scale.y.range()[1]; })\n\t\t\t.attr('y2', function(d) { return _scale.y.range()[0]; });\n\n\t\ttextEnter\n\t\t\t.attr('dy', '0em')\n\t\t\t.attr('y', -3)\n\t\t\t.attr('text-anchor', 'middle')\n\t\t\t.text(function(d) { return _markerValue.label(d); });\n\n\t\t// Update\n\t\tlineUpdate\n\t\t\t.attr('x1', function(d) { return _scale.x(_markerValue.x(d)); })\n\t\t\t.attr('x2', function(d) { return _scale.x(_markerValue.x(d)); });\n\n\t\ttextUpdate\n\t\t\t.attr('x', function(d) { return _scale.x(_markerValue.x(d)); });\n\n\t\t// Exit\n\t\tvar markerExit = markerJoin.exit().remove();\n\n\t}\n\n\t/*\n\t * Get the current state of the filter\n\t * Returns undefined if the filter is disabled or not set, millsecond time otherwise\n\t */\n\tfunction getFilter() {\n\t\tvar extent;\n\t\tif(_filter.enabled && !_filter.brush.empty()) {\n\t\t\textent = _filter.brush.extent();\n\t\t\tif(null != extent) {\n\t\t\t\textent = [ extent[0].getTime(), extent[1].getTime() ];\n\t\t\t}\n\t\t}\n\n\t\treturn extent;\n\t}\n\n\t/*\n\t * Set the state of the filter, firing events if necessary\n\t */\n\tfunction setFilter(newExtent, oldExtent) {\n\t\t// Fire the event if the extents are different\n\t\tvar suppressEvent = newExtent == oldExtent || newExtent == null || oldExtent == null || (newExtent[0] == oldExtent[0] && newExtent[1] == oldExtent[1]);\n\t\tvar clearFilter = (null == newExtent || newExtent[0] >= newExtent[1]);\n\n\t\t// either clear the filter or assert it\n\t\tif(clearFilter) {\n\t\t\t_filter.brush.clear();\n\t\t} else {\n\t\t\t_filter.brush.extent([ new Date(newExtent[0]), new Date(newExtent[1]) ]);\n\t\t}\n\n\t\t// fire the event if anything changed\n\t\tif(!suppressEvent) {\n\t\t\t_filter.brush.event(_element.g.brush);\n\t\t}\n\t}\n\n\t/*\n\t * Update the state of the existing filter (if any) on the plot.\n\t * \n\t * This method accepts the extent of the brush before any plot changes were applied\n\t * and updates the brush to be redrawn on the plot after the plot changes are applied.\n\t * There is also logic to clip the brush if the extent has moved such that the brush\n\t * has moved partially out of the plot boundaries, as well as to clear the brush if it\n\t * has moved completely outside of the boundaries of the plot.\n\t */\n\tfunction updateFilter(extent) {\n\t\t// Don't need to do anything if filtering is not enabled\n\t\tif(_filter.enabled) {\n\t\t\t// Reassert the x scale of the brush (in case the scale has changed)\n\t\t\t_filter.brush.x(_scale.x);\n\n\t\t\t// Derive the overall plot extent from the collection of series\n\t\t\tvar plotExtent = multiExtent(_data, _extent.x);\n\n\t\t\t// If there was no previous extent, then there is no brush to update\n\t\t\tif(null != extent) {\n\t\t\t\t// Clip extent by the full extent of the plot (this is in case we've slipped off the visible plot)\n\t\t\t\tvar nExtent = [ Math.max(plotExtent[0], extent[0]), Math.min(plotExtent[1], extent[1]) ];\n\t\t\t\tsetFilter(nExtent, extent);\n\t\t\t}\n\n\t\t\t_element.g.brush\n\t\t\t\t.call(_filter.brush)\n\t\t\t\t.selectAll('rect')\n\t\t\t\t\t.attr('height', _height - _margin.top - _margin.bottom + 7);\n\t\t}\n\t}\n\n\t// Basic Getters/Setters\n\t_instance.width = function(v){\n\t\tif(!arguments.length) { return _width; }\n\t\t_width = v;\n\t\treturn _instance;\n\t};\n\t_instance.height = function(v){\n\t\tif(!arguments.length) { return _height; }\n\t\t_height = v;\n\t\treturn _instance;\n\t};\n\t_instance.margin = function(v){\n\t\tif(!arguments.length) { return _margin; }\n\t\t_margin = v;\n\t\treturn _instance;\n\t};\n\t_instance.interpolation = function(v){\n\t\tif(!arguments.length) { return _line.interpolate(); }\n\t\t_line.interpolate(v);\n\t\t_area.interpolate(v);\n\t\treturn _instance;\n\t};\n\t_instance.xAxis = function(v){\n\t\tif(!arguments.length) { return _axis.x; }\n\t\t_axis.x = v;\n\t\treturn _instance;\n\t};\n\t_instance.yAxis = function(v){\n\t\tif(!arguments.length) { return _axis.y; }\n\t\t_axis.y = v;\n\t\treturn _instance;\n\t};\n\t_instance.xScale = function(v){\n\t\tif(!arguments.length) { return _scale.x; }\n\t\t_scale.x = v;\n\t\tif(null != _axis.x) {\n\t\t\t_axis.x.scale(v);\n\t\t}\n\t\treturn _instance;\n\t};\n\t_instance.yScale = function(v){\n\t\tif(!arguments.length) { return _scale.y; }\n\t\t_scale.y = v;\n\t\tif(null != _axis.y) {\n\t\t\t_axis.y.scale(v);\n\t\t}\n\t\treturn _instance;\n\t};\n\t_instance.xValue = function(v){\n\t\tif(!arguments.length) { return _value.x; }\n\t\t_value.x = v;\n\t\treturn _instance;\n\t};\n\t_instance.yValue = function(v){\n\t\tif(!arguments.length) { return _value.y; }\n\t\t_value.y = v;\n\t\treturn _instance;\n\t};\n\t_instance.yExtent = function(v){\n\t\tif(!arguments.length) { return _extent.y; }\n\t\t_extent.y = v;\n\t\treturn _instance;\n\t};\n\t_instance.xExtent = function(v){\n\t\tif(!arguments.length) { return _extent.x; }\n\t\t_extent.x = v;\n\t\treturn _instance;\n\t};\n\t_instance.markerXValue = function(v){\n\t\tif(!arguments.length) { return _markerValue.x; }\n\t\t_markerValue.x = v;\n\t\treturn _instance;\n\t};\n\t_instance.markerLabelValue = function(v){\n\t\tif(!arguments.length) { return _markerValue.label; }\n\t\t_markerValue.label = v;\n\t\treturn _instance;\n\t};\n\t_instance.markerHover = function(v) {\n\t\tif(!arguments.length) { return _markerHoverCallback; }\n\t\t_markerHoverCallback = v;\n\t\treturn _instance;\n\t};\n\t_instance.filter = function(v) {\n\t\tif(!arguments.length) { return _filter.dispatch; }\n\t\t_filter.enabled = v;\n\t\treturn _instance;\n\t};\n\n\t// Expects milliseconds time\n\t_instance.setFilter = function(extent) {\n\t\tvar oldExtent = getFilter();\n\t\tif(null != extent && extent.length === 2) {\n\t\t\t// Convert to Dates and assert filter\n\t\t\tif(extent[0] instanceof Date) {\n\t\t\t\textent[0] = extent[0].getTime();\n\t\t\t}\n\t\t\tif(extent[1] instanceof Date) {\n\t\t\t\textent[1] = extent[1].getTime();\n\t\t\t}\n\t\t}\n\n\t\tsetFilter(extent, oldExtent);\n\t\t_instance.redraw();\n\t\treturn _instance;\n\t};\n\n\treturn _instance;\n}","var sentio_realtime = sentio.realtime = {};","sentio.realtime.timeline = sentio_realtime_timeline;\n\nfunction sentio_realtime_timeline() {\n\t'use strict';\n\n\t// Default data delay, this is the difference between now and the latest tick shown on the timeline\n\tvar _delay = 0;\n\n\t// Interval of the timeline, this is the amount of time being displayed by the timeline\n\tvar _interval = 60000;\n\n\t// Is the timeline running?\n\tvar _running = false;\n\tvar _timeout = null;\n\n\t// What is the refresh rate?\n\tvar _fps = 32;\n\n\tvar _instance = sentio.timeline.line();\n\t_instance.yExtent().filter(function(d) {\n\t\tvar x = _instance.xValue()(d);\n\t\tvar xExtent = _instance.xExtent().getExtent();\n\t\treturn (x < xExtent[1] && x > xExtent[0]);\n\t});\n\n\t/*\n\t * This is the main update loop function. It is called every time the\n\t * _instance is updating to proceed through time.\n\t */ \n\tfunction tick() {\n\t\t// If not running, let the loop die\n\t\tif(!_running) return;\n\n\t\t_instance.redraw();\n\n\t\t// Schedule the next update\n\t\t_timeout = window.setTimeout(tick, (_fps > 0)? 1000/_fps : 0);\n\t}\n\n\t/*\n\t * Redraw the graphic\n\t */\n\tvar parentRedraw = _instance.redraw;\n\t_instance.redraw = function() {\n\t\t// Update the x domain (to the latest time window)\n\t\tvar now = new Date();\n\t\t_instance.xExtent().overrideValue([now - _delay - _interval, now - _delay]);\n\n\t\tparentRedraw();\n\t\treturn _instance;\n\t};\n\n\t_instance.start = function() {\n\t\tif(_running){ return; }\n\t\t_running = true;\n\n\t\ttick();\n\t\treturn _instance;\n\t};\n\n\t_instance.stop = function() {\n\t\t_running = false;\n\n\t\tif(_timeout != null) {\n\t\t\twindow.clearTimeout(_timeout);\n\t\t}\n\t\treturn _instance;\n\t};\n\n\t_instance.restart = function() {\n\t\t_instance.stop();\n\t\t_instance.start();\n\t\treturn _instance;\n\t};\n\n\t_instance.interval = function(v) {\n\t\tif(!arguments.length) { return _interval; }\n\t\t_interval = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.delay = function(v) {\n\t\tif(!arguments.length) { return _delay; }\n\t\t_delay = v;\n\t\treturn _instance;\n\t};\n\n\t_instance.fps = function(v){\n\t\tif(!arguments.length) { return _fps; }\n\t\t_fps = v;\n\t\tif(_running) {\n\t\t\t_instance.restart();\n\t\t}\n\t\treturn _instance;\n\t};\n\n\treturn _instance;\n}"],"sourceRoot":"/source/"}