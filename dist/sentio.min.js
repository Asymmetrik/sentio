/*! @asymmetrik/sentio - 5.0.0 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("d3-dispatch"),require("d3-interpolate"),require("d3-scale"),require("d3-shape"),require("d3-axis"),require("d3-brush"),require("d3-selection"),require("d3-line")):"function"==typeof define&&define.amd?define(["exports","d3-dispatch","d3-interpolate","d3-scale","d3-shape","d3-axis","d3-brush","d3-selection","d3-line"],t):t(e.sentio={},e.d3,e.d3,e.d3,e.d3,e.d3,e.d3,e.d3,e.d3)}(this,function(e,t,n,r,i,a,u,l,o){"use strict";function c(e){/**
	 * Private Functions
	 */
function t(e){if(null==e||2!==e.length||isNaN(e[0])||isNaN(e[1])||e[0]>=e[1])throw new Error("Default extent must be a two element ordered array of numbers");l.defaultValue=e}function n(e){if(null!=e&&2!==e.length)throw new Error("Extent override must be a two element array or null/undefined");l.overrideValue=e}function r(e){if(null!=e&&2!==e.length)throw new Error("Extent padding must be a two element array or null/undefined");l.paddingValue=e}function i(e){if("function"!=typeof e)throw new Error("Value getter must be a function");o.getValue=e}function a(e){if("function"!=typeof e)throw new Error("Filter must be a function");o.filter=e}/*
	 * Constructor/initialization method
	 */
function u(e){null!=e&&(null!=e.defaultValue&&t(e.defaultValue),null!=e.overrideValue&&n(e.overrideValue),null!=e.paddingValue&&r(e.paddingValue),null!=e.getValue&&i(e.getValue),null!=e.filter&&a(e.filter))}/**
	 * Private variables
	 */
// Configuration
var l={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(e){return e},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return u.defaultValue=function(e){return arguments.length?(t(e),u):l.defaultValue},u.overrideValue=function(e){return arguments.length?(n(e),u):l.overrideValue},u.paddingValue=function(e){return arguments.length?(r(e),u):l.paddingValue},u.getValue=function(e){return arguments.length?(i(e),u):o.getValue},u.filter=function(e){return arguments.length?(a(e),u):o.filter},u.getExtent=function(e){var t,n=l.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
t=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=e&&
// Iterate over each element of the data
e.forEach(function(e,n){
// If the element passes the filter, then update the extent
if(o.filter(e,n)){r=!0;var i=o.getValue(e,n);t[0]=Math.min(t[0],i),t[1]=Math.max(t[1],i)}}),
// If we didn't find any data, use the default values
r||(t=l.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(t[0]=n[0]),null!=n[1]&&(t[1]=n[1]));var i=l.paddingValue;null==i||null==i[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
t[0]-=l.paddingValue[0]),null==i||null==i[1]||null!=n&&null!=n[1]||(t[1]+=l.paddingValue[1])}else
// Since the override is fully specified, use it
t=n;
// Verify that the extent is valid
return t[0]>t[1]&&(t[1]=t[0]),t},u(e),u}function s(e){/**
	 * Private Functions
	 */
function t(e){i=e}/*
	 * Constructor/initialization method
	 */
function n(e){null!=e&&null!=e.extent&&t(e.extent)}/**
	 * Private variables
	 */
var r={values:function(e){return e.values}},i=c();/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return n.extent=function(e){return arguments.length?(t(e),n):i},n.values=function(e){return arguments.length?(r.values=e,n):r.values},n.getExtent=function(e){var t;
// In case there was no data
return e.forEach(function(e,n){var a=i.getExtent(r.values(e,n));null==t?t=a:(t[0]=Math.min(t[0],a[0]),t[1]=Math.max(t[1],a[1]))}),null==t&&(t=i.getExtent([])),t},n(e),n}function d(e){/**
	 * Private Functions
	 */
function n(e){
// Should probably fire event for new brush state
v=e}function r(){return v&&null!=f}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function i(e){return null!=e&&Array.isArray(e)&&(e=e.map(function(e){return+e})),e}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function a(e){return(!Array.isArray(e)||2!=e.length||isNaN(e[0])||isNaN(e[1]))&&(e=void 0),e}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function o(e){return function(t){var n=null!=l.event.selection?i(l.event.selection.map(g.invert)):void 0,r=m,a=!((n===r||null!=n&&null!=r&&n[0]===r[0]&&n[1]===r[1])&&p);
// Store the new selection only on the 'end' event
"end"===e&&(
// Reset the selection
m=n,
// Reset the flag
p=!1),
// Suppress event if it's duplicate and programmatic
a&&h.apply(e,this,t)}}function c(e){var t=void 0;return v&&null!=e&&null!=g&&(t=null!=(t=u.brushSelection(e))&&Array.isArray(t)?i(t.map(g.invert)):void 0),t}function s(e,t){var n=null==(t=a(t))||t[0]>=t[1];
// either clear the filter or move it
p=!0,n?f.move(e,void 0):f.move(e,t.map(g))}function d(e){if(null==e)throw new Error("Must provide a brush and a scale");if(null==e.brush)throw new Error("Must provide a brush");if((f=e.brush).on("brush",o("brush")).on("start",o("start")).on("end",o("end")),null==e.scale)throw new Error("Must provide a scale");g=e.scale,null!=e.enabled&&n(e.enabled)}/**
	 * Private variables
	 */
// The brush object
var f,g,h=t.dispatch("brush","start","end"),m=void 0,v=!1,p=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return d.scale=function(e){return arguments.length?(g=e,d):g},d.dispatch=function(){return h},d.brush=function(){return f},d.enabled=function(e){return arguments.length?(n(e),d):r()},d.getSelection=function(e){return c(e)},d.setSelection=function(e,t){return s(e,t)},d(e),d}function f(){/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function e(){
// Try to get the node from the brush group selection
var e=null!=S.g.brush?S.g.brush.node():null;
// Get the current brush selection
return B.getSelection(e)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function n(e){B.setSelection(S.g.brush,e)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in brush change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function l(e){
// If there was no previous extent, then there is no brush to update
if(null!=e){
// Derive the overall plot extent from the collection of series
var t=z.extent(k.x).getExtent(G);n(null!=t&&Array.isArray(t)&&2==t.length?[Math.max(t[0],e[0]),Math.min(t[1],e[1])]:void 0)}S.g.brush.style("display",B.enabled()?"unset":"none").call(B.brush())}
// Chart create/init method
function o(){}function f(){null!=A.x&&S.g.xAxis.call(A.x),null!=A.xGrid&&y.xGrid&&S.g.xAxisGrid.call(A.xGrid),null!=A.y&&S.g.yAxis.call(A.y),null!=A.yGrid&&y.yGrid&&S.g.yAxisGrid.call(A.yGrid)}function g(){
// Join
var e=S.g.plots.selectAll(".plot").data(G,b.seriesKey),t=e.enter().append("g").attr("class","plot"),n=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" line"}),r=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" area"}),i=e.select(".line"),a=e.select(".area");
// Enter + Update
n.merge(i).datum(b.seriesValues).attr("d",E),r.merge(a).datum(b.seriesValues).attr("d",M.y0(V.y.range()[0])),e.exit().remove()}function h(){
// Join
var e=S.g.markers.selectAll(".marker").data(T.values,b.markerValueX),t=e.enter().append("g").attr("class","marker").on("mouseover",function(e,t){C.call("markerMouseover",this,e,t)}).on("mouseout",function(e,t){C.call("markerMouseout",this,e,t)}).on("click",function(e,t){C.call("markerClick",this,e,t)}),n=t.append("line"),r=t.append("text");n.attr("y1",function(e){return V.y.range()[1]}).attr("y2",function(e){return V.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(b.markerValueLabel);
// Enter + Update
var i=e.select("line"),a=e.select("text");n.merge(i).attr("x1",function(e,t){return V.x(b.markerValueX(e,t))}).attr("x2",function(e,t){return V.x(b.markerValueX(e))}),r.merge(a).attr("x",function(e,t){return V.x(b.markerValueX(e))}),
// Exit
e.exit().remove()}var m="timeline_line_"+Date.now(),v={top:10,right:10,bottom:20,left:40},p=100,x=600,y={xGrid:!1,yGrid:!1,points:!1,tooltip:!1},b={valueX:function(e){return e[0]},valueY:function(e){return e[1]},markerValueX:function(e){return e[0]},markerLabel:function(e){return e[1]},seriesKey:function(e){return e.key},seriesValues:function(e){return e.values},seriesLabel:function(e){return e.label}},w=Date.now(),k={x:c({defaultValue:[w-3e5,w],getValue:function(e,t){return b.valueX(e,t)}}),y:c({getValue:function(e,t){return b.valueY(e,t)}})},z=s().values(function(e,t){return b.seriesValues(e,t)}),V={x:r.scaleTime(),y:r.scaleLinear()},A={x:a.axisBottom().scale(V.x),y:a.axisLeft().ticks(3).scale(V.y),xGrid:a.axisBottom().tickFormat("").tickSizeOuter(0).scale(V.x),yGrid:a.axisLeft().tickFormat("").tickSizeOuter(0).ticks(3).scale(V.y)},S={svg:void 0,g:{container:void 0,plots:void 0,xAxis:void 0,yAxis:void 0,xAxisGrid:void 0,yAxisGrid:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},E=i.line();E.x(function(e,t){return V.x(b.valueX(e,t))}),E.y(function(e,t){return V.y(b.valueY(e,t))});
// Area generator for the plot
var M=i.area();M.x(function(e,t){return V.x(b.valueX(e,t))}),M.y1(function(e,t){return V.y(b.valueY(e,t))});
// Brush Management
var B=d({brush:u.brushX(),scale:V.x});B.dispatch().on("end",function(){C.call("brushend",this,e())}).on("start",function(){C.call("brushstart",this,e())}).on("brush",function(){C.call("brush",this,e())});
// The dispatch object and all events
var C=t.dispatch("brush","brushstart","brushend","markerClick","markerMouseover","markerMouseout"),G=[],T={values:[]};/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return o.init=function(e){
// Create a container div
S.div=e.append("div").attr("class","sentio timeline"),
// Create the SVG element
S.svg=S.div.append("svg");
// Add the defs and add the clip path definition
var t=S.svg.append("defs");
// Append a container for everything
// Append the grid
// Append the path group (which will have the clip path and the line path
// Append groups for the axes
// Append a group for the markers
// Add the brush element
return S.plotClipPath=t.append("clipPath").attr("id","plot_"+m).append("rect"),S.markerClipPath=t.append("clipPath").attr("id","marker_"+m).append("rect"),S.g.container=S.svg.append("g"),S.g.xAxisGrid=S.g.container.append("g").attr("class","x grid"),S.g.yAxisGrid=S.g.container.append("g").attr("class","y grid"),S.g.plots=S.g.container.append("g").attr("class","plots").attr("clip-path","url(#plot_"+m+")"),S.g.xAxis=S.g.container.append("g").attr("class","x axis"),S.g.yAxis=S.g.container.append("g").attr("class","y axis"),S.g.markers=S.g.container.append("g").attr("class","markers").attr("clip-path","url(#marker_"+m+")"),S.g.brush=S.g.container.append("g").attr("class","x brush").attr("clip-path","url(#marker_"+m+")"),o.resize(),o},o.data=function(e){return arguments.length?(G=null!=e?e:[],o):G},o.markers=function(e){return arguments.length?(T.values=null!=e?e:[],o):T.values},o.resize=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Resize the SVG Pane
// Update the margins on the main draw group
// Resize Scales
/**
		 * Resize clip paths
		 */
// Plot clip path is only the plot pane
// Marker clip path includes top margin by default
/**
		 * Update axis and grids
		 */
// Reset axis and grid positions
// Resize the x grid ticks
// Resize the y grid ticks
/**
		 * Update the brush
		 */
// Resize and position the brush g element
// Resize the brush
return S.svg.attr("width",x).attr("height",p),S.g.container.attr("transform","translate("+v.left+","+v.top+")"),V.x.range([0,Math.max(0,x-v.left-v.right)]),V.y.range([Math.max(0,p-v.top-v.bottom),0]),S.plotClipPath.attr("transform","translate(0, -1)").attr("width",Math.max(0,V.x.range()[1])+2).attr("height",Math.max(0,V.y.range()[0])+2),S.markerClipPath.attr("transform","translate(0, -"+v.top+")").attr("width",Math.max(0,x-v.left-v.right)).attr("height",Math.max(0,p-v.bottom)),S.g.xAxis.attr("transform","translate(0,"+V.y.range()[0]+")"),S.g.xAxisGrid.attr("transform","translate(0,"+V.y.range()[0]+")"),y.xGrid?A.xGrid.tickSizeInner(-(p-v.top-v.bottom)):A.xGrid.tickSizeInner(0),y.yGrid?A.yGrid.tickSizeInner(-(x-v.left-v.right)):A.yGrid.tickSizeInner(0),S.g.brush.selectAll("rect").attr("y",-1).attr("x",0).attr("width",V.x.range()[1]).attr("height",V.y.range()[0]+2),B.brush().extent([[0,0],[V.x.range()[1],V.y.range()[0]+2]]),l(t),o},o.redraw=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return V.x.domain(z.extent(k.x).getExtent(G)),V.y.domain(z.extent(k.y).getExtent(G)),f(),g(),h(),l(t),o},o.width=function(e){return arguments.length?(x=e,o):x},o.height=function(e){return arguments.length?(p=e,o):p},o.margin=function(e){return arguments.length?(v=e,o):v},o.xGrid=function(e){return arguments.length?(y.xGrid=e,o):y.xGrid},o.yGrid=function(e){return arguments.length?(y.yGrid=e,o):y.yGrid},o.grid=function(e){return y.xGrid=y.yGrid=e,o},o.curve=function(e){return arguments.length?(E.curve(e),M.curve(e),o):E.curve()},o.xAxis=function(e){return arguments.length?(A.x=e,o):A.x},o.xGridAxis=function(e){return arguments.length?(A.xGrid=e,o):A.xGrid},o.yAxis=function(e){return arguments.length?(A.y=e,o):A.y},o.yGridAxis=function(e){return arguments.length?(A.yGrid=e,o):A.yGrid},o.xScale=function(e){return arguments.length?(V.x=e,null!=A.x&&A.x.scale(e),null!=A.xGrid&&A.xGrid.scale(e),null!=B&&B.scale(e),o):V.x},o.yScale=function(e){return arguments.length?(V.y=e,null!=A.y&&A.y.scale(e),null!=A.yGrid&&A.yGrid.scale(e),o):V.y},o.xValue=function(e){return arguments.length?(b.valueX=e,o):b.valueX},o.yValue=function(e){return arguments.length?(b.valueY=e,o):b.valueY},o.yExtent=function(e){return arguments.length?(k.y=e,o):k.y},o.xExtent=function(e){return arguments.length?(k.x=e,o):k.x},o.seriesKey=function(e){return arguments.length?(b.seriesKey=e,o):b.seriesKey},o.seriesLabel=function(e){return arguments.length?(b.seriesLabel=e,o):b.seriesLabel},o.seriesValues=function(e){return arguments.length?(b.seriesValues=e,o):b.seriesValues},o.markerXValue=function(e){return arguments.length?(b.markerValueX=e,o):b.markerValueX},o.markerLabel=function(e){return arguments.length?(b.markerValueLabel=e,o):b.markerValueLabel},o.dispatch=function(e){return arguments.length?o:C},o.brush=function(e){return arguments.length?(B.enabled(e),o):B.enabled()},o.setBrush=function(e){return n(e),o},o.getBrush=function(){return e()},o}function g(e){/**
	 * Private Functions
	 */
// Get the index given the value
function t(e){return null==l.size||null==l.lwm?0:Math.floor((e-l.lwm)/l.size)}function n(){l.hwm=l.lwm+l.count*l.size}function r(){
// drop stuff below the lwm
for(var e,t=s;c.length>0&&c[0][0]<l.lwm;)e=c.shift(),s-=o.countBin(e);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=l.hwm;)e=c.pop(),s-=o.countBin(e);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([l.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-l.size;n>=l.lwm;n-=l.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<l.hwm-l.size;)c.push([c[c.length-1][0]+l.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(u,c,s,t)}function i(e){var n=s;e.forEach(function(e,n){var r=t(o.getKey(e,n));if(r>=0&&r<c.length){var i=o.getValue(e,n),a=o.countBin(c[r]);o.updateBin.call(u,c[r],i,n),s+=o.countBin(c[r])-a}}),o.afterAdd&&o.afterAdd.call(u,c,s,n)}function a(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function u(e){if(null==e||null==e.size||null==e.count||null==e.lwm)throw new Error("You must provide an initial size, count, and lwm");l.size=Number(e.size),l.count=Number(e.count),l.lwm=Number(e.lwm),null!=e.createSeed&&(o.createSeed=e.createSeed),null!=e.getKey&&(o.getKey=e.getKey),null!=e.getValue&&(o.getValue=e.getValue),null!=e.updateBin&&(o.updateBin=e.updateBin),null!=e.countBin&&(o.countBin=e.countBin),null!=e.afterAdd&&(o.afterAdd=e.afterAdd),null!=e.afterUpdate&&(o.afterUpdate=e.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var l={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(e){return e},
// The default value function
getValue:function(e){return e},
// The default function for updating a bin given a new value
updateBin:function(e,t){e[1].push(t)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(e){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof e[1]?e[1]:e[1].hasOwnProperty("length")?e[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(e,t,n){},
// The default function to be called after the bins are updated
afterUpdate:function(e,t,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return u.set=function(e){return a(),r(),i(e),u},u.clear=function(){return a(),r(),u},u.add=function(e){return i(e),u},u.lwm=function(e){if(!arguments.length)return l.lwm;var t=l.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return l.lwm=Number(e),n(),(t-l.lwm)%l.size!=0&&a(),r(),u},u.hwm=function(){return l.hwm},u.getKey=function(e){return arguments.length?(o.getKey=e,a(),r(),u):o.getKey},u.getValue=function(e){return arguments.length?(o.getValue=e,a(),r(),u):o.getValue},u.updateBin=function(e){return arguments.length?(o.updateBin=e,a(),r(),u):o.updateBin},u.createSeed=function(e){return arguments.length?(o.createSeed=e,a(),r(),u):o.createSeed},u.countBin=function(e){return arguments.length?(o.countBin=e,a(),r(),u):o.countBin},u.afterAdd=function(e){return arguments.length?(o.afterAdd=e,u):o.afterAdd},u.afterUpdate=function(e){return arguments.length?(o.afterUpdate=e,u):o.afterUpdate},u.size=function(e){if(!arguments.length)return l.size;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return e!==l.size&&(l.size=e,n(),a(),r()),u},u.count=function(e){if(!arguments.length)return l.count;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return e!==l.count&&(l.count=Math.floor(e),n(),r()),u},u.bins=function(){return c},u.itemCount=function(){return s},u.clearBin=function(e){if(e>=0&&e<c.length){var t=o.countBin(c[e]);return s-=t,c[e][1]=o.createSeed(),t}return 0},u(e),u}e.chartDonut=function(){
// Chart create/init method
function e(e){}/**
	 * Private functions
	 */
function a(){/*
		 * Join the data
		 */
var e=y.gChart.selectAll("path.arc").data(x.pie(b),function(e,t){return v.key(e.data,t)}),t=e.enter().append("path").attr("class","arc").on("mouseover",v.mouseover).on("mouseout",v.mouseout).on("click",v.click).each(function(e){this._current={startAngle:0,endAngle:0}}).merge(e);t.transition().duration(g).attrTween("d",function(e){var t=n.interpolate(this._current,e);return this._current=t(0),function(e){return x.arc(t(e))}}),t.attr("key",function(e,t){return v.key(e.data,t)}).attr("fill",function(e,t){return p.color(v.key(e.data,t))}),/*
		 * Exit
		 */
e.exit().remove()}function u(){var e=h.markSize+h.markMargin;
// Only option is 'center' for now
if("center"===h.position){
// The center position of the chart
var t=d.left+o,n=d.top+o;return"translate("+(t-(null==y.gLegend._maxWidth?0:y.gLegend._maxWidth)/2)+","+(n-(e*b.length+h.markMargin)/2)+")"}}function l(){/*
		 * Join the data
		 */
var e=y.gLegend.selectAll("g.entry").data(b,v.key),t=e.enter().append("g").attr("class","entry").attr("transform",function(e,t){return"translate(0, "+t*(h.markSize+h.markMargin)+")"}).on("mouseover",v.mouseover).on("mouseout",v.mouseout).on("click",v.click),n=t.append("rect").attr("width",h.markSize).attr("height",h.markSize);/*
		 * Enter + Update
		 */
t.append("text").attr("x",h.markSize+h.markMargin).attr("y",h.markSize-h.labelOffset).merge(e.select("text")).text(v.label),n.merge(e.select("rect")).style("fill",function(e,t){return p.color(v.key(e,t))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
t.merge(e).each(function(e,t){
// Reset
y.gLegend._maxWidth=0===t?this.getBBox().width:Math.max(this.getBBox().width,y.gLegend._maxWidth)}),
// Reassert the legend position
y.gLegend.attr("transform",u()),/*
		 * Exit
		 */
e.exit().remove()}
// Chart height/width
var o,c=400,s=400,d={top:2,bottom:2,right:2,left:2},f=.7,g=500,h={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},m=t.dispatch("mouseover","mouseout","click"),v={getEventElement:function(e,t){return null!=e&&null!=e.data?e.data:e},updateActiveElement:function(e,t){var n=y.gLegend.selectAll("g.entry"),r=y.gChart.selectAll("path.arc");if(null!=e){
// Set the highlight on the row
var i=v.key(e,t);n.classed("active",function(e,t){return v.key(e,t)==i}),r.classed("active",function(e,t){return v.key(e.data,t)==i})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(e,t){e=v.getEventElement(e,t),v.updateActiveElement(e,t),m.call("mouseover",this,e,t)},mouseout:function(e,t){e=v.getEventElement(e,t),v.updateActiveElement(),m.call("mouseout",this,e,t)},click:function(e,t){e=v.getEventElement(e,t),m.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},p={color:r.scaleOrdinal(r.schemeCategory10)},x={arc:i.arc().padAngle(.01),pie:i.pie().value(function(e,t){return v.value(e,t)}).sort(null)},y={div:void 0,svg:void 0,gChart:void 0,legend:void 0},b=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return y.div=t.append("div").attr("class","sentio donut"),y.svg=y.div.append("svg"),y.gChart=y.svg.append("g").attr("class","chart"),y.gLegend=y.svg.append("g").attr("class","legend"),e.resize(),e},e.data=function(t){return arguments.length?(b=null!=t?t:[],e):b},e.resize=function(){var t=c-d.right-d.left,n=s-d.top-d.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return o=Math.min(n,t)/2,y.svg.attr("width",c).attr("height",s),y.gChart.attr("transform","translate("+(d.left+o)+","+(d.top+o)+")"),x.arc.innerRadius(o*f).outerRadius(o),y.gLegend.attr("transform",u()),e},e.redraw=function(){return a(),h.enabled&&l(),e},e.width=function(t){return arguments.length?(c=t,e):c},e.height=function(t){return arguments.length?(s=t,e):s},e.innerRadiusRatio=function(t){return arguments.length?(f=t,e):f},e.duration=function(t){return arguments.length?(g=t,e):g},e.key=function(t){return arguments.length?(v.key=t,e):v.key},e.value=function(t){return arguments.length?(v.value=t,e):v.value},e.label=function(t){return arguments.length?(v.label=t,e):v.label},e.colorScale=function(t){return arguments.length?(p.color=t,e):p.color},e.dispatch=function(){return m},e.legend=function(t){return arguments.length?(h=t,e):h},e},e.chartMatrix=function(){
// Chart dimensions
var e=16,n=1,i={top:20,right:2,bottom:2,left:64},u=500,l=t.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),o={updateActiveSeries:function(e,t){var n=h.g.chart.selectAll(".row text");if(null!=e){
// Set the highlight on the row
var r=o.seriesKey(e,t);n.classed("active",function(e,t){return o.seriesKey(e,t)==r})}else
// Now update the style
n.classed("active",!1)},rowMouseover:function(e,t){o.updateActiveSeries(e,t),l.call("rowMouseover",this,e,t)},rowMouseout:function(e,t){o.updateActiveSeries(),l.call("rowMouseout",this,e,t)},rowClick:function(e,t){l.call("rowClick",this,e,t)},cellMouseover:function(e,t){l.call("cellMouseover",this,e,t)},cellMouseout:function(e,t){l.call("cellMouseout",this,e,t)},cellClick:function(e,t){l.call("cellClick",this,e,t)},seriesKey:function(e){return e.key},seriesLabel:function(e){return e.label},seriesValues:function(e){return e.values},key:function(e){return e.key},value:function(e){return e.value}},d={x:c().getValue(function(e,t){return o.key(e,t)}),value:c().getValue(function(e,t){return o.value(e,t)}),multi:s()},f={x:r.scaleLinear(),y:r.scaleOrdinal(),color:r.scaleLinear().range(["#e7e7e7","#008500"])},g={x:a.axisTop().scale(f.x).tickSizeOuter(0).tickSizeInner(2)},h={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},m=[],v=function(){};return v.init=function(e){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return h.div=e.append("div").attr("class","sentio matrix"),h.svg=h.div.append("svg"),h.g.xAxis=h.svg.append("g").attr("class","x axis"),h.g.chart=h.svg.append("g").attr("class","chart"),v.resize(),v},v.data=function(e){return arguments.length?(m=null!=e?e:[],v):m},v.resize=function(){},v.redraw=function(){
// Determine the number of rows to render
var t=m.length,r=[];t>0&&(r=o.seriesValues(m[0]));var a=r.length,l=n+e,c=a*l+n,s=t*l+n;
// scale the svg to the right size
h.svg.attr("width",c+i.left+i.right).attr("height",s+i.top+i.bottom),
// Configure the scales
f.x.domain(d.x.getExtent(r)).range([0,c-n-l]),f.color.domain(d.multi.values(o.seriesValues).extent(d.value).getExtent(m)),
// Draw the x axis
h.g.xAxis.attr("transform","translate("+(i.left+n+e/2)+","+i.top+")"),h.g.xAxis.call(g.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var p=h.g.chart.selectAll("g.row").data(m,o.seriesKey),x=p.enter().append("g");x.style("opacity","0.1").attr("class","row").attr("transform",function(e,t){return"translate("+i.left+","+(i.top+l*t)+")"}).on("mouseover",o.rowMouseover).on("mouseout",o.rowMouseout).on("click",o.rowClick),
// Also must append the label of the row
x.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",n+e/2).attr("dy",".32em"),
// Also must append a line
x.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",n+e/2).attr("y2",n+e/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var y=x.merge(p);y.transition().duration(u).style("opacity","1").attr("transform",function(e,t){return"translate("+i.left+","+(i.top+l*t)+")"}),
// Update the series labels in case they changed
y.select("text.series.label").text(o.seriesLabel),/*
		 * Row Exit
		 */
p.exit().transition().duration(u).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var b=y.selectAll("rect.cell").data(o.seriesValues,o.key);/*
		 * Cell Remove
		 */
return b.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(e,t){return f.color(o.value(e,t))}).attr("x",function(e,t){return f.x(o.key(e,t))+n}).attr("y",n).attr("height",e).attr("width",e).on("mouseover",o.cellMouseover).on("mouseout",o.cellMouseout).on("click",o.cellClick).merge(b).transition().duration(u).style("opacity","1").attr("x",function(e,t){return f.x(o.key(e,t))+n}).style("fill",function(e,t){return f.color(o.value(e,t))}),b.exit().transition().duration(u).attr("width",0).style("opacity","0.1").remove(),v},v.cellSize=function(t){return arguments.length?(e=t,v):e},v.cellMargin=function(e){return arguments.length?(n=e,v):n},v.margin=function(e){return arguments.length?(i=e,v):i},v.duration=function(e){return arguments.length?(u=e,v):u},v.seriesKey=function(e){return arguments.length?(o.seriesKey=e,v):o.seriesKey},v.seriesLabel=function(e){return arguments.length?(o.seriesLabel=e,v):o.seriesLabel},v.seriesValues=function(e){return arguments.length?(o.seriesValues=e,v):o.seriesValues},v.key=function(e){return arguments.length?(o.key=e,v):o.key},v.value=function(e){return arguments.length?(o.value=e,v):o.value},v.colorScale=function(e){return arguments.length?(f.color=e,v):f.color},v.xScale=function(e){return arguments.length?(f.xScale=e,g.x.scale(e),v):f.xScale},v.yScale=function(e){return arguments.length?(f.yScale=e,v):f.yScale},v.xExtent=function(e){return arguments.length?(d.x=e,d.x.getValue(function(t,n){return e(t,n)}),v):d.x},v.valueExtent=function(e){return arguments.length?(d.value=e,d.value.getValue(function(t,n){return e(t,n)}),v):d.value},v.dispatch=function(){return l},v},e.chartTimeline=f,e.chartAutoBrushTimeline=function(){function e(e){var t=e;
// Crop the brush to max extent
// Make a new copy
// Crop the brush using the max extent
return null!=t&&((t=e.slice())[0]=Math.max(t[0],h[0]),t[1]=Math.min(t[1],h[1])),t}/**
	 * Handle a change to the brush (whether from the timeline or manual)
	 * - Crop the brush if necessary based on maxExtent
	 * - Ensure the brush is valid.
	 * - Update the brush and recalculate the extent.
	 *
	 * @param newBrush
	 */
function n(t){
// Ensure the brush is valid
null!=(t=e(t))?(
// Update the brush
u=t,x.setBrush(t),
// Update the extent as necessary
r(),
// Fire the brush change event
v.call("brushChange",this,t)):
// Don't allow them to apply an invalid brush
x.setBrush(u),p.redraw()}/**
	 * Update the extent
	 */
function r(){var e=i(u);if(e.pan||e.zoom){
// Update the Extent and fire the event
var t=a(u,e);p.xExtent().overrideValue(t),v.call("extentChange",this,t)}}/**
	 * Check to see if the extent needs to change
	 * - Checks boundaries and zoom level
	 * - Returns a status to indicate how the extent needs to change
	 *
	 * @param brush
	 * @returns { pan: boolean, zoom: boolean }
	 */
function i(e){var t={pan:!1,zoom:!1};if(null!=e){var n=p.xScale(),r=n.domain()[0],i=e[0],a=e[1],u=n.domain()[1],l=u-r,o=(a-i)/l,c=(i-r)/l<=s.edgeTrigger&&i>h[0],d=(u-a)/l<=s.edgeTrigger&&a<h[1];
// Should we resize and/or recenter?
t.zoom=o>=s.zoomOutTrigger||o<=s.zoomInTrigger,t.pan=c||d}return t}/**
	 * Given the brush, determine the new xExtent that should be applied
	 * @param brush The brush for which to determine the extent
	 * @param transform What kind of transform we should apply (whether zoom or pan)
	 * @returns {[*,*]}
	 */
function a(e,t){var n=p.xScale().domain()[0],r=e[0],i=e[1],a=p.xScale().domain()[1]-n;
// If we're zooming, change the target width
t.zoom&&(
// Calculate the new width of the extent (and make sure it isn't smaller than the max zoom)
a=Math.max((i-r)/s.zoomTarget,d));
// Determine the current center of the brush
var u=r+(i-r)/2,l=Math.max(u-a/2,h[0]);
// Track how much of the width we successfully applied to the new lower bound
a-=u-l;
// Determine the new upper bound as as much of the width as we can apply above the center
var o=Math.min(u+a,h[1]);
// Track how much of the width we applied to the upper bound
// If newWidthE is greater than zero, it means that clipping kept us from applying
// all of the width, so we should try to apply the rest to the lower bound
return a-=o-u,l=Math.max(l-a,h[0]),[l,o]}var u,l="autobrush_timeline_"+Date.now(),c=Date.now(),s={edgeTrigger:.01,zoomInTrigger:.05,zoomOutTrigger:.8,zoomTarget:.2},d=864e5,g=36e5,h=[c-31536e7,c],m=[c-15552e6,c],v=t.dispatch("extentChange","brushChange"),p=f(),x={element:{g:{container:void 0},axisClipPath:void 0},brush:p.brush,dispatch:p.dispatch,init:p.init,resize:p.resize,redraw:p.redraw,setBrush:p.setBrush,xAxis:p.xAxis};
// Set up default look and feel
// Initialization of the timline and auto brush
// Redraw the auto brush
// Resize
// Basic Getters/Setters
// Cannot disable the brush
return p.margin({top:2,right:10,bottom:2,left:10}),p.xAxis().ticks(5),p.yAxis(null),p.init=function(e){
// Store the container
// Initialize the timeline
// Turn on brushing and register for brush events
// Set the initial brush
// Add a clip path for the axis
// Attach the clip path to the axis
return x.element.g.container=e,x.init(e),x.brush(!0),x.dispatch().on("brushend.internal",n),null==u&&(u=m,p.setBrush(u)),x.element.axisClipPath=e.select("svg defs").append("clipPath").attr("id","axis_"+l).append("rect"),x.element.g.container.select("div.sentio.timeline").select("g.x.axis").attr("clip-path","url(#axis_"+l+")"),p.resize(),p},p.redraw=function(){
// Let the timeline redraw like normal
x.redraw(),/*
		 * Update the X Axis
		 */
// Set the x Axis ticks to be full height
p.xAxis().tickSize(-p.height()+p.margin().top+p.margin().bottom);
// Update text position to be on the chart
var e=x.element.g.container.select("div.sentio.timeline").select("g.x.axis").attr("pointer-events","none");
// Set the x Axis ticks to be full height
// Set the curve to interpolate
// Call it to redraw
return e.selectAll("g.tick text").attr("y","3").attr("dy","-0.71em").attr("dx","0.35em").attr("text-anchor","start"),p.xAxis().tickSize(-p.height()+p.margin().top+p.margin().bottom),p.curve(o.curveNatural),null!=p.xAxis()&&e.call(p.xAxis()),p},p.resize=function(){
// Need to be defensive here since parent init calls resize
if(x.resize(),null!=x.element.axisClipPath){var e=p.margin(),t=p.width(),n=p.height();
// Update the size of the xAxis clip path
x.element.axisClipPath.attr("transform","translate(0, -"+(n+e.top)+")").attr("width",Math.max(0,t-e.left-e.right+2)).attr("height",Math.max(0,n+e.bottom+e.top))}},p.edgeTrigger=function(e){return arguments.length?(s.edgeTrigger=e,p):s.edgeTrigger},p.zoomInTrigger=function(e){return arguments.length?(s.zoomInTrigger=e,p):s.zoomInTrigger},p.zoomOutTrigger=function(e){return arguments.length?(s.zoomOutTrigger=e,p):s.zoomOutTrigger},p.zoomTarget=function(e){return arguments.length?(s.zoomTarget=e,p):s.zoomTarget},p.maxExtent=function(e){return arguments.length?(h=e,p):h},p.minExtent=function(e){return arguments.length?(d=e,p):d},p.minBrush=function(e){return arguments.length?(g=e,p):g},p.setBrush=function(e){return n(e),p},p.dispatch=function(){return v},p.rawDispatch=function(){return x.dispatch},p.brush=function(){return!0},p},e.chartRealtimeTimeline=function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function e(){
// If not running, let the loop die
r&&(u.redraw(),
// Schedule the next update
i=window.setTimeout(e,a>0?1e3/a:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var t=0,n=6e4,r=!1,i=null,a=32,u=f();u.yExtent().filter(function(e){var t=u.xValue()(e),n=u.xExtent().getExtent();return t<n[1]&&t>n[0]});/*
	 * Redraw the graphic
	 */
var l=u.redraw;return u.redraw=function(){
// Update the x domain (to the latest time window)
var e=new Date;return u.xExtent().overrideValue([e-t-n,e-t]),l(),u},u.start=function(){if(!r)return r=!0,e(),u},u.stop=function(){return r=!1,null!=i&&window.clearTimeout(i),u},u.restart=function(){return u.stop(),u.start(),u},u.interval=function(e){return arguments.length?(n=e,u):n},u.delay=function(e){return arguments.length?(t=e,u):t},u.fps=function(e){return arguments.length?(a=e,r&&u.restart(),u):a},u},e.chartVerticalBars=function(){
// Chart create/init method
function e(e){}
// Layout properties
var n=100,i=24,a=2,u=500,l=t.dispatch("mouseover","mouseout","click"),o={mouseover:function(e,t){l.call("mouseover",this,e,t)},mouseout:function(e,t){l.call("mouseout",this,e,t)},click:function(e,t){l.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},s={x:r.scaleLinear(),y:r.scaleLinear()},d={width:c({defaultValue:[0,10],getValue:function(e,t){return o.value(e,t)}})},f={div:void 0},g=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
return f.div=t.append("div").attr("class","sentio bars-vertical"),e.resize(),e},e.data=function(t){return arguments.length?(g=null!=t?t:[],e):g},e.resize=function(){
// Set up the x scale (y is fixed)
return s.x.range([0,n]),e},e.redraw=function(){
// Update the x domain
s.x.domain(d.width.getExtent(g)),
// Update the y domain (based on configuration and data)
s.y.domain([0,g.length]),s.y.range([0,(i+a)*g.length]);
// Data Join
var t=f.div.selectAll("div.bar").data(g,o.key),n=t.enter().append("div").attr("class","bar").style("top",s.y.range()[1]-i+"px").style("height",i+"px").on("mouseover",o.mouseover).on("mouseout",o.mouseout).on("click",o.click).style("opacity","0.01"),r=n.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return n.merge(t).transition().duration(u).style("opacity","1").style("width",function(e,t){return s.x(o.value(e,t))+"px"}).style("top",function(e,t){return s.y(t)+"px"}).style("left","0px"),r.merge(t.select("div.bar-label")).html(o.label).style("max-width",s.x.range()[1]-10+"px"),t.exit().transition().duration(u).style("opacity","0.01").style("top",s.y.range()[1]-i+"px").remove(),f.div.style("height",s.y.range()[1]+"px"),e},e.width=function(t){return arguments.length?(n=t,e):n},e.barHeight=function(t){return arguments.length?(i=t,e):i},e.barPadding=function(t){return arguments.length?(a=t,e):a},e.key=function(t){return arguments.length?(o.key=t,e):o.key},e.value=function(t){return arguments.length?(o.value=t,e):o.value},e.label=function(t){return arguments.length?(o.label=t,e):o.label},e.widthExtent=function(t){return arguments.length?(d.width=t,d.width.getValue(function(e,t){return o.value(e,t)}),e):d.width},e.dispatch=function(t){return arguments.length?e:l},e.duration=function(t){return arguments.length?(u=t,e):u},e},e.controllerRealtimeBins=/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(e){/**
	 * Private Functions
	 */
function t(){
// Assume the hwm is now plus two binSize
var e=Date.now()+2*u.size();
// Trunc the hwm down to a round value based on the binSize
return(e=Math.floor(e/u.size())*u.size())-u.size()*u.count()}function n(){!0===l&&(
// need to update the lwm
u.lwm(t()),window.setTimeout(n,u.size()))}function r(){l||(
// Start the update loop
l=!0,n())}function i(){
// Setting running to false will stop the update loop
l=!1}
// create/init method
function a(e){if(null==e||null==e.binCount||null==e.binSize)throw new Error("You must provide an initial binSize and binCount");o.binSize=Number(e.binSize),o.binCount=Number(e.binCount),null!=e.delay&&(o.delay=Number(e.delay)),(u=g({size:o.binSize,count:o.binCount+2,lwm:0})).lwm(t()),r()}/**
	 * Private variables
	 */
var u,l,o={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return a.model=function(){return u},a.bins=function(){return u.bins()},a.start=function(){return r(),a},a.stop=function(){return i(),a},a.running=function(){return l},a.add=function(e){return u.add(e),a},a.clear=function(){return u.clear(),a},a.binSize=function(e){if(!arguments.length)return o.binSize;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");return o.binSize=e,u.size(e),u.lwm(t()),a},a.binCount=function(e){if(!arguments.length)return o.binCount;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");return o.binCount=e,u.count(e+2),u.lwm(t()),a},a(e),a},e.timelineBrush=d,e.modelBins=g,e.modelExtent=c,e.modelMultiExtent=s,Object.defineProperty(e,"__esModule",{value:!0})});