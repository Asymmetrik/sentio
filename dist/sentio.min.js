/*! @asymmetrik/sentio - 5.0.0-alpha.7 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("d3-dispatch"),require("d3-interpolate"),require("d3-scale"),require("d3-shape"),require("d3-axis"),require("d3-brush"),require("d3-voronoi"),require("d3-selection")):"function"==typeof define&&define.amd?define(["exports","d3-dispatch","d3-interpolate","d3-scale","d3-shape","d3-axis","d3-brush","d3-voronoi","d3-selection"],e):e(t.sentio={},t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3)}(this,function(t,e,n,r,i,a,u,l,o){"use strict";function c(t){/**
	 * Private Functions
	 */
function e(t){if(null==t||2!==t.length||isNaN(t[0])||isNaN(t[1])||t[0]>=t[1])throw new Error("Default extent must be a two element ordered array of numbers");l.defaultValue=t}function n(t){if(null!=t&&2!==t.length)throw new Error("Extent override must be a two element array or null/undefined");l.overrideValue=t}function r(t){if(null!=t&&2!==t.length)throw new Error("Extent padding must be a two element array or null/undefined");l.paddingValue=t}function i(t){if("function"!=typeof t)throw new Error("Value getter must be a function");o.getValue=t}function a(t){if("function"!=typeof t)throw new Error("Filter must be a function");o.filter=t}/*
	 * Constructor/initialization method
	 */
function u(t){null!=t&&(null!=t.defaultValue&&e(t.defaultValue),null!=t.overrideValue&&n(t.overrideValue),null!=t.paddingValue&&r(t.paddingValue),null!=t.getValue&&i(t.getValue),null!=t.filter&&a(t.filter))}/**
	 * Private variables
	 */
// Configuration
var l={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(t){return t},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return u.defaultValue=function(t){return arguments.length?(e(t),u):l.defaultValue},u.overrideValue=function(t){return arguments.length?(n(t),u):l.overrideValue},u.paddingValue=function(t){return arguments.length?(r(t),u):l.paddingValue},u.getValue=function(t){return arguments.length?(i(t),u):o.getValue},u.filter=function(t){return arguments.length?(a(t),u):o.filter},u.getExtent=function(t){var e,n=l.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
e=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=t&&
// Iterate over each element of the data
t.forEach(function(t,n){
// If the element passes the filter, then update the extent
if(o.filter(t,n)){r=!0;var i=o.getValue(t,n);e[0]=Math.min(e[0],i),e[1]=Math.max(e[1],i)}}),
// If we didn't find any data, use the default values
r||(e=l.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(e[0]=n[0]),null!=n[1]&&(e[1]=n[1]));var i=l.paddingValue;null==i||null==i[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
e[0]-=l.paddingValue[0]),null==i||null==i[1]||null!=n&&null!=n[1]||(e[1]+=l.paddingValue[1])}else
// Since the override is fully specified, use it
e=n;
// Verify that the extent is valid
return e[0]>e[1]&&(e[1]=e[0]),e},u(t),u}function s(t){function e(t){i=t}function n(t){a=t}/*
	 * Constructor/initialization method
	 */
function r(t){null!=t&&(null!=t.extent&&e(t.extent),null!=t.series&&n(t.series))}var i=c(),a=[];/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return r.extent=function(t){return arguments.length?(e(t),r):i},r.series=function(t){return arguments.length?(a=t,r):a},r.getExtent=function(t){var e;
// Iterate over each series
// In case there was no data
return a.forEach(function(n){
// Update the extent to set the value getter
i.getValue(n.getValue);
// Get the extent of the current series
var r=i.getExtent(t);
// If it's null, use the new extent
null==e?e=r:(e[0]=Math.min(e[0],r[0]),e[1]=Math.max(e[1],r[1]))}),null==e&&(e=i.getExtent([])),e},r(t),r}function d(t){/**
	 * Private Functions
	 */
function n(t){
// Should probably fire event for new brush state
m=t}function r(){return m&&null!=f}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function i(t){return null!=t&&Array.isArray(t)&&(t=t.map(function(t){return+t})),t}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function a(t){return(!Array.isArray(t)||2!=t.length||isNaN(t[0])||isNaN(t[1]))&&(t=void 0),t}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function l(t){return function(e){var n=null!=o.event.selection?i(o.event.selection.map(g.invert)):void 0,r=p,a=!((n===r||null!=n&&null!=r&&n[0]===r[0]&&n[1]===r[1])&&v);
// Store the new selection only on the 'end' event
"end"===t&&(
// Reset the selection
p=n,
// Reset the flag
v=!1),
// Suppress event if it's duplicate and programmatic
a&&h.apply(t,this,e)}}function c(t){var e=void 0;return m&&null!=t&&null!=g&&(e=null!=(e=u.brushSelection(t))&&Array.isArray(e)?i(e.map(g.invert)):void 0),e}function s(t,e){var n=null==(e=a(e))||e[0]>=e[1];
// either clear the filter or move it
v=!0,n?f.move(t,void 0):f.move(t,e.map(g))}function d(t){if(null==t)throw new Error("Must provide a brush and a scale");if(null==t.brush)throw new Error("Must provide a brush");if((f=t.brush).on("brush",l("brush")).on("start",l("start")).on("end",l("end")),null==t.scale)throw new Error("Must provide a scale");g=t.scale,null!=t.enabled&&n(t.enabled)}/**
	 * Private variables
	 */
// The brush object
var f,g,h=e.dispatch("brush","start","end"),p=void 0,m=!1,v=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return d.scale=function(t){return arguments.length?(g=t,d):g},d.dispatch=function(){return h},d.brush=function(){return f},d.enabled=function(t){return arguments.length?(n(t),d):r()},d.getSelection=function(t){return c(t)},d.setSelection=function(t,e){return s(t,e)},d(t),d}/**
 *
 *  data: []
 *  series: [ {label, x, y} ]
 *
 */
function f(){/**
	 * Explodes the data into an array with one point per unique point
	 * in the data (according to the series).
	 *
	 * I.e.,
	 *
	 * data: [{ x: 0, y1: 1, y2: 2}]
	 * series: [
	 *     { key: 's1', getValue: function(d) { return d.y1; } },
	 *     { key: 's2', getValue: function(d) { return d.y2; } }
	 * ]
	 *
	 * ==>
	 *
	 * [
	 *     { x: 0, y: 1, series: { key: 's1', ... }, data: { x: 0, y1: 1, y2: 2 },
	 *     { x: 0, y: 2, series: { key: 's2', ... }, data: { x: 0, y1: 1, y2: 2 },
	 * ]
	 *
	 * @param series
	 * @param data
	 */
function t(t,e,n){var r=[];
// Loop over each series
return t.forEach(function(t,i){
// Convert the data to x/y series
r=r.concat(e.map(function(e,r){return{x:n(e,r),y:t.getValue(e,r),series:t,data:e}}))}),r}function n(t){if(null!=t){var e=X.g.points.selectAll("circle").data(O.map(function(e){return{x:V.valueX(t.data),y:e.getValue(t.data),category:e.category}})),n=e.enter().append("circle"),r=e.selectAll("circle");n.merge(r).attr("class",function(t,e){return t.category}).attr("cx",function(t,e){return G.x(t.x)}).attr("cy",function(t,e){return G.y(t.y)}).attr("r",3)}else X.g.points.selectAll("circle").remove()}function o(t,e){var r=E.pointEvents;"value"===r||"values"===r&&n(t.data),I.call("pointMouseover",this,t.data,e)}function f(t,e){var r=E.pointEvents;"value"===r||"values"===r&&n(),I.call("pointMouseout",this,t.data,e)}function g(t,e){I.call("pointClick",this,t.data,e)}/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function h(){
// Try to get the node from the brush group selection
var t=null!=X.g.brush?X.g.brush.node():null;
// Get the current brush selection
return L.getSelection(t)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function p(t){L.setSelection(X.g.brush,t)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in brush change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function m(t){
// If there was no previous extent, then there is no brush to update
if(null!=t){
// Derive the overall plot extent from the collection of series
var e=M.x.getExtent(P);p(null!=e&&Array.isArray(e)&&2==e.length?[Math.max(e[0],t[0]),Math.min(e[1],t[1])]:void 0)}X.g.brush.style("display",L.enabled()?"unset":"none").call(L.brush())}function v(){null!=C.x&&X.g.xAxis.call(C.x),null!=C.xGrid&&E.xGrid&&X.g.xAxisGrid.call(C.xGrid),null!=C.y&&X.g.yAxis.call(C.y),null!=C.yGrid&&E.yGrid&&X.g.yAxisGrid.call(C.yGrid)}function x(){
// Join
var e=X.g.plots.selectAll(".plot").data(O,function(t){return t.key}),n=e.enter().append("g").attr("class","plot"),r=n.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" line"}),i=n.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" area"}),a=e.select(".line"),u=e.select(".area");if(
// Enter + Update
r.merge(a).attr("d",function(t){return T.y(function(e,n){return G.y(t.getValue(e,n))})(P)}),i.merge(u).attr("d",function(t){return N.y0(G.y.range()[0]).y1(function(e,n){return G.y(t.getValue(e,n))})(P)}),
// Remove the previous voronoi
X.g.voronoi.selectAll("path").remove(),E.pointEvents){
// check range against width
var l=G.x.domain(),c=t(O,P,V.valueX).filter(function(t){
// Filter out points that are outside of the extent
return l[0]<=t.x&&t.x<=l[1]});
// Filter out paths that are null
c=_.polygons(c).filter(function(t){return null!=t}),
// Draw the circle markers
X.g.voronoi.selectAll("path").data(c).enter().append("path").attr("d",function(t){return null!=t?"M"+t.join("L")+"Z":null}).on("mouseover",o).on("mouseout",f).on("click",g)}e.exit().remove()}function y(){
// Join
var t=X.g.markers.selectAll(".marker").data(D,V.markerValueX),e=t.enter().append("g").attr("class","marker").on("mouseover",function(t,e){I.call("markerMouseover",this,t,e)}).on("mouseout",function(t,e){I.call("markerMouseout",this,t,e)}).on("click",function(t,e){I.call("markerClick",this,t,e)}),n=e.append("line"),r=e.append("text");n.attr("y1",function(t){return G.y.range()[1]}).attr("y2",function(t){return G.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(V.markerLabel);
// Enter + Update
var i=t.select("line"),a=t.select("text");n.merge(i).attr("x1",function(t,e){return G.x(V.markerValueX(t,e))}).attr("x2",function(t,e){return G.x(V.markerValueX(t))}),r.merge(a).attr("x",function(t,e){return G.x(V.markerValueX(t))}),
// Exit
t.exit().remove()}
// Chart create/init method
function b(){}var k="timeline_line_"+Date.now(),w={top:10,right:10,bottom:20,left:40},z=100,A=600,E={xGrid:!1,yGrid:!1,pointEvents:!1},V={valueX:function(t){return t[0]},markerValueX:function(t){return t[0]},markerLabel:function(t){return t[1]},pointRadius:function(){return 2}},S=Date.now(),M={x:c({defaultValue:[S-3e5,S],getValue:function(t,e){return V.valueX(t,e)}}),y:c()},B=s(),G={x:r.scaleTime(),y:r.scaleLinear()},C={x:a.axisBottom().scale(G.x),y:a.axisLeft().ticks(3).scale(G.y),xGrid:a.axisBottom().tickFormat("").tickSizeOuter(0).scale(G.x),yGrid:a.axisLeft().tickFormat("").tickSizeOuter(0).ticks(3).scale(G.y)},T=i.line().x(function(t,e){return G.x(V.valueX(t,e))}),N=i.area().x(function(t,e){return G.x(V.valueX(t,e))}),_=l.voronoi().x(function(t,e){return G.x(t.x,e)}).y(function(t,e){return G.y(t.y,e)}),L=d({brush:u.brushX(),scale:G.x});L.dispatch().on("end",function(){I.call("brushEnd",this,h())}).on("start",function(){I.call("brushStart",this,h())}).on("brush",function(){I.call("brush",this,h())});
// The dispatch object and all events
var I=e.dispatch("brush","brushStart","brushEnd","markerClick","markerMouseover","markerMouseout","pointMouseover","pointMouseout","pointClick"),X={svg:void 0,g:{container:void 0,plots:void 0,points:void 0,voronoi:void 0,xAxis:void 0,yAxis:void 0,xAxisGrid:void 0,yAxisGrid:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},P=[],O=[],D=[];/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the data to drive the chart
	 */
/*
	 * Define the series to show on the chart
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return b.init=function(t){
// Create a container div
X.div=t.append("div").attr("class","sentio timeline"),
// Create the SVG element
X.svg=X.div.append("svg");
// Add the defs and add the clip path definition
var e=X.svg.append("defs");
// Append a container for everything
// Append the grid
// Append the path group (which will have the clip path and the line path
// Append groups for the axes
// Append a group for the voronoi and the points
// Append a group for the markers
// Add the brush element
return X.plotClipPath=e.append("clipPath").attr("id","plot_"+k).append("rect"),X.markerClipPath=e.append("clipPath").attr("id","marker_"+k).append("rect"),X.g.container=X.svg.append("g"),X.g.grid=X.g.container.append("g").attr("class","grid"),X.g.xAxisGrid=X.g.grid.append("g").attr("class","x"),X.g.yAxisGrid=X.g.grid.append("g").attr("class","y"),X.g.plots=X.g.container.append("g").attr("class","plots"),X.g.plots.attr("clip-path","url(#plot_"+k+")"),X.g.axes=X.g.container.append("g").attr("class","axis"),X.g.xAxis=X.g.axes.append("g").attr("class","x"),X.g.yAxis=X.g.axes.append("g").attr("class","y"),X.g.points=X.g.container.append("g").attr("class","points"),X.g.points.attr("clip-path","url(#marker_"+k+")"),X.g.voronoi=X.g.container.append("g").attr("class","voronoi"),X.g.markers=X.g.container.append("g").attr("class","markers"),X.g.markers.attr("clip-path","url(#marker_"+k+")"),X.g.brush=X.g.container.append("g").attr("class","x brush"),X.g.brush.attr("clip-path","url(#marker_"+k+")"),b.resize(),b},b.data=function(t){return arguments.length?(P=null!=t?t:[],b):P},b.series=function(t){return arguments.length?(O=null!=t?t:[],b):O},b.markers=function(t){return arguments.length?(D=null!=t?t:[],b):D},b.resize=function(){
// Need to grab the brush extent before we change anything
var t=h();
// Resize the SVG Pane
// Update the margins on the main draw group
// Resize Scales
/**
		 * Resize clip paths
		 */
// Plot clip path is only the plot pane
// Marker clip path includes top margin by default
// Resize the clip extent of the plot
/**
		 * Update axis and grids
		 */
// Reset axis and grid positions
// Resize the x grid ticks
// Resize the y grid ticks
/**
		 * Update the brush
		 */
// Resize and position the brush g element
// Resize the brush
return X.svg.attr("width",A).attr("height",z),X.g.container.attr("transform","translate("+w.left+","+w.top+")"),G.x.range([0,Math.max(0,A-w.left-w.right)]),G.y.range([Math.max(0,z-w.top-w.bottom),0]),X.plotClipPath.attr("transform","translate(0, -1)").attr("width",Math.max(0,G.x.range()[1])+2).attr("height",Math.max(0,G.y.range()[0])+2),X.markerClipPath.attr("transform","translate(0, -"+w.top+")").attr("width",Math.max(0,A-w.left-w.right)).attr("height",Math.max(0,z-w.bottom)),_.extent([[0,0],[A-w.left-w.right,z-w.top-w.bottom]]),X.g.xAxis.attr("transform","translate(0,"+G.y.range()[0]+")"),X.g.xAxisGrid.attr("transform","translate(0,"+G.y.range()[0]+")"),E.xGrid?C.xGrid.tickSizeInner(-(z-w.top-w.bottom)):C.xGrid.tickSizeInner(0),E.yGrid?C.yGrid.tickSizeInner(-(A-w.left-w.right)):C.yGrid.tickSizeInner(0),X.g.brush.selectAll("rect").attr("y",-1).attr("x",0).attr("width",G.x.range()[1]).attr("height",G.y.range()[0]+2),L.brush().extent([[0,0],[G.x.range()[1],G.y.range()[0]+2]]),m(t),b},b.redraw=function(){
// Need to grab the brush extent before we change anything
var t=h();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return G.x.domain(M.x.getExtent(P)),G.y.domain(B.extent(M.y).series(O).getExtent(P)),v(),x(),y(),m(t),b},b.width=function(t){return arguments.length?(A=t,b):A},b.height=function(t){return arguments.length?(z=t,b):z},b.margin=function(t){return arguments.length?(w=t,b):w},b.showXGrid=function(t){return arguments.length?(E.xGrid=t,b):E.xGrid},b.showYGrid=function(t){return arguments.length?(E.yGrid=t,b):E.yGrid},b.showGrid=function(t){return E.xGrid=E.yGrid=t,b},b.pointEvents=function(t){return arguments.length?(E.pointEvents=t,b):E.pointEvents},b.curve=function(t){return arguments.length?(T.curve(t),N.curve(t),b):T.curve()},b.xAxis=function(t){return arguments.length?(C.x=t,b):C.x},b.xGridAxis=function(t){return arguments.length?(C.xGrid=t,b):C.xGrid},b.yAxis=function(t){return arguments.length?(C.y=t,b):C.y},b.yGridAxis=function(t){return arguments.length?(C.yGrid=t,b):C.yGrid},b.xScale=function(t){return arguments.length?(G.x=t,null!=C.x&&C.x.scale(t),null!=C.xGrid&&C.xGrid.scale(t),null!=L&&L.scale(t),b):G.x},b.yScale=function(t){return arguments.length?(G.y=t,null!=C.y&&C.y.scale(t),null!=C.yGrid&&C.yGrid.scale(t),b):G.y},b.xValue=function(t){return arguments.length?(V.valueX=t,b):V.valueX},b.yExtent=function(t){return arguments.length?(M.y=t,b):M.y},b.xExtent=function(t){return arguments.length?(M.x=t,b):M.x},b.markerXValue=function(t){return arguments.length?(V.markerValueX=t,b):V.markerValueX},b.markerLabel=function(t){return arguments.length?(V.markerLabel=t,b):V.markerLabel},b.dispatch=function(t){return arguments.length?b:I},b.brush=function(t){return arguments.length?(L.enabled(t),b):L.enabled()},b.setBrush=function(t){return p(t),b},b.getBrush=function(){return h()},b}/**
 * Binning model for timelines
 *
 * This data model is responsible for subdiving a period of time into an array of sequential bins.
 * As data objects are added to the model, they are aggregated into the bins.
 *
 */
function g(t){/**
	 * Private Functions
	 */
// Get the index given the value
function e(t){return null==l.size||null==l.lwm?0:Math.floor((t-l.lwm)/l.size)}function n(){l.hwm=l.lwm+l.count*l.size}function r(){
// drop stuff below the lwm
for(var t,e=s;c.length>0&&c[0][0]<l.lwm;)t=c.shift(),s-=o.countBin(t);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=l.hwm;)t=c.pop(),s-=o.countBin(t);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([l.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-l.size;n>=l.lwm;n-=l.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<l.hwm-l.size;)c.push([c[c.length-1][0]+l.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(u,c,s,e)}function i(t){var n=s;t.forEach(function(t,n){var r=e(o.getKey(t,n));if(r>=0&&r<c.length){var i=o.getValue(t,n),a=o.countBin(c[r]);o.updateBin.call(u,c[r],i,n),s+=o.countBin(c[r])-a}}),o.afterAdd&&o.afterAdd.call(u,c,s,n)}function a(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function u(t){if(null==t||null==t.size||null==t.count||null==t.lwm)throw new Error("You must provide an initial size, count, and lwm");l.size=Number(t.size),l.count=Number(t.count),l.lwm=Number(t.lwm),null!=t.createSeed&&(o.createSeed=t.createSeed),null!=t.getKey&&(o.getKey=t.getKey),null!=t.getValue&&(o.getValue=t.getValue),null!=t.updateBin&&(o.updateBin=t.updateBin),null!=t.countBin&&(o.countBin=t.countBin),null!=t.afterAdd&&(o.afterAdd=t.afterAdd),null!=t.afterUpdate&&(o.afterUpdate=t.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var l={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(t){return t},
// The default value function
getValue:function(t){return t},
// The default function for updating a bin given a new value
updateBin:function(t,e){t[1].push(e)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(t){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof t[1]?t[1]:t[1].hasOwnProperty("length")?t[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(t,e,n){},
// The default function to be called after the bins are updated
afterUpdate:function(t,e,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return u.set=function(t){return a(),r(),i(t),u},u.clear=function(){return a(),r(),u},u.add=function(t){return i(t),u},u.lwm=function(t){if(!arguments.length)return l.lwm;var e=l.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return l.lwm=Number(t),n(),(e-l.lwm)%l.size!=0&&a(),r(),u},u.hwm=function(){return l.hwm},u.getKey=function(t){return arguments.length?(o.getKey=t,a(),r(),u):o.getKey},u.getValue=function(t){return arguments.length?(o.getValue=t,a(),r(),u):o.getValue},u.updateBin=function(t){return arguments.length?(o.updateBin=t,a(),r(),u):o.updateBin},u.createSeed=function(t){return arguments.length?(o.createSeed=t,a(),r(),u):o.createSeed},u.countBin=function(t){return arguments.length?(o.countBin=t,a(),r(),u):o.countBin},u.afterAdd=function(t){return arguments.length?(o.afterAdd=t,u):o.afterAdd},u.afterUpdate=function(t){return arguments.length?(o.afterUpdate=t,u):o.afterUpdate},u.size=function(t){if(!arguments.length)return l.size;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return t!==l.size&&(l.size=t,n(),a(),r()),u},u.count=function(t){if(!arguments.length)return l.count;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return t!==l.count&&(l.count=Math.floor(t),n(),r()),u},u.bins=function(){return c},u.itemCount=function(){return s},u.clearBin=function(t){if(t>=0&&t<c.length){var e=o.countBin(c[t]);return s-=e,c[t][1]=o.createSeed(),e}return 0},u(t),u}t.chartDonut=function(){
// Chart create/init method
function t(t){}/**
	 * Private functions
	 */
function a(){/*
		 * Join the data
		 */
var t=y.gChart.selectAll("path.arc").data(x.pie(b),function(t,e){return m.key(t.data,e)}),e=t.enter().append("path").attr("class","arc").on("mouseover",m.mouseover).on("mouseout",m.mouseout).on("click",m.click).each(function(t){this._current={startAngle:0,endAngle:0}}).merge(t);e.transition().duration(g).attrTween("d",function(t){var e=n.interpolate(this._current,t);return this._current=e(0),function(t){return x.arc(e(t))}}),e.attr("key",function(t,e){return m.key(t.data,e)}).attr("fill",function(t,e){return v.color(m.key(t.data,e))}),/*
		 * Exit
		 */
t.exit().remove()}function u(){var t=h.markSize+h.markMargin;
// Only option is 'center' for now
if("center"===h.position){
// The center position of the chart
var e=d.left+o,n=d.top+o;return"translate("+(e-(null==y.gLegend._maxWidth?0:y.gLegend._maxWidth)/2)+","+(n-(t*b.length+h.markMargin)/2)+")"}}function l(){/*
		 * Join the data
		 */
var t=y.gLegend.selectAll("g.entry").data(b,m.key),e=t.enter().append("g").attr("class","entry").attr("transform",function(t,e){return"translate(0, "+e*(h.markSize+h.markMargin)+")"}).on("mouseover",m.mouseover).on("mouseout",m.mouseout).on("click",m.click),n=e.append("rect").attr("width",h.markSize).attr("height",h.markSize);/*
		 * Enter + Update
		 */
e.append("text").attr("x",h.markSize+h.markMargin).attr("y",h.markSize-h.labelOffset).merge(t.select("text")).text(m.label),n.merge(t.select("rect")).style("fill",function(t,e){return v.color(m.key(t,e))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
e.merge(t).each(function(t,e){
// Reset
y.gLegend._maxWidth=0===e?this.getBBox().width:Math.max(this.getBBox().width,y.gLegend._maxWidth)}),
// Reassert the legend position
y.gLegend.attr("transform",u()),/*
		 * Exit
		 */
t.exit().remove()}
// Chart height/width
var o,c=400,s=400,d={top:2,bottom:2,right:2,left:2},f=.7,g=500,h={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},p=e.dispatch("mouseover","mouseout","click"),m={getEventElement:function(t,e){return null!=t&&null!=t.data?t.data:t},updateActiveElement:function(t,e){var n=y.gLegend.selectAll("g.entry"),r=y.gChart.selectAll("path.arc");if(null!=t){
// Set the highlight on the row
var i=m.key(t,e);n.classed("active",function(t,e){return m.key(t,e)==i}),r.classed("active",function(t,e){return m.key(t.data,e)==i})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(t,e){t=m.getEventElement(t,e),m.updateActiveElement(t,e),p.call("mouseover",this,t,e)},mouseout:function(t,e){t=m.getEventElement(t,e),m.updateActiveElement(),p.call("mouseout",this,t,e)},click:function(t,e){t=m.getEventElement(t,e),p.call("click",this,t,e)},key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},v={color:r.scaleOrdinal(r.schemeCategory10)},x={arc:i.arc().padAngle(.01),pie:i.pie().value(function(t,e){return m.value(t,e)}).sort(null)},y={div:void 0,svg:void 0,gChart:void 0,legend:void 0},b=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return t.init=function(e){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return y.div=e.append("div").attr("class","sentio donut"),y.svg=y.div.append("svg"),y.gChart=y.svg.append("g").attr("class","chart"),y.gLegend=y.svg.append("g").attr("class","legend"),t.resize(),t},t.data=function(e){return arguments.length?(b=null!=e?e:[],t):b},t.resize=function(){var e=c-d.right-d.left,n=s-d.top-d.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return o=Math.min(n,e)/2,y.svg.attr("width",c).attr("height",s),y.gChart.attr("transform","translate("+(d.left+o)+","+(d.top+o)+")"),x.arc.innerRadius(o*f).outerRadius(o),y.gLegend.attr("transform",u()),t},t.redraw=function(){return a(),h.enabled&&l(),t},t.width=function(e){return arguments.length?(c=e,t):c},t.height=function(e){return arguments.length?(s=e,t):s},t.innerRadiusRatio=function(e){return arguments.length?(f=e,t):f},t.duration=function(e){return arguments.length?(g=e,t):g},t.key=function(e){return arguments.length?(m.key=e,t):m.key},t.value=function(e){return arguments.length?(m.value=e,t):m.value},t.label=function(e){return arguments.length?(m.label=e,t):m.label},t.colorScale=function(e){return arguments.length?(v.color=e,t):v.color},t.dispatch=function(){return p},t.legend=function(e){return arguments.length?(h=e,t):h},t},t.chartMatrix=function(){function t(t,e){var n=b.g.chart.selectAll(".row text");if(null!=t){
// Set the highlight on the row
var r=t.key;n.classed("active",function(t){return t.key==r})}else
// Now update the style
n.classed("active",!1)}function n(e,n){t(e,n),z.call("rowMouseover",this,e,n)}function i(e,n){t(),z.call("rowMouseout",this,e,n)}function u(t,e){z.call("rowClick",this,t,e)}function l(t,e){z.call("cellMouseover",this,t,e)}function o(t,e){z.call("cellMouseout",this,t,e)}function d(t,e){z.call("cellClick",this,t,e)}/**
	 * Style stuff
	 */
// Cell dimensions
var f=16,g=1,h={top:20,right:2,bottom:2,left:64},p=500,m={key:function(t){return t.key},value:function(t){return t.value}},v={x:c().getValue(function(t,e){return m.key(t,e)}),value:c(),multi:s()},x={x:r.scaleLinear(),y:r.scaleOrdinal(),color:r.scaleLinear().range(["#e7e7e7","#008500"])},y={x:a.axisTop().scale(x.x).tickSizeOuter(0).tickSizeInner(2)},b={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},k=[],w=[],z=e.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),A=function(){};return A.init=function(t){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return b.div=t.append("div").attr("class","sentio matrix"),b.svg=b.div.append("svg"),b.g.xAxis=b.svg.append("g").attr("class","x axis"),b.g.chart=b.svg.append("g").attr("class","chart"),A},A.resize=function(){},A.redraw=function(){
// Determine the number of rows/boxes to render
var t=w.length,e=k.length,r=g+f,a=e*r+g,c=t*r+g;
// scale the svg to the right size
b.svg.attr("width",a+h.left+h.right).attr("height",c+h.top+h.bottom),
// Configure the scales
x.x.domain(v.x.getExtent(k)).range([0,a-g-r]),x.color.domain(v.multi.extent(v.value).series(w).getExtent(k)),
// Draw the x axis
b.g.xAxis.attr("transform","translate("+(h.left+g+f/2)+","+h.top+")"),b.g.xAxis.call(y.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var s=b.g.chart.selectAll("g.row").data(w,function(t){return t.key}),z=s.enter().append("g");z.style("opacity","0.1").attr("class","row").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}).on("mouseover",n).on("mouseout",i).on("click",u),
// Also must append the label of the row
z.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",g+f/2).attr("dy",".32em"),
// Also must append a line
z.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",g+f/2).attr("y2",g+f/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var E=z.merge(s);E.transition().duration(p).style("opacity","1").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}),
// Update the series labels in case they changed
E.select("text.series.label").text(function(t){return t.label}),/*
		 * Row Exit
		 */
s.exit().transition().duration(p).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var V=E.selectAll("rect.cell").data(function(t){return k.map(function(e,n){return{key:m.key(e,n),value:t.getValue(e,n)}})},m.key);/*
		 * Cell Remove
		 */
return V.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(t,e){return x.color(t.value)}).attr("x",function(t,e){return x.x(t.key)+g}).attr("y",g).attr("height",f).attr("width",f).on("mouseover",l).on("mouseout",o).on("click",d).merge(V).transition().duration(p).style("opacity","1").attr("x",function(t,e){return x.x(t.key)+g}).style("fill",function(t,e){return x.color(t.value)}),V.exit().transition().duration(p).attr("width",0).style("opacity","0.1").remove(),A},A.data=function(t){return arguments.length?(k=null!=t?t:[],A):k},A.series=function(t){return arguments.length?(w=null!=t?t:[],A):w},A.cellSize=function(t){return arguments.length?(f=t,A):f},A.cellMargin=function(t){return arguments.length?(g=t,A):g},A.margin=function(t){return arguments.length?(h=t,A):h},A.duration=function(t){return arguments.length?(p=t,A):p},A.key=function(t){return arguments.length?(m.key=t,A):m.key},A.colorScale=function(t){return arguments.length?(x.color=t,A):x.color},A.xScale=function(t){return arguments.length?(x.xScale=t,y.x.scale(t),A):x.xScale},A.yScale=function(t){return arguments.length?(x.yScale=t,A):x.yScale},A.xExtent=function(t){return arguments.length?(v.x=t,v.x.getValue(function(e,n){return t(e,n)}),A):v.x},A.valueExtent=function(t){return arguments.length?(v.value=t,A):v.value},A.dispatch=function(){return z},A},t.chartTimeline=f,t.chartAutoBrushTimeline=function(){function t(t){var e=t;
// Crop the brush to max extent
// Make a new copy
// Crop the brush using the max extent
return null!=e&&((e=t.slice())[0]=Math.max(e[0],h[0]),e[1]=Math.min(e[1],h[1])),e}/**
	 * Handle a change to the brush (whether from the timeline or manual)
	 * - Crop the brush if necessary based on maxExtent
	 * - Ensure the brush is valid.
	 * - Update the brush and recalculate the extent.
	 *
	 * @param newBrush
	 */
function n(e){
// Ensure the brush is valid
null!=(e=t(e))?(
// Update the brush
l=e,x.setBrush(e),
// Update the extent as necessary
r(),
// Fire the brush change event
m.call("brushChange",this,e)):
// Don't allow them to apply an invalid brush
x.setBrush(l),v.redraw()}/**
	 * Update the extent
	 */
function r(){var t=a(l);if(t.pan||t.zoom){
// Update the Extent and fire the event
var e=u(l,t);v.xExtent().overrideValue(e),m.call("extentChange",this,e)}}/**
	 * Check to see if the extent needs to change
	 * - Checks boundaries and zoom level
	 * - Returns a status to indicate how the extent needs to change
	 *
	 * @param brush
	 * @returns { pan: boolean, zoom: boolean }
	 */
function a(t){var e={pan:!1,zoom:!1};if(null!=t){var n=v.xScale(),r=n.domain()[0],i=t[0],a=t[1],u=n.domain()[1],l=u-r,o=(a-i)/l,c=(i-r)/l<=s.edgeTrigger&&i>h[0],d=(u-a)/l<=s.edgeTrigger&&a<h[1];
// Should we resize and/or recenter?
e.zoom=o>=s.zoomOutTrigger||o<=s.zoomInTrigger,e.pan=c||d}return e}/**
	 * Given the brush, determine the new xExtent that should be applied
	 * @param brush The brush for which to determine the extent
	 * @param transform What kind of transform we should apply (whether zoom or pan)
	 * @returns {[*,*]}
	 */
function u(t,e){var n=v.xScale().domain()[0],r=t[0],i=t[1],a=v.xScale().domain()[1]-n;
// If we're zooming, change the target width
e.zoom&&(
// Calculate the new width of the extent (and make sure it isn't smaller than the max zoom)
a=Math.max((i-r)/s.zoomTarget,d));
// Determine the current center of the brush
var u=r+(i-r)/2,l=Math.max(u-a/2,h[0]);
// Track how much of the width we successfully applied to the new lower bound
a-=u-l;
// Determine the new upper bound as as much of the width as we can apply above the center
var o=Math.min(u+a,h[1]);
// Track how much of the width we applied to the upper bound
// If newWidthE is greater than zero, it means that clipping kept us from applying
// all of the width, so we should try to apply the rest to the lower bound
return a-=o-u,l=Math.max(l-a,h[0]),[l,o]}var l,o="autobrush_timeline_"+Date.now(),c=Date.now(),s={edgeTrigger:.01,zoomInTrigger:.05,zoomOutTrigger:.8,zoomTarget:.2},d=864e5,g=36e5,h=[c-31536e7,c],p=[c-15552e6,c],m=e.dispatch("extentChange","brushChange"),v=f();
// Turn on brushing and register for brush events
v.brush(!0),v.dispatch().on("brushEnd.internal",n),
// Turn off pointer events by default
v.pointEvents(!1);var x={element:{g:{container:void 0},axisClipPath:void 0},brush:v.brush,dispatch:v.dispatch,init:v.init,resize:v.resize,redraw:v.redraw,setBrush:v.setBrush,xAxis:v.xAxis};
// Set up default look and feel
// Initialization of the timeline and auto brush
// Redraw the auto brush
// Resize
// Basic Getters/Setters
// Cannot disable the brush
return v.margin({top:2,right:10,bottom:2,left:10}),v.xAxis().ticks(5),v.yAxis(null),v.init=function(t){
// Store the container
// Initialize the timeline
// Set the initial brush
// Add a clip path for the axis
// Attach the clip path to the axis
return x.element.g.container=t,x.init(t),null==l&&(l=p,v.setBrush(l)),x.element.axisClipPath=t.select("svg defs").append("clipPath").attr("id","axis_"+o).append("rect"),x.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("clip-path","url(#axis_"+o+")"),v.resize(),v},v.redraw=function(){
// Let the timeline redraw like normal
x.redraw(),/*
		 * Update the X Axis
		 */
// Set the x Axis ticks to be full height
v.xAxis().tickSize(-v.height()+v.margin().top+v.margin().bottom);
// Update text position to be on the chart
var t=x.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("pointer-events","none");
// Set the x Axis ticks to be full height
// Set the curve to interpolate
// Call it to redraw
return t.selectAll("g.tick text").attr("y","3").attr("dy","-0.71em").attr("dx","0.35em").attr("text-anchor","start"),v.xAxis().tickSize(-v.height()+v.margin().top+v.margin().bottom),v.curve(i.curveNatural),null!=v.xAxis()&&t.call(v.xAxis()),v},v.resize=function(){
// Need to be defensive here since parent init calls resize
if(x.resize(),null!=x.element.axisClipPath){var t=v.margin(),e=v.width(),n=v.height();
// Update the size of the xAxis clip path
x.element.axisClipPath.attr("transform","translate(0, -"+(n+t.top)+")").attr("width",Math.max(0,e-t.left-t.right+2)).attr("height",Math.max(0,n+t.bottom+t.top))}},v.edgeTrigger=function(t){return arguments.length?(s.edgeTrigger=t,v):s.edgeTrigger},v.zoomInTrigger=function(t){return arguments.length?(s.zoomInTrigger=t,v):s.zoomInTrigger},v.zoomOutTrigger=function(t){return arguments.length?(s.zoomOutTrigger=t,v):s.zoomOutTrigger},v.zoomTarget=function(t){return arguments.length?(s.zoomTarget=t,v):s.zoomTarget},v.maxExtent=function(t){return arguments.length?(h=t,v):h},v.minExtent=function(t){return arguments.length?(d=t,v):d},v.minBrush=function(t){return arguments.length?(g=t,v):g},v.setBrush=function(t){return n(t),v},v.dispatch=function(){return m},v.timelineDispatch=function(){return x.dispatch},v.brush=function(){return!0},v},t.chartRealtimeTimeline=function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function t(){
// If not running, let the loop die
r&&(u.redraw(),
// Schedule the next update
i=window.setTimeout(t,a>0?1e3/a:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var e=0,n=6e4,r=!1,i=null,a=32,u=f();u.yExtent().filter(function(t){var e=u.xValue()(t),n=u.xExtent().getExtent();return e<n[1]&&e>n[0]}),u.brush(!1),u.pointEvents(!1);/*
	 * Redraw the graphic
	 */
var l=u.redraw;return u.redraw=function(){
// Update the x domain (to the latest time window)
var t=new Date;return u.xExtent().overrideValue([t-e-n,t-e]),l(),u},u.start=function(){if(!r)return r=!0,t(),u},u.stop=function(){return r=!1,null!=i&&window.clearTimeout(i),u},u.restart=function(){return u.stop(),u.start(),u},u.interval=function(t){return arguments.length?(n=t,u):n},u.delay=function(t){return arguments.length?(e=t,u):e},u.fps=function(t){return arguments.length?(a=t,r&&u.restart(),u):a},u.brush=function(t){return!1},u},t.chartVerticalBars=function(){function t(t,e){d.call("mouseover",this,t,e)}function n(t,e){d.call("mouseout",this,t,e)}function i(t,e){d.call("click",this,t,e)}
// Chart create/init method
function a(t){}
// Layout properties
var u=100,l=24,o=2,s=500,d=e.dispatch("mouseover","mouseout","click"),f={key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},g={x:r.scaleLinear(),y:r.scaleLinear()},h={width:c({defaultValue:[0,10],getValue:function(t,e){return f.value(t,e)}})},p={div:void 0},m=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return a.init=function(t){
// Create the DIV element
return p.div=t.append("div").attr("class","sentio bars-vertical"),a.resize(),a},a.data=function(t){return arguments.length?(m=null!=t?t:[],a):m},a.resize=function(){
// Set up the x scale (y is fixed)
return g.x.range([0,u]),a},a.redraw=function(){
// Update the x domain
g.x.domain(h.width.getExtent(m)),
// Update the y domain (based on configuration and data)
g.y.domain([0,m.length]),g.y.range([0,(l+o)*m.length]);
// Data Join
var e=p.div.selectAll("div.bar").data(m,f.key),r=e.enter().append("div").attr("class","bar").style("top",g.y.range()[1]-l+"px").style("height",l+"px").on("mouseover",t).on("mouseout",n).on("click",i).style("opacity","0.01"),u=r.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return r.merge(e).transition().duration(s).style("opacity","1").style("width",function(t,e){return g.x(f.value(t,e))+"px"}).style("top",function(t,e){return g.y(e)+"px"}).style("left","0px"),u.merge(e.select("div.bar-label")).html(f.label).style("max-width",g.x.range()[1]-10+"px"),e.exit().transition().duration(s).style("opacity","0.01").style("top",g.y.range()[1]-l+"px").remove(),p.div.style("height",g.y.range()[1]+"px"),a},a.width=function(t){return arguments.length?(u=t,a):u},a.barHeight=function(t){return arguments.length?(l=t,a):l},a.barPadding=function(t){return arguments.length?(o=t,a):o},a.key=function(t){return arguments.length?(f.key=t,a):f.key},a.value=function(t){return arguments.length?(f.value=t,a):f.value},a.label=function(t){return arguments.length?(f.label=t,a):f.label},a.widthExtent=function(t){return arguments.length?(h.width=t,h.width.getValue(function(t,e){return f.value(t,e)}),a):h.width},a.dispatch=function(t){return arguments.length?a:d},a.duration=function(t){return arguments.length?(s=t,a):s},a},t.controllerRealtimeBins=/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(t){/**
	 * Private Functions
	 */
function e(){
// Assume the hwm is now plus two binSize
var t=Date.now()+2*u.size();
// Trunc the hwm down to a round value based on the binSize
return(t=Math.floor(t/u.size())*u.size())-u.size()*u.count()}function n(){!0===l&&(
// need to update the lwm
u.lwm(e()),window.setTimeout(n,u.size()))}function r(){l||(
// Start the update loop
l=!0,n())}function i(){
// Setting running to false will stop the update loop
l=!1}
// create/init method
function a(t){if(null==t||null==t.binCount||null==t.binSize)throw new Error("You must provide an initial binSize and binCount");o.binSize=Number(t.binSize),o.binCount=Number(t.binCount),null!=t.delay&&(o.delay=Number(t.delay)),(u=g({size:o.binSize,count:o.binCount+2,lwm:0})).lwm(e()),r()}/**
	 * Private variables
	 */
var u,l,o={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return a.model=function(){return u},a.bins=function(){return u.bins()},a.start=function(){return r(),a},a.stop=function(){return i(),a},a.running=function(){return l},a.add=function(t){return u.add(t),a},a.clear=function(){return u.clear(),a},a.binSize=function(t){if(!arguments.length)return o.binSize;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");return o.binSize=t,u.size(t),u.lwm(e()),a},a.binCount=function(t){if(!arguments.length)return o.binCount;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");return o.binCount=t,u.count(t+2),u.lwm(e()),a},a(t),a},t.timelineBrush=d,t.modelBins=g,t.modelExtent=c,t.modelMultiExtent=s,Object.defineProperty(t,"__esModule",{value:!0})});