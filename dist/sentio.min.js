/*! @asymmetrik/sentio - 4.0.1 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("d3")):"function"==typeof define&&define.amd?define(["exports","d3"],t):t(e.sentio={},e.d3)}(this,function(e,t){"use strict";function n(e){/**
	 * Private Functions
	 */
function t(e){if(null==e||2!==e.length||isNaN(e[0])||isNaN(e[1])||e[0]>=e[1])throw new Error("Default extent must be a two element ordered array of numbers");a.defaultValue=e}function n(e){if(null!=e&&2!==e.length)throw new Error("Extent override must be a two element array or null/undefined");a.overrideValue=e}function r(e){if("function"!=typeof e)throw new Error("Value getter must be a function");l.getValue=e}function u(e){if("function"!=typeof e)throw new Error("Filter must be a function");l.filter=e}/*
	 * Constructor/initialization method
	 */
function i(e){null!=e&&(null!=e.defaultValue&&t(e.defaultValue),null!=e.overrideValue&&n(e.overrideValue),null!=e.getValue&&r(e.getValue),null!=e.filter&&u(e.filter))}/**
	 * Private variables
	 */
// Configuration
var a={defaultValue:[0,10],overrideValue:void 0},l={getValue:function(e){return e},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return i.defaultValue=function(e){return arguments.length?(t(e),i):a.defaultValue},i.overrideValue=function(e){return arguments.length?(n(e),i):a.overrideValue},i.getValue=function(e){return arguments.length?(r(e),i):l.getValue},i.filter=function(e){return arguments.length?(u(e),i):l.filter},i.getExtent=function(e){var t,n=a.overrideValue;
// Check to see if we need to calculate the extent
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
t=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=e&&
// Iterate over each element of the data
e.forEach(function(e,n){
// If the element passes the filter, then update the extent
if(l.filter(e,n)){r=!0;var u=l.getValue(e,n);t[0]=Math.min(t[0],u),t[1]=Math.max(t[1],u)}}),
// If we didn't find any data, use the default values
r||(t=a.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(
// Set the lower override
t[0]=n[0],t[0]>t[1]&&(t[1]=t[0])),null!=n[1]&&(t[1]=n[1],t[1]<t[0]&&(t[0]=t[1])))}else
// Since the override is fully specified, use it
t=n;return t},i(e),i}function r(e){/**
	 * Private Functions
	 */
function t(e){i=e}/*
	 * Constructor/initialization method
	 */
function r(e){null!=e&&null!=e.extent&&t(e.extent)}/**
	 * Private variables
	 */
var u={values:function(e){return e.values}},i=n();/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return r.extent=function(e){return arguments.length?(t(e),r):i},r.values=function(e){return arguments.length?(u.values=e,r):u.values},r.getExtent=function(e){var t;
// In case there was no data
return e.forEach(function(e,n){var r=i.getExtent(u.values(e,n));null==t?t=r:(t[0]=Math.min(t[0],r[0]),t[1]=Math.max(t[1],r[1]))}),null==t&&(t=i.getExtent([])),t},r(e),r}function u(e){/**
	 * Private Functions
	 */
function n(e){
// Should probably fire event for new brush state
h=e}function r(){return h&&null!=s}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function u(e){return null!=e&&Array.isArray(e)&&(e=e.map(function(e){return+e})),e}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function i(e){return(!Array.isArray(e)||2!=e.length||isNaN(e[0])||isNaN(e[1]))&&(e=void 0),e}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function a(e){return function(n){var r=null!=t.event.selection?u(t.event.selection.map(f.invert)):void 0,i=g,a=!((r===i||null!=r&&null!=i&&r[0]===i[0]&&r[1]===i[1])&&v);
// Store the new selection only on the 'end' event
"end"===e&&(
// Reset the selection
g=r,
// Reset the flag
v=!1),
// Suppress event if it's duplicate and programmatic
a&&d.apply(e,this,n)}}function l(e){var n=void 0;return h&&null!=e&&null!=f&&(n=null!=(n=t.brushSelection(e))&&Array.isArray(n)?u(n.map(f.invert)):void 0),n}function o(e,t){var n=null==(t=i(t))||t[0]>=t[1];
// either clear the filter or move it
v=!0,n?s.move(e,void 0):s.move(e,t.map(f))}function c(e){if(null==e)throw new Error("Must provide a brush and a scale");if(null==e.brush)throw new Error("Must provide a brush");if((s=e.brush).on("brush",a("brush")).on("start",a("start")).on("end",a("end")),null==e.scale)throw new Error("Must provide a scale");f=e.scale,null!=e.enabled&&n(e.enabled)}/**
	 * Private variables
	 */
// The brush object
var s,f,d=t.dispatch("brush","start","end"),g=void 0,h=!1,v=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return c.scale=function(e){return arguments.length?(f=e,c):f},c.dispatch=function(){return d},c.brush=function(){return s},c.enabled=function(e){return arguments.length?(n(e),c):r()},c.getSelection=function(e){return l(e)},c.setSelection=function(e,t){return o(e,t)},c(e),c}function i(){/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function e(){
// Try to get the node from the brush group selection
var e=null!=V.g.brush?V.g.brush.node():null;
// Get the current brush selection
return E.getSelection(e)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function i(e){E.setSelection(V.g.brush,e)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in filter change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function a(e){
// If there was no previous extent, then there is no brush to update
if(null!=e){
// Derive the overall plot extent from the collection of series
var t=b.extent(y.x).getExtent(M);i(null!=t&&Array.isArray(t)&&2==t.length?[Math.max(t[0],e[0]),Math.min(t[1],e[1])]:void 0)}V.g.brush.style("display",E.enabled()?"unset":"none").call(E.brush())}
// Chart create/init method
function l(){}function o(){null!=k.x&&V.g.xAxis.call(k.x),null!=k.y&&V.g.yAxis.call(k.y)}function c(){
// Join
var e=V.g.plots.selectAll(".plot").data(M,v.seriesKey),t=e.enter().append("g").attr("class","plot"),n=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" line"}),r=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" area"}),u=e.select(".line"),i=e.select(".area");
// Enter + Update
n.merge(u).datum(v.seriesValues).attr("d",z),r.merge(i).datum(v.seriesValues).attr("d",A.y0(w.y.range()[0])),e.exit().remove()}function s(){
// Join
var e=V.g.markers.selectAll(".marker").data(C.values,p.x),t=e.enter().append("g").attr("class","marker").on("mouseover",function(e,t){S.call("markerMouseover",this,e,t)}).on("mouseout",function(e,t){S.call("markerMouseout",this,e,t)}).on("click",function(e,t){S.call("markerClick",this,e,t)}),n=t.append("line"),r=t.append("text");n.attr("y1",function(e){return w.y.range()[1]}).attr("y2",function(e){return w.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(p.label);
// Enter + Update
var u=e.select("line"),i=e.select("text");n.merge(u).attr("x1",function(e,t){return w.x(p.x(e,t))}).attr("x2",function(e,t){return w.x(p.x(e))}),r.merge(i).attr("x",function(e,t){return w.x(p.x(e))}),
// Exit
e.exit().remove()}var f="timeline_line_"+Date.now(),d={top:10,right:10,bottom:20,left:40},g=100,h=600,v={valueX:function(e){return e[0]},valueY:function(e){return e[1]},markerValueX:function(e){return e[0]},markerLabel:function(e){return e[1]},seriesKey:function(e){return e.key},seriesValues:function(e){return e.values},seriesLabel:function(e){return e.label}},m={x:function(e){return e[0]},y:function(e){return e[1]}},p={x:function(e,t){return e[0]},label:function(e,t){return e[1]}},x=Date.now(),y={x:n({defaultValue:[x-3e5,x],getValue:function(e,t){return v.valueX(e,t)}}),y:n({getValue:function(e,t){return v.valueY(e,t)}})},b=r().values(function(e,t){return v.seriesValues(e,t)}),w={x:t.scaleTime(),y:t.scaleLinear()},k={x:t.axisBottom().scale(w.x),y:t.axisLeft().scale(w.y).ticks(3)},V={svg:void 0,g:{container:void 0,plots:void 0,xAxis:void 0,yAxis:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},z=t.line();z.x(function(e,t){return w.x(v.valueX(e,t))}),z.y(function(e,t){return w.y(v.valueY(e,t))});
// Area generator for the plot
var A=t.area();A.x(function(e,t){return w.x(v.valueX(e,t))}),A.y1(function(e,t){return w.y(v.valueY(e,t))});
// Brush Management
var E=u({brush:t.brushX(),scale:w.x});E.dispatch().on("end",function(){S.call("filterend",this,e())}).on("start",function(){S.call("filterstart",this,e())}).on("brush",function(){S.call("filter",this,e())});
// The dispatch object and all events
var S=t.dispatch("filter","filterstart","filterend","markerClick","markerMouseover","markerMouseout"),M=[],C={values:[]};/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return l.init=function(e){
// Create a container div
// Create the SVG element
// Add the defs and add the clip path definition
// Append a container for everything
// Append the path group (which will have the clip path and the line path
// Add the filter brush element
// Append a group for the markers
// Append groups for the axes
return V.div=e.append("div").attr("class","sentio timeline"),V.svg=V.div.append("svg"),V.plotClipPath=V.svg.append("defs").append("clipPath").attr("id","plot_"+f).append("rect"),V.markerClipPath=V.svg.append("defs").append("clipPath").attr("id","marker_"+f).append("rect"),V.g.container=V.svg.append("g"),V.g.plots=V.g.container.append("g").attr("class","plots").attr("clip-path","url(#plot_"+f+")"),V.g.brush=V.g.container.append("g").attr("class","x brush").attr("clip-path","url(#marker_"+f+")"),V.g.markers=V.g.container.append("g").attr("class","markers").attr("clip-path","url(#marker_"+f+")"),V.g.xAxis=V.g.container.append("g").attr("class","x axis"),V.g.yAxis=V.g.container.append("g").attr("class","y axis"),l.resize(),l},l.data=function(e){return arguments.length?(M=null!=e?e:[],l):M},l.markers=function(e){return arguments.length?(C.values=null!=e?e:[],l):C.values},l.resize=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Set up the scales
// Append the clip path
// Now update the size of the svg pane
// Update the positions of the axes
// update the margins on the main draw group
// Update the size of the brush
return w.x.range([0,Math.max(0,h-d.left-d.right)]),w.y.range([Math.max(0,g-d.top-d.bottom),0]),V.plotClipPath.attr("transform","translate(0, -"+d.top+")").attr("width",Math.max(0,h-d.left-d.right)).attr("height",Math.max(0,g-d.bottom)),V.markerClipPath.attr("transform","translate(0, -"+d.top+")").attr("width",Math.max(0,h-d.left-d.right)).attr("height",Math.max(0,g-d.bottom)),V.svg.attr("width",h).attr("height",g),V.g.xAxis.attr("transform","translate(0,"+w.y.range()[0]+")"),V.g.yAxis.attr("class","y axis"),V.g.container.attr("transform","translate("+d.left+","+d.top+")"),V.g.brush.selectAll("rect").attr("y",0).attr("x",0).attr("height",h-d.left-d.right).attr("height",g-d.top-d.bottom+4),E.brush().extent([[0,0],[h-d.left-d.right,g-d.top-d.bottom]]),a(t),l},l.redraw=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return w.x.domain(b.extent(y.x).getExtent(M)),w.y.domain(b.extent(y.y).getExtent(M)),o(),c(),s(),a(t),l},l.width=function(e){return arguments.length?(h=e,l):h},l.height=function(e){return arguments.length?(g=e,l):g},l.margin=function(e){return arguments.length?(d=e,l):d},l.curve=function(e){return arguments.length?(z.curve(e),A.curve(e),l):z.curve()},l.xAxis=function(e){return arguments.length?(k.x=e,l):k.x},l.yAxis=function(e){return arguments.length?(k.y=e,l):k.y},l.xScale=function(e){return arguments.length?(w.x=e,null!=k.x&&k.x.scale(e),null!=E&&E.scale(e),l):w.x},l.yScale=function(e){return arguments.length?(w.y=e,null!=k.y&&k.y.scale(e),l):w.y},l.xValue=function(e){return arguments.length?(m.x=e,l):m.x},l.yValue=function(e){return arguments.length?(m.y=e,l):m.y},l.yExtent=function(e){return arguments.length?(y.y=e,l):y.y},l.xExtent=function(e){return arguments.length?(y.x=e,l):y.x},l.seriesKey=function(e){return arguments.length?(v.seriesKey=e,l):v.seriesKey},l.seriesLabel=function(e){return arguments.length?(v.seriesLabel=e,l):v.seriesLabel},l.seriesValues=function(e){return arguments.length?(v.seriesValues=e,l):v.seriesValues},l.markerXValue=function(e){return arguments.length?(p.x=e,l):p.x},l.markerLabel=function(e){return arguments.length?(p.label=e,l):p.label},l.dispatch=function(e){return arguments.length?l:S},l.filter=function(e){return arguments.length?(E.enabled(e),l):E.enabled()},l.setFilter=function(e){return i(e),l},l.getFilter=function(){return e()},l}function a(e){/**
	 * Private Functions
	 */
// Get the index given the value
function t(e){return null==l.size||null==l.lwm?0:Math.floor((e-l.lwm)/l.size)}function n(){l.hwm=l.lwm+l.count*l.size}function r(){
// drop stuff below the lwm
for(var e,t=s;c.length>0&&c[0][0]<l.lwm;)e=c.shift(),s-=o.countBin(e);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=l.hwm;)e=c.pop(),s-=o.countBin(e);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([l.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-l.size;n>=l.lwm;n-=l.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<l.hwm-l.size;)c.push([c[c.length-1][0]+l.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(a,c,s,t)}function u(e){var n=s;e.forEach(function(e,n){var r=t(o.getKey(e,n));if(r>=0&&r<c.length){var u=o.getValue(e,n),i=o.countBin(c[r]);o.updateBin.call(a,c[r],u,n),s+=o.countBin(c[r])-i}}),o.afterAdd&&o.afterAdd.call(a,c,s,n)}function i(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function a(e){if(null==e||null==e.size||null==e.count||null==e.lwm)throw new Error("You must provide an initial size, count, and lwm");l.size=Number(e.size),l.count=Number(e.count),l.lwm=Number(e.lwm),null!=e.createSeed&&(o.createSeed=e.createSeed),null!=e.getKey&&(o.getKey=e.getKey),null!=e.getValue&&(o.getValue=e.getValue),null!=e.updateBin&&(o.updateBin=e.updateBin),null!=e.countBin&&(o.countBin=e.countBin),null!=e.afterAdd&&(o.afterAdd=e.afterAdd),null!=e.afterUpdate&&(o.afterUpdate=e.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var l={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(e){return e},
// The default value function
getValue:function(e){return e},
// The default function for updating a bin given a new value
updateBin:function(e,t){e[1].push(t)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(e){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof e[1]?e[1]:e[1].hasOwnProperty("length")?e[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(e,t,n){},
// The default function to be called after the bins are updated
afterUpdate:function(e,t,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return a.set=function(e){return i(),r(),u(e),a},a.clear=function(){return i(),r(),a},a.add=function(e){return u(e),a},a.lwm=function(e){if(!arguments.length)return l.lwm;var t=l.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return l.lwm=Number(e),n(),(t-l.lwm)%l.size!=0&&i(),r(),a},a.hwm=function(){return l.hwm},a.getKey=function(e){return arguments.length?(o.getKey=e,i(),r(),a):o.getKey},a.getValue=function(e){return arguments.length?(o.getValue=e,i(),r(),a):o.getValue},a.updateBin=function(e){return arguments.length?(o.updateBin=e,i(),r(),a):o.updateBin},a.createSeed=function(e){return arguments.length?(o.createSeed=e,i(),r(),a):o.createSeed},a.countBin=function(e){return arguments.length?(o.countBin=e,i(),r(),a):o.countBin},a.afterAdd=function(e){return arguments.length?(o.afterAdd=e,a):o.afterAdd},a.afterUpdate=function(e){return arguments.length?(o.afterUpdate=e,a):o.afterUpdate},a.size=function(e){if(!arguments.length)return l.size;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return e!==l.size&&(l.size=e,n(),i(),r()),a},a.count=function(e){if(!arguments.length)return l.count;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return e!==l.count&&(l.count=Math.floor(e),n(),r()),a},a.bins=function(){return c},a.itemCount=function(){return s},a.clearBin=function(e){if(e>=0&&e<c.length){var t=o.countBin(c[e]);return s-=t,c[e][1]=o.createSeed(),t}return 0},a(e),a}var l={donut:function(){
// Chart create/init method
function e(e){}/**
	 * Private functions
	 */
function n(){/*
		 * Join the data
		 */
var e=m.gChart.selectAll("path.arc").data(v.pie(p),function(e,t){return g.key(e.data,t)}),n=e.enter().append("path").attr("class","arc").on("mouseover",g.mouseover).on("mouseout",g.mouseout).on("click",g.click).each(function(e){this._current={startAngle:0,endAngle:0}}).merge(e);n.transition().duration(s).attrTween("d",function(e){var n=t.interpolate(this._current,e);return this._current=n(0),function(e){return v.arc(n(e))}}),n.attr("key",function(e,t){return g.key(e.data,t)}).attr("fill",function(e,t){return h.color(g.key(e.data,t))}),/*
		 * Exit
		 */
e.exit().remove()}function r(){var e=f.markSize+f.markMargin;
// Only option is 'center' for now
if("center"===f.position){
// The center position of the chart
var t=o.left+i,n=o.top+i;return"translate("+(t-(null==m.gLegend._maxWidth?0:m.gLegend._maxWidth)/2)+","+(n-(e*p.length+f.markMargin)/2)+")"}}function u(){/*
		 * Join the data
		 */
var e=m.gLegend.selectAll("g.entry").data(p,g.key),t=e.enter().append("g").attr("class","entry").attr("transform",function(e,t){return"translate(0, "+t*(f.markSize+f.markMargin)+")"}).on("mouseover",g.mouseover).on("mouseout",g.mouseout).on("click",g.click),n=t.append("rect").attr("width",f.markSize).attr("height",f.markSize);/*
		 * Enter + Update
		 */
t.append("text").attr("x",f.markSize+f.markMargin).attr("y",f.markSize-f.labelOffset).merge(e.select("text")).text(g.label),n.merge(e.select("rect")).style("fill",function(e,t){return h.color(g.key(e,t))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
t.merge(e).each(function(e,t){
// Reset
m.gLegend._maxWidth=0===t?this.getBBox().width:Math.max(this.getBBox().width,m.gLegend._maxWidth)}),
// Reassert the legend position
m.gLegend.attr("transform",r()),/*
		 * Exit
		 */
e.exit().remove()}
// Chart height/width
var i,a=400,l=400,o={top:2,bottom:2,right:2,left:2},c=.7,s=500,f={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},d=t.dispatch("mouseover","mouseout","click"),g={getEventElement:function(e,t){return null!=e&&null!=e.data?e.data:e},updateActiveElement:function(e,t){var n=m.gLegend.selectAll("g.entry"),r=m.gChart.selectAll("path.arc");if(null!=e){
// Set the highlight on the row
var u=g.key(e,t);n.classed("active",function(e,t){return g.key(e,t)==u}),r.classed("active",function(e,t){return g.key(e.data,t)==u})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(e,t){e=g.getEventElement(e,t),g.updateActiveElement(e,t),d.call("mouseover",this,e,t)},mouseout:function(e,t){e=g.getEventElement(e,t),g.updateActiveElement(),d.call("mouseout",this,e,t)},click:function(e,t){e=g.getEventElement(e,t),d.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},h={color:t.scaleOrdinal(t.schemeCategory10)},v={arc:t.arc().padAngle(.01),pie:t.pie().value(function(e,t){return g.value(e,t)}).sort(null)},m={div:void 0,svg:void 0,gChart:void 0,legend:void 0},p=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return m.div=t.append("div").attr("class","sentio donut"),m.svg=m.div.append("svg"),m.gChart=m.svg.append("g").attr("class","chart"),m.gLegend=m.svg.append("g").attr("class","legend"),e.resize(),e},e.data=function(t){return arguments.length?(p=null!=t?t:[],e):p},e.resize=function(){var t=a-o.right-o.left,n=l-o.top-o.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return i=Math.min(n,t)/2,m.svg.attr("width",a).attr("height",l),m.gChart.attr("transform","translate("+(o.left+i)+","+(o.top+i)+")"),v.arc.innerRadius(i*c).outerRadius(i),m.gLegend.attr("transform",r()),e},e.redraw=function(){return n(),f.enabled&&u(),e},e.width=function(t){return arguments.length?(a=t,e):a},e.height=function(t){return arguments.length?(l=t,e):l},e.innerRadiusRatio=function(t){return arguments.length?(c=t,e):c},e.duration=function(t){return arguments.length?(s=t,e):s},e.key=function(t){return arguments.length?(g.key=t,e):g.key},e.value=function(t){return arguments.length?(g.value=t,e):g.value},e.label=function(t){return arguments.length?(g.label=t,e):g.label},e.colorScale=function(t){return arguments.length?(h.color=t,e):h.color},e.dispatch=function(){return d},e.legend=function(t){return arguments.length?(f=t,e):f},e},matrix:function(){
// Chart dimensions
var e=16,u=1,i={top:20,right:2,bottom:2,left:64},a=500,l=t.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),o={updateActiveSeries:function(e,t){var n=d.g.chart.selectAll(".row text");if(null!=e){
// Set the highlight on the row
var r=o.seriesKey(e,t);n.classed("active",function(e,t){return o.seriesKey(e,t)==r})}else
// Now update the style
n.classed("active",!1)},rowMouseover:function(e,t){o.updateActiveSeries(e,t),l.call("rowMouseover",this,e,t)},rowMouseout:function(e,t){o.updateActiveSeries(),l.call("rowMouseout",this,e,t)},rowClick:function(e,t){l.call("rowClick",this,e,t)},cellMouseover:function(e,t){l.call("cellMouseover",this,e,t)},cellMouseout:function(e,t){l.call("cellMouseout",this,e,t)},cellClick:function(e,t){l.call("cellClick",this,e,t)},seriesKey:function(e){return e.key},seriesLabel:function(e){return e.label},seriesValues:function(e){return e.values},key:function(e){return e.key},value:function(e){return e.value}},c={x:n().getValue(function(e,t){return o.key(e,t)}),value:n().getValue(function(e,t){return o.value(e,t)}),multi:r()},s={x:t.scaleLinear(),y:t.scaleOrdinal(),color:t.scaleLinear().range(["#e7e7e7","#008500"])},f={x:t.axisTop().scale(s.x).tickSizeOuter(0).tickSizeInner(2)},d={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},g=[],h=function(){};return h.init=function(e){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return d.div=e.append("div").attr("class","sentio matrix"),d.svg=d.div.append("svg"),d.g.xAxis=d.svg.append("g").attr("class","x axis"),d.g.chart=d.svg.append("g").attr("class","chart"),h.resize(),h},h.data=function(e){return arguments.length?(g=null!=e?e:[],h):g},h.resize=function(){},h.redraw=function(){
// Determine the number of rows to render
var t=g.length,n=[];t>0&&(n=o.seriesValues(g[0]));var r=n.length,l=u+e,v=r*l+u,m=t*l+u;
// scale the svg to the right size
d.svg.attr("width",v+i.left+i.right).attr("height",m+i.top+i.bottom),
// Configure the scales
s.x.domain(c.x.getExtent(n)).range([0,v-u-l]),s.color.domain(c.multi.values(o.seriesValues).extent(c.value).getExtent(g)),
// Draw the x axis
d.g.xAxis.attr("transform","translate("+(i.left+u+e/2)+","+i.top+")"),d.g.xAxis.call(f.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var p=d.g.chart.selectAll("g.row").data(g,o.seriesKey),x=p.enter().append("g");x.style("opacity","0.1").attr("class","row").attr("transform",function(e,t){return"translate("+i.left+","+(i.top+l*t)+")"}).on("mouseover",o.rowMouseover).on("mouseout",o.rowMouseout).on("click",o.rowClick),
// Also must append the label of the row
x.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",u+e/2).attr("dy",".32em"),
// Also must append a line
x.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",u+e/2).attr("y2",u+e/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var y=x.merge(p);y.transition().duration(a).style("opacity","1").attr("transform",function(e,t){return"translate("+i.left+","+(i.top+l*t)+")"}),
// Update the series labels in case they changed
y.select("text.series.label").text(o.seriesLabel),/*
		 * Row Exit
		 */
p.exit().transition().duration(a).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var b=y.selectAll("rect.cell").data(o.seriesValues,o.key);/*
		 * Cell Remove
		 */
return b.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(e,t){return s.color(o.value(e,t))}).attr("x",function(e,t){return s.x(o.key(e,t))+u}).attr("y",u).attr("height",e).attr("width",e).on("mouseover",o.cellMouseover).on("mouseout",o.cellMouseout).on("click",o.cellClick).merge(b).transition().duration(a).style("opacity","1").attr("x",function(e,t){return s.x(o.key(e,t))+u}).style("fill",function(e,t){return s.color(o.value(e,t))}),b.exit().transition().duration(a).attr("width",0).style("opacity","0.1").remove(),h},h.cellSize=function(t){return arguments.length?(e=t,h):e},h.cellMargin=function(e){return arguments.length?(u=e,h):u},h.margin=function(e){return arguments.length?(i=e,h):i},h.duration=function(e){return arguments.length?(a=e,h):a},h.seriesKey=function(e){return arguments.length?(o.seriesKey=e,h):o.seriesKey},h.seriesLabel=function(e){return arguments.length?(o.seriesLabel=e,h):o.seriesLabel},h.seriesValues=function(e){return arguments.length?(o.seriesValues=e,h):o.seriesValues},h.key=function(e){return arguments.length?(o.key=e,h):o.key},h.value=function(e){return arguments.length?(o.value=e,h):o.value},h.colorScale=function(e){return arguments.length?(s.color=e,h):s.color},h.xScale=function(e){return arguments.length?(s.xScale=e,f.x.scale(e),h):s.xScale},h.yScale=function(e){return arguments.length?(s.yScale=e,h):s.yScale},h.xExtent=function(e){return arguments.length?(c.x=e,c.x.getValue(function(t,n){return e(t,n)}),h):c.x},h.valueExtent=function(e){return arguments.length?(c.value=e,c.value.getValue(function(t,n){return e(t,n)}),h):c.value},h.dispatch=function(){return l},h},realtimeTimeline:function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function e(){
// If not running, let the loop die
r&&(l.redraw(),
// Schedule the next update
u=window.setTimeout(e,a>0?1e3/a:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var t=0,n=6e4,r=!1,u=null,a=32,l=i();l.yExtent().filter(function(e){var t=l.xValue()(e),n=l.xExtent().getExtent();return t<n[1]&&t>n[0]});/*
	 * Redraw the graphic
	 */
var o=l.redraw;return l.redraw=function(){
// Update the x domain (to the latest time window)
var e=new Date;return l.xExtent().overrideValue([e-t-n,e-t]),o(),l},l.start=function(){if(!r)return r=!0,e(),l},l.stop=function(){return r=!1,null!=u&&window.clearTimeout(u),l},l.restart=function(){return l.stop(),l.start(),l},l.interval=function(e){return arguments.length?(n=e,l):n},l.delay=function(e){return arguments.length?(t=e,l):t},l.fps=function(e){return arguments.length?(a=e,r&&l.restart(),l):a},l},timeline:i,verticalBars:function(){
// Chart create/init method
function e(e){}
// Layout properties
var r=100,u=24,i=2,a=500,l=t.dispatch("mouseover","mouseout","click"),o={mouseover:function(e,t){l.call("mouseover",this,e,t)},mouseout:function(e,t){l.call("mouseout",this,e,t)},click:function(e,t){l.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},c={x:t.scaleLinear(),y:t.scaleLinear()},s={width:n({defaultValue:[0,10],getValue:function(e,t){return o.value(e,t)}})},f={div:void 0},d=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
return f.div=t.append("div").attr("class","sentio bars-vertical"),e.resize(),e},e.data=function(t){return arguments.length?(d=null!=t?t:[],e):d},e.resize=function(){
// Set up the x scale (y is fixed)
return c.x.range([0,r]),e},e.redraw=function(){
// Update the x domain
c.x.domain(s.width.getExtent(d)),
// Update the y domain (based on configuration and data)
c.y.domain([0,d.length]),c.y.range([0,(u+i)*d.length]);
// Data Join
var t=f.div.selectAll("div.bar").data(d,o.key),n=t.enter().append("div").attr("class","bar").style("top",c.y.range()[1]-u+"px").style("height",u+"px").on("mouseover",o.mouseover).on("mouseout",o.mouseout).on("click",o.click).style("opacity","0.01"),r=n.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return n.merge(t).transition().duration(a).style("opacity","1").style("width",function(e,t){return c.x(o.value(e,t))+"px"}).style("top",function(e,t){return c.y(t)+"px"}).style("left","0px"),r.merge(t.select("div.bar-label")).html(o.label).style("max-width",c.x.range()[1]-10+"px"),t.exit().transition().duration(a).style("opacity","0.01").style("top",c.y.range()[1]-u+"px").remove(),f.div.style("height",c.y.range()[1]+"px"),e},e.width=function(t){return arguments.length?(r=t,e):r},e.barHeight=function(t){return arguments.length?(u=t,e):u},e.barPadding=function(t){return arguments.length?(i=t,e):i},e.key=function(t){return arguments.length?(o.key=t,e):o.key},e.value=function(t){return arguments.length?(o.value=t,e):o.value},e.label=function(t){return arguments.length?(o.label=t,e):o.label},e.widthExtent=function(t){return arguments.length?(s.width=t,s.width.getValue(function(e,t){return o.value(e,t)}),e):s.width},e.dispatch=function(t){return arguments.length?e:l},e.duration=function(t){return arguments.length?(a=t,e):a},e}},o={realtimeBins:/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(e){/**
	 * Private Functions
	 */
function t(){
// Assume the hwm is now plus two binSize
var e=Date.now()+2*l.size();
// Trunc the hwm down to a round value based on the binSize
return(e=Math.floor(e/l.size())*l.size())-l.size()*l.count()}function n(){!0===o&&(
// need to update the lwm
l.lwm(t()),window.setTimeout(n,l.size()))}function r(){o||(
// Start the update loop
o=!0,n())}function u(){
// Setting running to false will stop the update loop
o=!1}
// create/init method
function i(e){if(null==e||null==e.binCount||null==e.binSize)throw new Error("You must provide an initial binSize and binCount");c.binSize=Number(e.binSize),c.binCount=Number(e.binCount),null!=e.delay&&(c.delay=Number(e.delay)),(l=a({size:c.binSize,count:c.binCount+2,lwm:0})).lwm(t()),r()}/**
	 * Private variables
	 */
var l,o,c={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return i.model=function(){return l},i.bins=function(){return l.bins()},i.start=function(){return r(),i},i.stop=function(){return u(),i},i.running=function(){return o},i.add=function(e){return l.add(e),i},i.clear=function(){return l.clear(),i},i.binSize=function(e){if(!arguments.length)return c.binSize;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");return c.binSize=e,l.size(e),l.lwm(t()),i},i.binCount=function(e){if(!arguments.length)return c.binCount;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");return c.binCount=e,l.count(e+2),l.lwm(t()),i},i(e),i},timelineBrush:u},c={bins:a,extent:n,multiExtent:r};e.chart=l,e.controller=o,e.model=c,Object.defineProperty(e,"__esModule",{value:!0})});