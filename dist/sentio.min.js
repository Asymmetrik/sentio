/*! @asymmetrik/sentio - 4.1.0 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("d3")):"function"==typeof define&&define.amd?define(["exports","d3"],t):t(e.sentio={},e.d3)}(this,function(e,t){"use strict";function n(e){/**
	 * Private Functions
	 */
function t(e){if(null==e||2!==e.length||isNaN(e[0])||isNaN(e[1])||e[0]>=e[1])throw new Error("Default extent must be a two element ordered array of numbers");i.defaultValue=e}function n(e){if(null!=e&&2!==e.length)throw new Error("Extent override must be a two element array or null/undefined");i.overrideValue=e}function r(e){if(null!=e&&2!==e.length)throw new Error("Extent padding must be a two element array or null/undefined");i.paddingValue=e}function u(e){if("function"!=typeof e)throw new Error("Value getter must be a function");o.getValue=e}function a(e){if("function"!=typeof e)throw new Error("Filter must be a function");o.filter=e}/*
	 * Constructor/initialization method
	 */
function l(e){null!=e&&(null!=e.defaultValue&&t(e.defaultValue),null!=e.overrideValue&&n(e.overrideValue),null!=e.paddingValue&&r(e.paddingValue),null!=e.getValue&&u(e.getValue),null!=e.filter&&a(e.filter))}/**
	 * Private variables
	 */
// Configuration
var i={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(e){return e},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return l.defaultValue=function(e){return arguments.length?(t(e),l):i.defaultValue},l.overrideValue=function(e){return arguments.length?(n(e),l):i.overrideValue},l.paddingValue=function(e){return arguments.length?(r(e),l):i.paddingValue},l.getValue=function(e){return arguments.length?(u(e),l):o.getValue},l.filter=function(e){return arguments.length?(a(e),l):o.filter},l.getExtent=function(e){var t,n=i.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
t=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=e&&
// Iterate over each element of the data
e.forEach(function(e,n){
// If the element passes the filter, then update the extent
if(o.filter(e,n)){r=!0;var u=o.getValue(e,n);t[0]=Math.min(t[0],u),t[1]=Math.max(t[1],u)}}),
// If we didn't find any data, use the default values
r||(t=i.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(t[0]=n[0]),null!=n[1]&&(t[1]=n[1]));var u=i.paddingValue;null==u||null==u[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
t[0]-=i.paddingValue[0]),null==u||null==u[1]||null!=n&&null!=n[1]||(t[1]+=i.paddingValue[1])}else
// Since the override is fully specified, use it
t=n;
// Verify that the extent is valid
return t[0]>t[1]&&(t[1]=t[0]),t},l(e),l}function r(e){/**
	 * Private Functions
	 */
function t(e){a=e}/*
	 * Constructor/initialization method
	 */
function r(e){null!=e&&null!=e.extent&&t(e.extent)}/**
	 * Private variables
	 */
var u={values:function(e){return e.values}},a=n();/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return r.extent=function(e){return arguments.length?(t(e),r):a},r.values=function(e){return arguments.length?(u.values=e,r):u.values},r.getExtent=function(e){var t;
// In case there was no data
return e.forEach(function(e,n){var r=a.getExtent(u.values(e,n));null==t?t=r:(t[0]=Math.min(t[0],r[0]),t[1]=Math.max(t[1],r[1]))}),null==t&&(t=a.getExtent([])),t},r(e),r}function u(e){/**
	 * Private Functions
	 */
function n(e){
// Should probably fire event for new brush state
h=e}function r(){return h&&null!=s}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function u(e){return null!=e&&Array.isArray(e)&&(e=e.map(function(e){return+e})),e}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function a(e){return(!Array.isArray(e)||2!=e.length||isNaN(e[0])||isNaN(e[1]))&&(e=void 0),e}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function l(e){return function(n){var r=null!=t.event.selection?u(t.event.selection.map(f.invert)):void 0,a=g,l=!((r===a||null!=r&&null!=a&&r[0]===a[0]&&r[1]===a[1])&&v);
// Store the new selection only on the 'end' event
"end"===e&&(
// Reset the selection
g=r,
// Reset the flag
v=!1),
// Suppress event if it's duplicate and programmatic
l&&d.apply(e,this,n)}}function i(e){var n=void 0;return h&&null!=e&&null!=f&&(n=null!=(n=t.brushSelection(e))&&Array.isArray(n)?u(n.map(f.invert)):void 0),n}function o(e,t){var n=null==(t=a(t))||t[0]>=t[1];
// either clear the filter or move it
v=!0,n?s.move(e,void 0):s.move(e,t.map(f))}function c(e){if(null==e)throw new Error("Must provide a brush and a scale");if(null==e.brush)throw new Error("Must provide a brush");if((s=e.brush).on("brush",l("brush")).on("start",l("start")).on("end",l("end")),null==e.scale)throw new Error("Must provide a scale");f=e.scale,null!=e.enabled&&n(e.enabled)}/**
	 * Private variables
	 */
// The brush object
var s,f,d=t.dispatch("brush","start","end"),g=void 0,h=!1,v=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return c.scale=function(e){return arguments.length?(f=e,c):f},c.dispatch=function(){return d},c.brush=function(){return s},c.enabled=function(e){return arguments.length?(n(e),c):r()},c.getSelection=function(e){return i(e)},c.setSelection=function(e,t){return o(e,t)},c(e),c}function a(){/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function e(){
// Try to get the node from the brush group selection
var e=null!=w.g.brush?w.g.brush.node():null;
// Get the current brush selection
return z.getSelection(e)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function a(e){z.setSelection(w.g.brush,e)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in filter change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function l(e){
// If there was no previous extent, then there is no brush to update
if(null!=e){
// Derive the overall plot extent from the collection of series
var t=x.extent(p.x).getExtent(A);a(null!=t&&Array.isArray(t)&&2==t.length?[Math.max(t[0],e[0]),Math.min(t[1],e[1])]:void 0)}w.g.brush.style("display",z.enabled()?"unset":"none").call(z.brush())}
// Chart create/init method
function i(){}function o(){null!=b.x&&w.g.xAxis.call(b.x),null!=b.y&&w.g.yAxis.call(b.y)}function c(){
// Join
var e=w.g.plots.selectAll(".plot").data(A,v.seriesKey),t=e.enter().append("g").attr("class","plot"),n=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" line"}),r=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" area"}),u=e.select(".line"),a=e.select(".area");
// Enter + Update
n.merge(u).datum(v.seriesValues).attr("d",k),r.merge(a).datum(v.seriesValues).attr("d",V.y0(y.y.range()[0])),e.exit().remove()}function s(){
// Join
var e=w.g.markers.selectAll(".marker").data(S.values,v.markerValueX),t=e.enter().append("g").attr("class","marker").on("mouseover",function(e,t){E.call("markerMouseover",this,e,t)}).on("mouseout",function(e,t){E.call("markerMouseout",this,e,t)}).on("click",function(e,t){E.call("markerClick",this,e,t)}),n=t.append("line"),r=t.append("text");n.attr("y1",function(e){return y.y.range()[1]}).attr("y2",function(e){return y.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(v.markerValueLabel);
// Enter + Update
var u=e.select("line"),a=e.select("text");n.merge(u).attr("x1",function(e,t){return y.x(v.markerValueX(e,t))}).attr("x2",function(e,t){return y.x(v.markerValueX(e))}),r.merge(a).attr("x",function(e,t){return y.x(v.markerValueX(e))}),
// Exit
e.exit().remove()}var f="timeline_line_"+Date.now(),d={top:10,right:10,bottom:20,left:40},g=100,h=600,v={valueX:function(e){return e[0]},valueY:function(e){return e[1]},markerValueX:function(e){return e[0]},markerLabel:function(e){return e[1]},seriesKey:function(e){return e.key},seriesValues:function(e){return e.values},seriesLabel:function(e){return e.label}},m=Date.now(),p={x:n({defaultValue:[m-3e5,m],getValue:function(e,t){return v.valueX(e,t)}}),y:n({getValue:function(e,t){return v.valueY(e,t)}})},x=r().values(function(e,t){return v.seriesValues(e,t)}),y={x:t.scaleTime(),y:t.scaleLinear()},b={x:t.axisBottom().scale(y.x),y:t.axisLeft().scale(y.y).ticks(3)},w={svg:void 0,g:{container:void 0,plots:void 0,xAxis:void 0,yAxis:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},k=t.line();k.x(function(e,t){return y.x(v.valueX(e,t))}),k.y(function(e,t){return y.y(v.valueY(e,t))});
// Area generator for the plot
var V=t.area();V.x(function(e,t){return y.x(v.valueX(e,t))}),V.y1(function(e,t){return y.y(v.valueY(e,t))});
// Brush Management
var z=u({brush:t.brushX(),scale:y.x});z.dispatch().on("end",function(){E.call("filterend",this,e())}).on("start",function(){E.call("filterstart",this,e())}).on("brush",function(){E.call("filter",this,e())});
// The dispatch object and all events
var E=t.dispatch("filter","filterstart","filterend","markerClick","markerMouseover","markerMouseout"),A=[],S={values:[]};/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return i.init=function(e){
// Create a container div
// Create the SVG element
// Add the defs and add the clip path definition
// Append a container for everything
// Append the path group (which will have the clip path and the line path
// Add the filter brush element
// Append a group for the markers
// Append groups for the axes
return w.div=e.append("div").attr("class","sentio timeline"),w.svg=w.div.append("svg"),w.plotClipPath=w.svg.append("defs").append("clipPath").attr("id","plot_"+f).append("rect"),w.markerClipPath=w.svg.append("defs").append("clipPath").attr("id","marker_"+f).append("rect"),w.g.container=w.svg.append("g"),w.g.plots=w.g.container.append("g").attr("class","plots").attr("clip-path","url(#plot_"+f+")"),w.g.brush=w.g.container.append("g").attr("class","x brush").attr("clip-path","url(#marker_"+f+")"),w.g.markers=w.g.container.append("g").attr("class","markers").attr("clip-path","url(#marker_"+f+")"),w.g.xAxis=w.g.container.append("g").attr("class","x axis"),w.g.yAxis=w.g.container.append("g").attr("class","y axis"),i.resize(),i},i.data=function(e){return arguments.length?(A=null!=e?e:[],i):A},i.markers=function(e){return arguments.length?(S.values=null!=e?e:[],i):S.values},i.resize=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Set up the scales
// Append the clip path
// Now update the size of the svg pane
// Update the positions of the axes
// update the margins on the main draw group
// Update the size of the brush
return y.x.range([0,Math.max(0,h-d.left-d.right)]),y.y.range([Math.max(0,g-d.top-d.bottom),0]),w.plotClipPath.attr("transform","translate(0, -"+d.top+")").attr("width",Math.max(0,h-d.left-d.right)).attr("height",Math.max(0,g-d.bottom)),w.markerClipPath.attr("transform","translate(0, -"+d.top+")").attr("width",Math.max(0,h-d.left-d.right)).attr("height",Math.max(0,g-d.bottom)),w.svg.attr("width",h).attr("height",g),w.g.xAxis.attr("transform","translate(0,"+y.y.range()[0]+")"),w.g.yAxis.attr("class","y axis"),w.g.container.attr("transform","translate("+d.left+","+d.top+")"),w.g.brush.selectAll("rect").attr("y",0).attr("x",0).attr("height",h-d.left-d.right).attr("height",g-d.top-d.bottom+4),z.brush().extent([[0,0],[h-d.left-d.right,g-d.top-d.bottom]]),l(t),i},i.redraw=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return y.x.domain(x.extent(p.x).getExtent(A)),y.y.domain(x.extent(p.y).getExtent(A)),o(),c(),s(),l(t),i},i.width=function(e){return arguments.length?(h=e,i):h},i.height=function(e){return arguments.length?(g=e,i):g},i.margin=function(e){return arguments.length?(d=e,i):d},i.curve=function(e){return arguments.length?(k.curve(e),V.curve(e),i):k.curve()},i.xAxis=function(e){return arguments.length?(b.x=e,i):b.x},i.yAxis=function(e){return arguments.length?(b.y=e,i):b.y},i.xScale=function(e){return arguments.length?(y.x=e,null!=b.x&&b.x.scale(e),null!=z&&z.scale(e),i):y.x},i.yScale=function(e){return arguments.length?(y.y=e,null!=b.y&&b.y.scale(e),i):y.y},i.xValue=function(e){return arguments.length?(v.valueX=e,i):v.valueX},i.yValue=function(e){return arguments.length?(v.valueY=e,i):v.valueY},i.yExtent=function(e){return arguments.length?(p.y=e,i):p.y},i.xExtent=function(e){return arguments.length?(p.x=e,i):p.x},i.seriesKey=function(e){return arguments.length?(v.seriesKey=e,i):v.seriesKey},i.seriesLabel=function(e){return arguments.length?(v.seriesLabel=e,i):v.seriesLabel},i.seriesValues=function(e){return arguments.length?(v.seriesValues=e,i):v.seriesValues},i.markerXValue=function(e){return arguments.length?(v.markerValueX=e,i):v.markerValueX},i.markerLabel=function(e){return arguments.length?(v.markerValueLabel=e,i):v.markerValueLabel},i.dispatch=function(e){return arguments.length?i:E},i.filter=function(e){return arguments.length?(z.enabled(e),i):z.enabled()},i.setFilter=function(e){return a(e),i},i.getFilter=function(){return e()},i}function l(e){/**
	 * Private Functions
	 */
// Get the index given the value
function t(e){return null==i.size||null==i.lwm?0:Math.floor((e-i.lwm)/i.size)}function n(){i.hwm=i.lwm+i.count*i.size}function r(){
// drop stuff below the lwm
for(var e,t=s;c.length>0&&c[0][0]<i.lwm;)e=c.shift(),s-=o.countBin(e);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=i.hwm;)e=c.pop(),s-=o.countBin(e);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([i.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-i.size;n>=i.lwm;n-=i.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<i.hwm-i.size;)c.push([c[c.length-1][0]+i.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(l,c,s,t)}function u(e){var n=s;e.forEach(function(e,n){var r=t(o.getKey(e,n));if(r>=0&&r<c.length){var u=o.getValue(e,n),a=o.countBin(c[r]);o.updateBin.call(l,c[r],u,n),s+=o.countBin(c[r])-a}}),o.afterAdd&&o.afterAdd.call(l,c,s,n)}function a(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function l(e){if(null==e||null==e.size||null==e.count||null==e.lwm)throw new Error("You must provide an initial size, count, and lwm");i.size=Number(e.size),i.count=Number(e.count),i.lwm=Number(e.lwm),null!=e.createSeed&&(o.createSeed=e.createSeed),null!=e.getKey&&(o.getKey=e.getKey),null!=e.getValue&&(o.getValue=e.getValue),null!=e.updateBin&&(o.updateBin=e.updateBin),null!=e.countBin&&(o.countBin=e.countBin),null!=e.afterAdd&&(o.afterAdd=e.afterAdd),null!=e.afterUpdate&&(o.afterUpdate=e.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var i={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(e){return e},
// The default value function
getValue:function(e){return e},
// The default function for updating a bin given a new value
updateBin:function(e,t){e[1].push(t)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(e){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof e[1]?e[1]:e[1].hasOwnProperty("length")?e[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(e,t,n){},
// The default function to be called after the bins are updated
afterUpdate:function(e,t,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return l.set=function(e){return a(),r(),u(e),l},l.clear=function(){return a(),r(),l},l.add=function(e){return u(e),l},l.lwm=function(e){if(!arguments.length)return i.lwm;var t=i.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return i.lwm=Number(e),n(),(t-i.lwm)%i.size!=0&&a(),r(),l},l.hwm=function(){return i.hwm},l.getKey=function(e){return arguments.length?(o.getKey=e,a(),r(),l):o.getKey},l.getValue=function(e){return arguments.length?(o.getValue=e,a(),r(),l):o.getValue},l.updateBin=function(e){return arguments.length?(o.updateBin=e,a(),r(),l):o.updateBin},l.createSeed=function(e){return arguments.length?(o.createSeed=e,a(),r(),l):o.createSeed},l.countBin=function(e){return arguments.length?(o.countBin=e,a(),r(),l):o.countBin},l.afterAdd=function(e){return arguments.length?(o.afterAdd=e,l):o.afterAdd},l.afterUpdate=function(e){return arguments.length?(o.afterUpdate=e,l):o.afterUpdate},l.size=function(e){if(!arguments.length)return i.size;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return e!==i.size&&(i.size=e,n(),a(),r()),l},l.count=function(e){if(!arguments.length)return i.count;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return e!==i.count&&(i.count=Math.floor(e),n(),r()),l},l.bins=function(){return c},l.itemCount=function(){return s},l.clearBin=function(e){if(e>=0&&e<c.length){var t=o.countBin(c[e]);return s-=t,c[e][1]=o.createSeed(),t}return 0},l(e),l}var i={donut:function(){
// Chart create/init method
function e(e){}/**
	 * Private functions
	 */
function n(){/*
		 * Join the data
		 */
var e=m.gChart.selectAll("path.arc").data(v.pie(p),function(e,t){return g.key(e.data,t)}),n=e.enter().append("path").attr("class","arc").on("mouseover",g.mouseover).on("mouseout",g.mouseout).on("click",g.click).each(function(e){this._current={startAngle:0,endAngle:0}}).merge(e);n.transition().duration(s).attrTween("d",function(e){var n=t.interpolate(this._current,e);return this._current=n(0),function(e){return v.arc(n(e))}}),n.attr("key",function(e,t){return g.key(e.data,t)}).attr("fill",function(e,t){return h.color(g.key(e.data,t))}),/*
		 * Exit
		 */
e.exit().remove()}function r(){var e=f.markSize+f.markMargin;
// Only option is 'center' for now
if("center"===f.position){
// The center position of the chart
var t=o.left+a,n=o.top+a;return"translate("+(t-(null==m.gLegend._maxWidth?0:m.gLegend._maxWidth)/2)+","+(n-(e*p.length+f.markMargin)/2)+")"}}function u(){/*
		 * Join the data
		 */
var e=m.gLegend.selectAll("g.entry").data(p,g.key),t=e.enter().append("g").attr("class","entry").attr("transform",function(e,t){return"translate(0, "+t*(f.markSize+f.markMargin)+")"}).on("mouseover",g.mouseover).on("mouseout",g.mouseout).on("click",g.click),n=t.append("rect").attr("width",f.markSize).attr("height",f.markSize);/*
		 * Enter + Update
		 */
t.append("text").attr("x",f.markSize+f.markMargin).attr("y",f.markSize-f.labelOffset).merge(e.select("text")).text(g.label),n.merge(e.select("rect")).style("fill",function(e,t){return h.color(g.key(e,t))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
t.merge(e).each(function(e,t){
// Reset
m.gLegend._maxWidth=0===t?this.getBBox().width:Math.max(this.getBBox().width,m.gLegend._maxWidth)}),
// Reassert the legend position
m.gLegend.attr("transform",r()),/*
		 * Exit
		 */
e.exit().remove()}
// Chart height/width
var a,l=400,i=400,o={top:2,bottom:2,right:2,left:2},c=.7,s=500,f={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},d=t.dispatch("mouseover","mouseout","click"),g={getEventElement:function(e,t){return null!=e&&null!=e.data?e.data:e},updateActiveElement:function(e,t){var n=m.gLegend.selectAll("g.entry"),r=m.gChart.selectAll("path.arc");if(null!=e){
// Set the highlight on the row
var u=g.key(e,t);n.classed("active",function(e,t){return g.key(e,t)==u}),r.classed("active",function(e,t){return g.key(e.data,t)==u})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(e,t){e=g.getEventElement(e,t),g.updateActiveElement(e,t),d.call("mouseover",this,e,t)},mouseout:function(e,t){e=g.getEventElement(e,t),g.updateActiveElement(),d.call("mouseout",this,e,t)},click:function(e,t){e=g.getEventElement(e,t),d.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},h={color:t.scaleOrdinal(t.schemeCategory10)},v={arc:t.arc().padAngle(.01),pie:t.pie().value(function(e,t){return g.value(e,t)}).sort(null)},m={div:void 0,svg:void 0,gChart:void 0,legend:void 0},p=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return m.div=t.append("div").attr("class","sentio donut"),m.svg=m.div.append("svg"),m.gChart=m.svg.append("g").attr("class","chart"),m.gLegend=m.svg.append("g").attr("class","legend"),e.resize(),e},e.data=function(t){return arguments.length?(p=null!=t?t:[],e):p},e.resize=function(){var t=l-o.right-o.left,n=i-o.top-o.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return a=Math.min(n,t)/2,m.svg.attr("width",l).attr("height",i),m.gChart.attr("transform","translate("+(o.left+a)+","+(o.top+a)+")"),v.arc.innerRadius(a*c).outerRadius(a),m.gLegend.attr("transform",r()),e},e.redraw=function(){return n(),f.enabled&&u(),e},e.width=function(t){return arguments.length?(l=t,e):l},e.height=function(t){return arguments.length?(i=t,e):i},e.innerRadiusRatio=function(t){return arguments.length?(c=t,e):c},e.duration=function(t){return arguments.length?(s=t,e):s},e.key=function(t){return arguments.length?(g.key=t,e):g.key},e.value=function(t){return arguments.length?(g.value=t,e):g.value},e.label=function(t){return arguments.length?(g.label=t,e):g.label},e.colorScale=function(t){return arguments.length?(h.color=t,e):h.color},e.dispatch=function(){return d},e.legend=function(t){return arguments.length?(f=t,e):f},e},matrix:function(){
// Chart dimensions
var e=16,u=1,a={top:20,right:2,bottom:2,left:64},l=500,i=t.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),o={updateActiveSeries:function(e,t){var n=d.g.chart.selectAll(".row text");if(null!=e){
// Set the highlight on the row
var r=o.seriesKey(e,t);n.classed("active",function(e,t){return o.seriesKey(e,t)==r})}else
// Now update the style
n.classed("active",!1)},rowMouseover:function(e,t){o.updateActiveSeries(e,t),i.call("rowMouseover",this,e,t)},rowMouseout:function(e,t){o.updateActiveSeries(),i.call("rowMouseout",this,e,t)},rowClick:function(e,t){i.call("rowClick",this,e,t)},cellMouseover:function(e,t){i.call("cellMouseover",this,e,t)},cellMouseout:function(e,t){i.call("cellMouseout",this,e,t)},cellClick:function(e,t){i.call("cellClick",this,e,t)},seriesKey:function(e){return e.key},seriesLabel:function(e){return e.label},seriesValues:function(e){return e.values},key:function(e){return e.key},value:function(e){return e.value}},c={x:n().getValue(function(e,t){return o.key(e,t)}),value:n().getValue(function(e,t){return o.value(e,t)}),multi:r()},s={x:t.scaleLinear(),y:t.scaleOrdinal(),color:t.scaleLinear().range(["#e7e7e7","#008500"])},f={x:t.axisTop().scale(s.x).tickSizeOuter(0).tickSizeInner(2)},d={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},g=[],h=function(){};return h.init=function(e){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return d.div=e.append("div").attr("class","sentio matrix"),d.svg=d.div.append("svg"),d.g.xAxis=d.svg.append("g").attr("class","x axis"),d.g.chart=d.svg.append("g").attr("class","chart"),h.resize(),h},h.data=function(e){return arguments.length?(g=null!=e?e:[],h):g},h.resize=function(){},h.redraw=function(){
// Determine the number of rows to render
var t=g.length,n=[];t>0&&(n=o.seriesValues(g[0]));var r=n.length,i=u+e,v=r*i+u,m=t*i+u;
// scale the svg to the right size
d.svg.attr("width",v+a.left+a.right).attr("height",m+a.top+a.bottom),
// Configure the scales
s.x.domain(c.x.getExtent(n)).range([0,v-u-i]),s.color.domain(c.multi.values(o.seriesValues).extent(c.value).getExtent(g)),
// Draw the x axis
d.g.xAxis.attr("transform","translate("+(a.left+u+e/2)+","+a.top+")"),d.g.xAxis.call(f.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var p=d.g.chart.selectAll("g.row").data(g,o.seriesKey),x=p.enter().append("g");x.style("opacity","0.1").attr("class","row").attr("transform",function(e,t){return"translate("+a.left+","+(a.top+i*t)+")"}).on("mouseover",o.rowMouseover).on("mouseout",o.rowMouseout).on("click",o.rowClick),
// Also must append the label of the row
x.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",u+e/2).attr("dy",".32em"),
// Also must append a line
x.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",u+e/2).attr("y2",u+e/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var y=x.merge(p);y.transition().duration(l).style("opacity","1").attr("transform",function(e,t){return"translate("+a.left+","+(a.top+i*t)+")"}),
// Update the series labels in case they changed
y.select("text.series.label").text(o.seriesLabel),/*
		 * Row Exit
		 */
p.exit().transition().duration(l).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var b=y.selectAll("rect.cell").data(o.seriesValues,o.key);/*
		 * Cell Remove
		 */
return b.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(e,t){return s.color(o.value(e,t))}).attr("x",function(e,t){return s.x(o.key(e,t))+u}).attr("y",u).attr("height",e).attr("width",e).on("mouseover",o.cellMouseover).on("mouseout",o.cellMouseout).on("click",o.cellClick).merge(b).transition().duration(l).style("opacity","1").attr("x",function(e,t){return s.x(o.key(e,t))+u}).style("fill",function(e,t){return s.color(o.value(e,t))}),b.exit().transition().duration(l).attr("width",0).style("opacity","0.1").remove(),h},h.cellSize=function(t){return arguments.length?(e=t,h):e},h.cellMargin=function(e){return arguments.length?(u=e,h):u},h.margin=function(e){return arguments.length?(a=e,h):a},h.duration=function(e){return arguments.length?(l=e,h):l},h.seriesKey=function(e){return arguments.length?(o.seriesKey=e,h):o.seriesKey},h.seriesLabel=function(e){return arguments.length?(o.seriesLabel=e,h):o.seriesLabel},h.seriesValues=function(e){return arguments.length?(o.seriesValues=e,h):o.seriesValues},h.key=function(e){return arguments.length?(o.key=e,h):o.key},h.value=function(e){return arguments.length?(o.value=e,h):o.value},h.colorScale=function(e){return arguments.length?(s.color=e,h):s.color},h.xScale=function(e){return arguments.length?(s.xScale=e,f.x.scale(e),h):s.xScale},h.yScale=function(e){return arguments.length?(s.yScale=e,h):s.yScale},h.xExtent=function(e){return arguments.length?(c.x=e,c.x.getValue(function(t,n){return e(t,n)}),h):c.x},h.valueExtent=function(e){return arguments.length?(c.value=e,c.value.getValue(function(t,n){return e(t,n)}),h):c.value},h.dispatch=function(){return i},h},realtimeTimeline:function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function e(){
// If not running, let the loop die
r&&(i.redraw(),
// Schedule the next update
u=window.setTimeout(e,l>0?1e3/l:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var t=0,n=6e4,r=!1,u=null,l=32,i=a();i.yExtent().filter(function(e){var t=i.xValue()(e),n=i.xExtent().getExtent();return t<n[1]&&t>n[0]});/*
	 * Redraw the graphic
	 */
var o=i.redraw;return i.redraw=function(){
// Update the x domain (to the latest time window)
var e=new Date;return i.xExtent().overrideValue([e-t-n,e-t]),o(),i},i.start=function(){if(!r)return r=!0,e(),i},i.stop=function(){return r=!1,null!=u&&window.clearTimeout(u),i},i.restart=function(){return i.stop(),i.start(),i},i.interval=function(e){return arguments.length?(n=e,i):n},i.delay=function(e){return arguments.length?(t=e,i):t},i.fps=function(e){return arguments.length?(l=e,r&&i.restart(),i):l},i},timeline:a,verticalBars:function(){
// Chart create/init method
function e(e){}
// Layout properties
var r=100,u=24,a=2,l=500,i=t.dispatch("mouseover","mouseout","click"),o={mouseover:function(e,t){i.call("mouseover",this,e,t)},mouseout:function(e,t){i.call("mouseout",this,e,t)},click:function(e,t){i.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},c={x:t.scaleLinear(),y:t.scaleLinear()},s={width:n({defaultValue:[0,10],getValue:function(e,t){return o.value(e,t)}})},f={div:void 0},d=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
return f.div=t.append("div").attr("class","sentio bars-vertical"),e.resize(),e},e.data=function(t){return arguments.length?(d=null!=t?t:[],e):d},e.resize=function(){
// Set up the x scale (y is fixed)
return c.x.range([0,r]),e},e.redraw=function(){
// Update the x domain
c.x.domain(s.width.getExtent(d)),
// Update the y domain (based on configuration and data)
c.y.domain([0,d.length]),c.y.range([0,(u+a)*d.length]);
// Data Join
var t=f.div.selectAll("div.bar").data(d,o.key),n=t.enter().append("div").attr("class","bar").style("top",c.y.range()[1]-u+"px").style("height",u+"px").on("mouseover",o.mouseover).on("mouseout",o.mouseout).on("click",o.click).style("opacity","0.01"),r=n.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return n.merge(t).transition().duration(l).style("opacity","1").style("width",function(e,t){return c.x(o.value(e,t))+"px"}).style("top",function(e,t){return c.y(t)+"px"}).style("left","0px"),r.merge(t.select("div.bar-label")).html(o.label).style("max-width",c.x.range()[1]-10+"px"),t.exit().transition().duration(l).style("opacity","0.01").style("top",c.y.range()[1]-u+"px").remove(),f.div.style("height",c.y.range()[1]+"px"),e},e.width=function(t){return arguments.length?(r=t,e):r},e.barHeight=function(t){return arguments.length?(u=t,e):u},e.barPadding=function(t){return arguments.length?(a=t,e):a},e.key=function(t){return arguments.length?(o.key=t,e):o.key},e.value=function(t){return arguments.length?(o.value=t,e):o.value},e.label=function(t){return arguments.length?(o.label=t,e):o.label},e.widthExtent=function(t){return arguments.length?(s.width=t,s.width.getValue(function(e,t){return o.value(e,t)}),e):s.width},e.dispatch=function(t){return arguments.length?e:i},e.duration=function(t){return arguments.length?(l=t,e):l},e}},o={realtimeBins:/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(e){/**
	 * Private Functions
	 */
function t(){
// Assume the hwm is now plus two binSize
var e=Date.now()+2*i.size();
// Trunc the hwm down to a round value based on the binSize
return(e=Math.floor(e/i.size())*i.size())-i.size()*i.count()}function n(){!0===o&&(
// need to update the lwm
i.lwm(t()),window.setTimeout(n,i.size()))}function r(){o||(
// Start the update loop
o=!0,n())}function u(){
// Setting running to false will stop the update loop
o=!1}
// create/init method
function a(e){if(null==e||null==e.binCount||null==e.binSize)throw new Error("You must provide an initial binSize and binCount");c.binSize=Number(e.binSize),c.binCount=Number(e.binCount),null!=e.delay&&(c.delay=Number(e.delay)),(i=l({size:c.binSize,count:c.binCount+2,lwm:0})).lwm(t()),r()}/**
	 * Private variables
	 */
var i,o,c={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return a.model=function(){return i},a.bins=function(){return i.bins()},a.start=function(){return r(),a},a.stop=function(){return u(),a},a.running=function(){return o},a.add=function(e){return i.add(e),a},a.clear=function(){return i.clear(),a},a.binSize=function(e){if(!arguments.length)return c.binSize;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");return c.binSize=e,i.size(e),i.lwm(t()),a},a.binCount=function(e){if(!arguments.length)return c.binCount;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");return c.binCount=e,i.count(e+2),i.lwm(t()),a},a(e),a},timelineBrush:u},c={bins:l,extent:n,multiExtent:r};e.chart=i,e.controller=o,e.model=c,Object.defineProperty(e,"__esModule",{value:!0})});