/*! @asymmetrik/sentio - 5.0.0-alpha.13 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("d3-dispatch"),require("d3-interpolate"),require("d3-scale"),require("d3-shape"),require("d3-axis"),require("d3-brush"),require("d3-voronoi"),require("d3-selection")):"function"==typeof define&&define.amd?define(["exports","d3-dispatch","d3-interpolate","d3-scale","d3-shape","d3-axis","d3-brush","d3-voronoi","d3-selection"],e):e(t.sentio={},t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3)}(this,function(t,e,n,r,i,a,u,l,o){"use strict";function c(t){/**
	 * Private Functions
	 */
function e(t){if(null==t||2!==t.length||isNaN(t[0])||isNaN(t[1])||t[0]>=t[1])throw new Error("Default extent must be a two element ordered array of numbers");l.defaultValue=t}function n(t){if(null!=t&&2!==t.length)throw new Error("Extent override must be a two element array or null/undefined");l.overrideValue=t}function r(t){if(null!=t&&2!==t.length)throw new Error("Extent padding must be a two element array or null/undefined");l.paddingValue=t}function i(t){if("function"!=typeof t)throw new Error("Value getter must be a function");o.getValue=t}function a(t){if("function"!=typeof t)throw new Error("Filter must be a function");o.filter=t}/*
	 * Constructor/initialization method
	 */
function u(t){null!=t&&(null!=t.defaultValue&&e(t.defaultValue),null!=t.overrideValue&&n(t.overrideValue),null!=t.paddingValue&&r(t.paddingValue),null!=t.getValue&&i(t.getValue),null!=t.filter&&a(t.filter))}/**
	 * Private variables
	 */
// Configuration
var l={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(t){return t},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return u.defaultValue=function(t){return arguments.length?(e(t),u):l.defaultValue},u.overrideValue=function(t){return arguments.length?(n(t),u):l.overrideValue},u.paddingValue=function(t){return arguments.length?(r(t),u):l.paddingValue},u.getValue=function(t){return arguments.length?(i(t),u):o.getValue},u.filter=function(t){return arguments.length?(a(t),u):o.filter},u.getExtent=function(t){var e,n=l.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
e=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=t&&
// Iterate over each element of the data
t.forEach(function(t,n){
// If the element passes the filter, then update the extent
if(o.filter(t,n)){r=!0;var i=o.getValue(t,n);e[0]=Math.min(e[0],i),e[1]=Math.max(e[1],i)}}),
// If we didn't find any data, use the default values
r||(e=l.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(e[0]=n[0]),null!=n[1]&&(e[1]=n[1]));var i=l.paddingValue;null==i||null==i[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
e[0]-=l.paddingValue[0]),null==i||null==i[1]||null!=n&&null!=n[1]||(e[1]+=l.paddingValue[1])}else
// Since the override is fully specified, use it
e=n;
// Verify that the extent is valid
return e[0]>e[1]&&(e[1]=e[0]),e},u(t),u}function s(t){function e(t){i=t}function n(t){a=t}/*
	 * Constructor/initialization method
	 */
function r(t){null!=t&&(null!=t.extent&&e(t.extent),null!=t.series&&n(t.series))}var i=c(),a=[];/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return r.extent=function(t){return arguments.length?(e(t),r):i},r.series=function(t){return arguments.length?(a=t,r):a},r.getExtent=function(t){var e;
// Iterate over each series
// In case there was no data
return a.forEach(function(n){
// Update the extent to set the value getter
i.getValue(n.getValue);
// Get the extent of the current series
var r=i.getExtent(t);
// If it's null, use the new extent
null==e?e=r:(e[0]=Math.min(e[0],r[0]),e[1]=Math.max(e[1],r[1]))}),null==e&&(e=i.getExtent([])),e},r(t),r}function g(t){/**
	 * Private Functions
	 */
function n(t){
// Should probably fire event for new brush state
p=t}function r(){return p&&null!=d}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function i(t){return null!=t&&Array.isArray(t)&&(t=t.map(function(t){return+t})),t}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function a(t){return(!Array.isArray(t)||2!=t.length||isNaN(t[0])||isNaN(t[1]))&&(t=void 0),t}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function l(t){return function(e){var n=null!=o.event.selection?i(o.event.selection.map(f.invert)):void 0,r=m,a=!((n===r||null!=n&&null!=r&&n[0]===r[0]&&n[1]===r[1])&&v);
// Store the new selection only on the 'end' event
"end"===t&&(
// Reset the selection
m=n,
// Reset the flag
v=!1),
// Suppress event if it's duplicate and programmatic
a&&h.apply(t,this,e)}}function c(t){var e=void 0;return p&&null!=t&&null!=f&&(e=null!=(e=u.brushSelection(t))&&Array.isArray(e)?i(e.map(f.invert)):void 0),e}function s(t,e){var n=null==(e=a(e))||e[0]>=e[1];
// either clear the filter or move it
v=!0,n?d.move(t,void 0):d.move(t,e.map(f))}function g(t){if(null==t)throw new Error("Must provide a brush and a scale");if(null==t.brush)throw new Error("Must provide a brush");if((d=t.brush).on("brush",l("brush")).on("start",l("start")).on("end",l("end")),null==t.scale)throw new Error("Must provide a scale");f=t.scale,null!=t.enabled&&n(t.enabled)}/**
	 * Private variables
	 */
// The brush object
var d,f,h=e.dispatch("brush","start","end"),m=void 0,p=!1,v=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return g.scale=function(t){return arguments.length?(f=t,g):f},g.dispatch=function(){return h},g.brush=function(){return d},g.enabled=function(t){return arguments.length?(n(t),g):r()},g.getSelection=function(t){return c(t)},g.setSelection=function(t,e){return s(t,e)},g(t),g}/**
 *
 *  data: []
 *  series: [ {label, x, y} ]
 *
 */
function d(){/**
	 * Explodes the data into an array with one point per unique point
	 * in the data (according to the series).
	 *
	 * I.e.,
	 *
	 * data: [{ x: 0, y1: 1, y2: 2}]
	 * series: [
	 *     { key: 's1', getValue: function(d) { return d.y1; } },
	 *     { key: 's2', getValue: function(d) { return d.y2; } }
	 * ]
	 *
	 * ==>
	 *
	 * [
	 *     { x: 0, y: 1, series: { key: 's1', ... }, data: { x: 0, y1: 1, y2: 2 },
	 *     { x: 0, y: 2, series: { key: 's2', ... }, data: { x: 0, y1: 1, y2: 2 },
	 * ]
	 *
	 * @param series
	 * @param data
	 */
function t(t,e,n){var r=[];
// Loop over each series
return t.forEach(function(t,i){
// Convert the data to x/y series
r=r.concat(e.map(function(e,r){return{x:n(e,r),y:t.getValue(e,r),series:t,data:e}}))}),r}function n(t){if(null!=t){var e=X.g.points.selectAll("circle").data(O.map(function(e){return{x:V.valueX(t.data),y:e.getValue(t.data),category:e.category}})),n=e.enter().append("circle"),r=e.selectAll("circle");n.merge(r).attr("class",function(t,e){return t.category}).attr("cx",function(t,e){return B.x(t.x)}).attr("cy",function(t,e){return B.y(t.y)}).attr("r",3)}else X.g.points.selectAll("circle").remove()}function o(t,e){var r=E.pointEvents;"value"===r||"values"===r&&n(t.data),I.call("pointMouseover",this,t.data,e)}function d(t,e){var r=E.pointEvents;"value"===r||"values"===r&&n(),I.call("pointMouseout",this,t.data,e)}function f(t,e){I.call("pointClick",this,t.data,e)}/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function h(){
// Try to get the node from the brush group selection
var t=null!=X.g.brush?X.g.brush.node():null;
// Get the current brush selection
return L.getSelection(t)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function m(t){L.setSelection(X.g.brush,t)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in brush change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function p(t){
// If there was no previous extent, then there is no brush to update
if(null!=t){
// Derive the overall plot extent from the collection of series
var e=M.x.getExtent(P);m(null!=e&&Array.isArray(e)&&2==e.length?[Math.max(e[0],t[0]),Math.min(e[1],t[1])]:void 0)}X.g.brush.style("display",L.enabled()?"unset":"none").call(L.brush())}function v(){null!=G.x&&X.g.xAxis.call(G.x),null!=G.xGrid&&E.xGrid&&X.g.xAxisGrid.call(G.xGrid),null!=G.y&&X.g.yAxis.call(G.y),null!=G.yGrid&&E.yGrid&&X.g.yAxisGrid.call(G.yGrid)}function x(){
// Join
var e=X.g.plots.selectAll(".plot").data(O,function(t){return t.key}),n=e.enter().append("g").attr("class","plot"),r=n.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" line"}),i=n.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" area"}),a=e.select(".line"),u=e.select(".area");if(
// Enter + Update
r.merge(a).attr("d",function(t){return C.y(function(e,n){return B.y(t.getValue(e,n))})(P)}),i.merge(u).attr("d",function(t){return N.y0(B.y.range()[0]).y1(function(e,n){return B.y(t.getValue(e,n))})(P)}),
// Remove the previous voronoi
X.g.voronoi.selectAll("path").remove(),E.pointEvents){
// check range against width
var l=B.x.domain(),c=t(O,P,V.valueX).filter(function(t){
// Filter out points that are outside of the extent
return l[0]<=t.x&&t.x<=l[1]});
// Filter out paths that are null
c=_.polygons(c).filter(function(t){return null!=t}),
// Draw the circle markers
X.g.voronoi.selectAll("path").data(c).enter().append("path").attr("d",function(t){return null!=t?"M"+t.join("L")+"Z":null}).on("mouseover",o).on("mouseout",d).on("click",f)}e.exit().remove()}function y(){
// Join
var t=X.g.markers.selectAll(".marker").data(U,V.markerValueX),e=t.enter().append("g").attr("class","marker").on("mouseover",function(t,e){I.call("markerMouseover",this,t,e)}).on("mouseout",function(t,e){I.call("markerMouseout",this,t,e)}).on("click",function(t,e){I.call("markerClick",this,t,e)}),n=e.append("line"),r=e.append("text");n.attr("y1",function(t){return B.y.range()[1]}).attr("y2",function(t){return B.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(V.markerLabel);
// Enter + Update
var i=t.select("line"),a=t.select("text");n.merge(i).attr("x1",function(t,e){return B.x(V.markerValueX(t,e))}).attr("x2",function(t,e){return B.x(V.markerValueX(t))}),r.merge(a).attr("x",function(t,e){return B.x(V.markerValueX(t))}),
// Exit
t.exit().remove()}
// Chart create/init method
function b(){}var k="timeline_line_"+Date.now(),w={top:10,right:10,bottom:20,left:40},z=100,A=600,E={xGrid:!1,yGrid:!1,pointEvents:!1},V={valueX:function(t){return t[0]},markerValueX:function(t){return t[0]},markerLabel:function(t){return t[1]},pointRadius:function(){return 2}},S=Date.now(),M={x:c({defaultValue:[S-3e5,S],getValue:function(t,e){return V.valueX(t,e)}}),y:c()},T=s(),B={x:r.scaleTime(),y:r.scaleLinear()},G={x:a.axisBottom().scale(B.x),y:a.axisLeft().ticks(3).scale(B.y),xGrid:a.axisBottom().tickFormat("").tickSizeOuter(0).scale(B.x),yGrid:a.axisLeft().tickFormat("").tickSizeOuter(0).ticks(3).scale(B.y)},C=i.line().x(function(t,e){return B.x(V.valueX(t,e))}),N=i.area().x(function(t,e){return B.x(V.valueX(t,e))}),_=l.voronoi().x(function(t,e){return B.x(t.x,e)}).y(function(t,e){return B.y(t.y,e)}),L=g({brush:u.brushX(),scale:B.x});L.dispatch().on("end",function(){I.call("brushEnd",this,h())}).on("start",function(){I.call("brushStart",this,h())}).on("brush",function(){I.call("brush",this,h())});
// The dispatch object and all events
var I=e.dispatch("brush","brushStart","brushEnd","markerClick","markerMouseover","markerMouseout","pointMouseover","pointMouseout","pointClick"),X={svg:void 0,g:{container:void 0,plots:void 0,points:void 0,voronoi:void 0,xAxis:void 0,yAxis:void 0,xAxisGrid:void 0,yAxisGrid:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},P=[],O=[],U=[];/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the data to drive the chart
	 */
/*
	 * Define the series to show on the chart
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return b.init=function(t){
// Create a container div
X.div=t.append("div").attr("class","sentio timeline"),
// Create the SVG element
X.svg=X.div.append("svg");
// Add the defs and add the clip path definition
var e=X.svg.append("defs");
// Append a container for everything
// Append the grid
// Append the path group (which will have the clip path and the line path
// Append groups for the axes
// Append a group for the voronoi and the points
// Append a group for the markers
// Add the brush element
return X.plotClipPath=e.append("clipPath").attr("id","plot_"+k).append("rect"),X.markerClipPath=e.append("clipPath").attr("id","marker_"+k).append("rect"),X.g.container=X.svg.append("g"),X.g.grid=X.g.container.append("g").attr("class","grid"),X.g.xAxisGrid=X.g.grid.append("g").attr("class","x"),X.g.yAxisGrid=X.g.grid.append("g").attr("class","y"),X.g.plots=X.g.container.append("g").attr("class","plots"),X.g.plots.attr("clip-path","url(#plot_"+k+")"),X.g.axes=X.g.container.append("g").attr("class","axis"),X.g.xAxis=X.g.axes.append("g").attr("class","x"),X.g.yAxis=X.g.axes.append("g").attr("class","y"),X.g.points=X.g.container.append("g").attr("class","points"),X.g.points.attr("clip-path","url(#marker_"+k+")"),X.g.voronoi=X.g.container.append("g").attr("class","voronoi"),X.g.markers=X.g.container.append("g").attr("class","markers"),X.g.markers.attr("clip-path","url(#marker_"+k+")"),X.g.brush=X.g.container.append("g").attr("class","x brush"),X.g.brush.attr("clip-path","url(#marker_"+k+")"),b.resize(),b},b.data=function(t){return arguments.length?(P=null!=t?t:[],b):P},b.series=function(t){return arguments.length?(O=null!=t?t:[],b):O},b.markers=function(t){return arguments.length?(U=null!=t?t:[],b):U},b.resize=function(){
// Need to grab the brush extent before we change anything
var t=h();
// Resize the SVG Pane
// Update the margins on the main draw group
// Resize Scales
/**
		 * Resize clip paths
		 */
// Plot clip path is only the plot pane
// Marker clip path includes top margin by default
// Resize the clip extent of the plot
/**
		 * Update axis and grids
		 */
// Reset axis and grid positions
// Resize the x grid ticks
// Resize the y grid ticks
/**
		 * Update the brush
		 */
// Resize and position the brush g element
// Resize the brush
return X.svg.attr("width",A).attr("height",z),X.g.container.attr("transform","translate("+w.left+","+w.top+")"),B.x.range([0,Math.max(0,A-w.left-w.right)]),B.y.range([Math.max(0,z-w.top-w.bottom),0]),X.plotClipPath.attr("transform","translate(0, -1)").attr("width",Math.max(0,B.x.range()[1])+2).attr("height",Math.max(0,B.y.range()[0])+2),X.markerClipPath.attr("transform","translate(0, -"+w.top+")").attr("width",Math.max(0,A-w.left-w.right)).attr("height",Math.max(0,z-w.bottom)),_.extent([[0,0],[A-w.left-w.right,z-w.top-w.bottom]]),X.g.xAxis.attr("transform","translate(0,"+B.y.range()[0]+")"),X.g.xAxisGrid.attr("transform","translate(0,"+B.y.range()[0]+")"),E.xGrid?G.xGrid.tickSizeInner(-(z-w.top-w.bottom)):G.xGrid.tickSizeInner(0),E.yGrid?G.yGrid.tickSizeInner(-(A-w.left-w.right)):G.yGrid.tickSizeInner(0),X.g.brush.selectAll("rect").attr("y",-1).attr("x",0).attr("width",B.x.range()[1]).attr("height",B.y.range()[0]+2),L.brush().extent([[0,0],[B.x.range()[1],B.y.range()[0]+2]]),p(t),b},b.redraw=function(){
// Need to grab the brush extent before we change anything
var t=h();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return B.x.domain(M.x.getExtent(P)),B.y.domain(T.extent(M.y).series(O).getExtent(P)),v(),x(),y(),p(t),b},b.width=function(t){return arguments.length?(A=t,b):A},b.height=function(t){return arguments.length?(z=t,b):z},b.margin=function(t){return arguments.length?(w=t,b):w},b.showXGrid=function(t){return arguments.length?(E.xGrid=t,b):E.xGrid},b.showYGrid=function(t){return arguments.length?(E.yGrid=t,b):E.yGrid},b.showGrid=function(t){return E.xGrid=E.yGrid=t,b},b.pointEvents=function(t){return arguments.length?(E.pointEvents=t,b):E.pointEvents},b.curve=function(t){return arguments.length?(C.curve(t),N.curve(t),b):C.curve()},b.xAxis=function(t){return arguments.length?(G.x=t,b):G.x},b.xGridAxis=function(t){return arguments.length?(G.xGrid=t,b):G.xGrid},b.yAxis=function(t){return arguments.length?(G.y=t,b):G.y},b.yGridAxis=function(t){return arguments.length?(G.yGrid=t,b):G.yGrid},b.xScale=function(t){return arguments.length?(B.x=t,null!=G.x&&G.x.scale(t),null!=G.xGrid&&G.xGrid.scale(t),null!=L&&L.scale(t),b):B.x},b.yScale=function(t){return arguments.length?(B.y=t,null!=G.y&&G.y.scale(t),null!=G.yGrid&&G.yGrid.scale(t),b):B.y},b.xValue=function(t){return arguments.length?(V.valueX=t,b):V.valueX},b.yExtent=function(t){return arguments.length?(M.y=t,b):M.y},b.xExtent=function(t){return arguments.length?(M.x=t,b):M.x},b.markerXValue=function(t){return arguments.length?(V.markerValueX=t,b):V.markerValueX},b.markerLabel=function(t){return arguments.length?(V.markerLabel=t,b):V.markerLabel},b.dispatch=function(t){return arguments.length?b:I},b.brush=function(t){return arguments.length?(L.enabled(t),b):L.enabled()},b.setBrush=function(t){return m(t),b},b.getBrush=function(){return h()},b}/**
 * Binning model for timelines
 *
 * This data model is responsible for subdiving a period of time into an array of sequential bins.
 * As data objects are added to the model, they are aggregated into the bins.
 *
 */
function f(t){/**
	 * Private Functions
	 */
// Get the index given the value
function e(t){return null==l.size||null==l.lwm?0:Math.floor((t-l.lwm)/l.size)}function n(){l.hwm=l.lwm+l.count*l.size}function r(){
// drop stuff below the lwm
for(var t,e=s;c.length>0&&c[0][0]<l.lwm;)t=c.shift(),s-=o.countBin(t);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=l.hwm;)t=c.pop(),s-=o.countBin(t);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([l.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-l.size;n>=l.lwm;n-=l.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<l.hwm-l.size;)c.push([c[c.length-1][0]+l.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(u,c,s,e)}function i(t){var n=s;t.forEach(function(t,n){var r=e(o.getKey(t,n));if(r>=0&&r<c.length){var i=o.getValue(t,n),a=o.countBin(c[r]);o.updateBin.call(u,c[r],i,n),s+=o.countBin(c[r])-a}}),o.afterAdd&&o.afterAdd.call(u,c,s,n)}function a(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function u(t){if(null==t||null==t.size||null==t.count||null==t.lwm)throw new Error("You must provide an initial size, count, and lwm");l.size=Number(t.size),l.count=Number(t.count),l.lwm=Number(t.lwm),null!=t.createSeed&&(o.createSeed=t.createSeed),null!=t.getKey&&(o.getKey=t.getKey),null!=t.getValue&&(o.getValue=t.getValue),null!=t.updateBin&&(o.updateBin=t.updateBin),null!=t.countBin&&(o.countBin=t.countBin),null!=t.afterAdd&&(o.afterAdd=t.afterAdd),null!=t.afterUpdate&&(o.afterUpdate=t.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var l={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(t){return t},
// The default value function
getValue:function(t){return t},
// The default function for updating a bin given a new value
updateBin:function(t,e){t[1].push(e)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(t){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof t[1]?t[1]:t[1].hasOwnProperty("length")?t[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(t,e,n){},
// The default function to be called after the bins are updated
afterUpdate:function(t,e,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return u.set=function(t){return a(),r(),i(t),u},u.clear=function(){return a(),r(),u},u.add=function(t){return i(t),u},u.lwm=function(t){if(!arguments.length)return l.lwm;var e=l.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return l.lwm=Number(t),n(),(e-l.lwm)%l.size!=0&&a(),r(),u},u.hwm=function(){return l.hwm},u.getKey=function(t){return arguments.length?(o.getKey=t,a(),r(),u):o.getKey},u.getValue=function(t){return arguments.length?(o.getValue=t,a(),r(),u):o.getValue},u.updateBin=function(t){return arguments.length?(o.updateBin=t,a(),r(),u):o.updateBin},u.createSeed=function(t){return arguments.length?(o.createSeed=t,a(),r(),u):o.createSeed},u.countBin=function(t){return arguments.length?(o.countBin=t,a(),r(),u):o.countBin},u.afterAdd=function(t){return arguments.length?(o.afterAdd=t,u):o.afterAdd},u.afterUpdate=function(t){return arguments.length?(o.afterUpdate=t,u):o.afterUpdate},u.size=function(t){if(!arguments.length)return l.size;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return t!==l.size&&(l.size=t,n(),a(),r()),u},u.count=function(t){if(!arguments.length)return l.count;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return t!==l.count&&(l.count=Math.floor(t),n(),r()),u},u.bins=function(){return c},u.itemCount=function(){return s},u.clearBin=function(t){if(t>=0&&t<c.length){var e=o.countBin(c[t]);return s-=e,c[t][1]=o.createSeed(),e}return 0},u(t),u}t.chartDonut=function(){
// Chart create/init method
function t(t){}/**
	 * Private functions
	 */
function a(){/*
		 * Join the data
		 */
var t=y.gChart.selectAll("path.arc").data(x.pie(b),function(t,e){return p.key(t.data,e)}),e=t.enter().append("path").attr("class","arc").on("mouseover",p.mouseover).on("mouseout",p.mouseout).on("click",p.click).each(function(t){this._current={startAngle:0,endAngle:0}}).merge(t);e.transition().duration(f).attrTween("d",function(t){var e=n.interpolate(this._current,t);return this._current=e(0),function(t){return x.arc(e(t))}}),e.attr("key",function(t,e){return p.key(t.data,e)}).attr("fill",function(t,e){return v.color(p.key(t.data,e))}),/*
		 * Exit
		 */
t.exit().remove()}function u(){var t=h.markSize+h.markMargin;
// Only option is 'center' for now
if("center"===h.position){
// The center position of the chart
var e=g.left+o,n=g.top+o;return"translate("+(e-(null==y.gLegend._maxWidth?0:y.gLegend._maxWidth)/2)+","+(n-(t*b.length+h.markMargin)/2)+")"}}function l(){/*
		 * Join the data
		 */
var t=y.gLegend.selectAll("g.entry").data(b,p.key),e=t.enter().append("g").attr("class","entry").attr("transform",function(t,e){return"translate(0, "+e*(h.markSize+h.markMargin)+")"}).on("mouseover",p.mouseover).on("mouseout",p.mouseout).on("click",p.click),n=e.append("rect").attr("width",h.markSize).attr("height",h.markSize);/*
		 * Enter + Update
		 */
e.append("text").attr("x",h.markSize+h.markMargin).attr("y",h.markSize-h.labelOffset).merge(t.select("text")).text(p.label),n.merge(t.select("rect")).style("fill",function(t,e){return v.color(p.key(t,e))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
e.merge(t).each(function(t,e){
// Reset
y.gLegend._maxWidth=0===e?this.getBBox().width:Math.max(this.getBBox().width,y.gLegend._maxWidth)}),
// Reassert the legend position
y.gLegend.attr("transform",u()),/*
		 * Exit
		 */
t.exit().remove()}
// Chart height/width
var o,c=400,s=400,g={top:2,bottom:2,right:2,left:2},d=.7,f=500,h={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},m=e.dispatch("mouseover","mouseout","click"),p={getEventElement:function(t,e){return null!=t&&null!=t.data?t.data:t},updateActiveElement:function(t,e){var n=y.gLegend.selectAll("g.entry"),r=y.gChart.selectAll("path.arc");if(null!=t){
// Set the highlight on the row
var i=p.key(t,e);n.classed("active",function(t,e){return p.key(t,e)==i}),r.classed("active",function(t,e){return p.key(t.data,e)==i})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(t,e){t=p.getEventElement(t,e),p.updateActiveElement(t,e),m.call("mouseover",this,t,e)},mouseout:function(t,e){t=p.getEventElement(t,e),p.updateActiveElement(),m.call("mouseout",this,t,e)},click:function(t,e){t=p.getEventElement(t,e),m.call("click",this,t,e)},key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},v={color:r.scaleOrdinal(r.schemeCategory10)},x={arc:i.arc().padAngle(.01),pie:i.pie().value(function(t,e){return p.value(t,e)}).sort(null)},y={div:void 0,svg:void 0,gChart:void 0,legend:void 0},b=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return t.init=function(e){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return y.div=e.append("div").attr("class","sentio donut"),y.svg=y.div.append("svg"),y.gChart=y.svg.append("g").attr("class","chart"),y.gLegend=y.svg.append("g").attr("class","legend"),t.resize(),t},t.data=function(e){return arguments.length?(b=null!=e?e:[],t):b},t.resize=function(){var e=c-g.right-g.left,n=s-g.top-g.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return o=Math.min(n,e)/2,y.svg.attr("width",c).attr("height",s),y.gChart.attr("transform","translate("+(g.left+o)+","+(g.top+o)+")"),x.arc.innerRadius(o*d).outerRadius(o),y.gLegend.attr("transform",u()),t},t.redraw=function(){return a(),h.enabled&&l(),t},t.width=function(e){return arguments.length?(c=e,t):c},t.height=function(e){return arguments.length?(s=e,t):s},t.innerRadiusRatio=function(e){return arguments.length?(d=e,t):d},t.duration=function(e){return arguments.length?(f=e,t):f},t.key=function(e){return arguments.length?(p.key=e,t):p.key},t.value=function(e){return arguments.length?(p.value=e,t):p.value},t.label=function(e){return arguments.length?(p.label=e,t):p.label},t.colorScale=function(e){return arguments.length?(v.color=e,t):v.color},t.dispatch=function(){return m},t.legend=function(e){return arguments.length?(h=e,t):h},t},t.chartMatrix=function(){function t(t,e){var n=b.g.chart.selectAll(".row text");if(null!=t){
// Set the highlight on the row
var r=t.key;n.classed("active",function(t){return t.key==r})}else
// Now update the style
n.classed("active",!1)}function n(e,n){t(e,n),z.call("rowMouseover",this,e,n)}function i(e,n){t(),z.call("rowMouseout",this,e,n)}function u(t,e){z.call("rowClick",this,t,e)}function l(t,e){z.call("cellMouseover",this,t,e)}function o(t,e){z.call("cellMouseout",this,t,e)}function g(t,e){z.call("cellClick",this,t,e)}/**
	 * Style stuff
	 */
// Cell dimensions
var d=16,f=1,h={top:20,right:2,bottom:2,left:64},m=500,p={key:function(t){return t.key},value:function(t){return t.value}},v={x:c().getValue(function(t,e){return p.key(t,e)}),value:c(),multi:s()},x={x:r.scaleLinear(),y:r.scaleOrdinal(),color:r.scaleLinear().range(["#e7e7e7","#008500"])},y={x:a.axisTop().scale(x.x).tickSizeOuter(0).tickSizeInner(2)},b={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},k=[],w=[],z=e.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),A=function(){};return A.init=function(t){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return b.div=t.append("div").attr("class","sentio matrix"),b.svg=b.div.append("svg"),b.g.xAxis=b.svg.append("g").attr("class","x axis"),b.g.chart=b.svg.append("g").attr("class","chart"),A},A.resize=function(){},A.redraw=function(){
// Determine the number of rows/boxes to render
var t=w.length,e=k.length,r=f+d,a=e*r+f,c=t*r+f;
// scale the svg to the right size
b.svg.attr("width",a+h.left+h.right).attr("height",c+h.top+h.bottom),
// Configure the scales
x.x.domain(v.x.getExtent(k)).range([0,a-f-r]),x.color.domain(v.multi.extent(v.value).series(w).getExtent(k)),
// Draw the x axis
b.g.xAxis.attr("transform","translate("+(h.left+f+d/2)+","+h.top+")"),b.g.xAxis.call(y.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var s=b.g.chart.selectAll("g.row").data(w,function(t){return t.key}),z=s.enter().append("g");z.style("opacity","0.1").attr("class","row").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}).on("mouseover",n).on("mouseout",i).on("click",u),
// Also must append the label of the row
z.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",f+d/2).attr("dy",".32em"),
// Also must append a line
z.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",f+d/2).attr("y2",f+d/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var E=z.merge(s);E.transition().duration(m).style("opacity","1").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}),
// Update the series labels in case they changed
E.select("text.series.label").text(function(t){return t.label}),/*
		 * Row Exit
		 */
s.exit().transition().duration(m).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var V=E.selectAll("rect.cell").data(function(t){return k.map(function(e,n){return{key:p.key(e,n),value:t.getValue(e,n)}})},p.key);/*
		 * Cell Remove
		 */
return V.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(t,e){return x.color(t.value)}).attr("x",function(t,e){return x.x(t.key)+f}).attr("y",f).attr("height",d).attr("width",d).on("mouseover",l).on("mouseout",o).on("click",g).merge(V).transition().duration(m).style("opacity","1").attr("x",function(t,e){return x.x(t.key)+f}).style("fill",function(t,e){return x.color(t.value)}),V.exit().transition().duration(m).attr("width",0).style("opacity","0.1").remove(),A},A.data=function(t){return arguments.length?(k=null!=t?t:[],A):k},A.series=function(t){return arguments.length?(w=null!=t?t:[],A):w},A.cellSize=function(t){return arguments.length?(d=t,A):d},A.cellMargin=function(t){return arguments.length?(f=t,A):f},A.margin=function(t){return arguments.length?(h=t,A):h},A.duration=function(t){return arguments.length?(m=t,A):m},A.key=function(t){return arguments.length?(p.key=t,A):p.key},A.colorScale=function(t){return arguments.length?(x.color=t,A):x.color},A.xScale=function(t){return arguments.length?(x.xScale=t,y.x.scale(t),A):x.xScale},A.yScale=function(t){return arguments.length?(x.yScale=t,A):x.yScale},A.xExtent=function(t){return arguments.length?(v.x=t,v.x.getValue(function(e,n){return t(e,n)}),A):v.x},A.valueExtent=function(t){return arguments.length?(v.value=t,A):v.value},A.dispatch=function(){return z},A},t.chartTimeline=d,t.chartAutoBrushTimeline=function(){function t(t){var e=t;
// Crop the brush to max extent
if(null!=e){
// Crop the brush using the max extent
(
// Make a new copy
e=t.slice())[0]=Math.max(e[0],h[0]),e[1]=Math.min(e[1],h[1]);
// What brush width do we need to obtain
var n=e[1]-e[0],r=n;null!=p&&(r=Math.min(n,p)),null!=m&&(r=Math.max(r,m)),
// If the width has to change
r!=n&&(e[0]===o[0]?
// We should move the upper bound
e[1]=e[0]+r:e[1]===o[1]&&(
// We should move the lower bound
e[0]=e[1]-r))}return e}function n(t){return null!=t&&(null==p||t[1]-t[0]<=p)}/**
	 * Handle a change to the brush (whether from the timeline or manual)
	 * - Crop the brush if necessary based on maxExtent
	 * - Ensure the brush is valid.
	 * - Update the brush and recalculate the extent.
	 *
	 * @param newBrush
	 */
function r(e){
// Ensure the brush is valid
if(e=t(e),n(e)){var r=null==o||o[0]!=e[0]||o[1]!=e[1];
// Update the brush
o=e,b.setBrush(o),
// Update the extent as necessary
a(),
// Only fire the brush event if it actually changed
r&&x.call("brushChange",this,o)}else
// Don't allow them to apply an invalid brush
b.setBrush(o)}/**
	 * Update the extent
	 */
function a(){var t=u(o);if(t.pan||t.zoom){
// Update the Extent and fire the event
var e=l(o,t);y.xExtent().overrideValue(e),x.call("extentChange",this,e)}}/**
	 * Check to see if the extent needs to change
	 * - Checks boundaries and zoom level
	 * - Returns a status to indicate how the extent needs to change
	 *
	 * @param brush
	 * @returns { pan: boolean, zoom: boolean }
	 */
function u(t){var e={pan:!1,zoom:!1};if(null!=t){var n=y.xScale(),r=n.domain()[0],i=t[0],a=t[1],u=n.domain()[1],l=u-r,o=(a-i)/l,c=(i-r)/l<=g.edgeTrigger&&i>h[0],s=(u-a)/l<=g.edgeTrigger&&a<h[1];
// Should we resize and/or recenter?
e.zoom=o>=g.zoomOutTrigger||o<=g.zoomInTrigger,e.pan=c||s}return e}/**
	 * Given the brush, determine the new xExtent that should be applied
	 * @param brush The brush for which to determine the extent
	 * @param transform What kind of transform we should apply (whether zoom or pan)
	 * @returns {[*,*]}
	 */
function l(t,e){var n=y.xScale().domain()[0],r=t[0],i=t[1],a=y.xScale().domain()[1]-n;
// If we're zooming, change the target width
e.zoom&&(
// Calculate the new width of the extent (and make sure it isn't smaller than the max zoom)
a=Math.max((i-r)/g.zoomTarget,f));
// Determine the current center of the brush
var u=r+(i-r)/2,l=Math.max(u-a/2,h[0]);
// Track how much of the width we successfully applied to the new lower bound
a-=u-l;
// Determine the new upper bound as as much of the width as we can apply above the center
var o=Math.min(u+a,h[1]);
// Track how much of the width we applied to the upper bound
// If newWidthE is greater than zero, it means that clipping kept us from applying
// all of the width, so we should try to apply the rest to the lower bound
return a-=o-u,l=Math.max(l-a,h[0]),[l,o]}var o,c="autobrush_timeline_"+Date.now(),s=Date.now(),g={edgeTrigger:.01,zoomInTrigger:.05,zoomOutTrigger:.8,zoomTarget:.2},f=864e5,h=[s-31536e7,s],m=36e5,p=void 0,v=[s-15552e6,s],x=e.dispatch("extentChange","brushChange"),y=d();
// Turn on brushing and register for brush events
y.brush(!0),y.dispatch().on("brushEnd.internal",function(t){r(t),y.redraw()}),
// Turn off pointer events by default
y.pointEvents(!1);var b={element:{g:{container:void 0},axisClipPath:void 0},brush:y.brush,dispatch:y.dispatch,init:y.init,resize:y.resize,redraw:y.redraw,setBrush:y.setBrush,xAxis:y.xAxis};
// Set up default look and feel
// Initialization of the timeline and auto brush
// Redraw the auto brush
// Resize
// Basic Getters/Setters
// Cannot disable the brush
return y.margin({top:2,right:10,bottom:2,left:10}),y.xAxis().ticks(5),y.yAxis(null),y.init=function(t){
// Store the container
// Initialize the timeline
// Set the initial brush
// Add a clip path for the axis
// Attach the clip path to the axis
return b.element.g.container=t,b.init(t),null==o&&r(v),b.element.axisClipPath=t.select("svg defs").append("clipPath").attr("id","axis_"+c).append("rect"),b.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("clip-path","url(#axis_"+c+")"),y.resize(),y},y.redraw=function(){
// Let the timeline redraw like normal
b.redraw(),/*
		 * Update the X Axis
		 */
// Set the x Axis ticks to be full height
y.xAxis().tickSize(-y.height()+y.margin().top+y.margin().bottom);
// Update text position to be on the chart
var t=b.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("pointer-events","none");
// Set the x Axis ticks to be full height
// Set the curve to interpolate
// Call it to redraw
return t.selectAll("g.tick text").attr("y","3").attr("dy","-0.71em").attr("dx","0.35em").attr("text-anchor","start"),y.xAxis().tickSize(-y.height()+y.margin().top+y.margin().bottom),y.curve(i.curveNatural),null!=y.xAxis()&&t.call(y.xAxis()),y},y.resize=function(){
// Need to be defensive here since parent init calls resize
if(b.resize(),null!=b.element.axisClipPath){var t=y.margin(),e=y.width(),n=y.height();
// Update the size of the xAxis clip path
b.element.axisClipPath.attr("transform","translate(0, -"+(n+t.top)+")").attr("width",Math.max(0,e-t.left-t.right+2)).attr("height",Math.max(0,n+t.bottom+t.top))}},y.edgeTrigger=function(t){return arguments.length?(g.edgeTrigger=t,y):g.edgeTrigger},y.zoomInTrigger=function(t){return arguments.length?(g.zoomInTrigger=t,y):g.zoomInTrigger},y.zoomOutTrigger=function(t){return arguments.length?(g.zoomOutTrigger=t,y):g.zoomOutTrigger},y.zoomTarget=function(t){return arguments.length?(g.zoomTarget=t,y):g.zoomTarget},y.maxExtent=function(t){return arguments.length?(h=t,y):h},y.minExtent=function(t){return arguments.length?(f=t,y):f},y.minBrush=function(t){return arguments.length?(m=t,y):m},y.maxBrush=function(t){return arguments.length?(p=t,y):p},y.setBrush=function(t){return r(t),y},y.dispatch=function(){return x},y.timelineDispatch=function(){return b.dispatch},y.brush=function(){return!0},y},t.chartRealtimeTimeline=function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function t(){
// If not running, let the loop die
r&&(u.redraw(),
// Schedule the next update
i=window.setTimeout(t,a>0?1e3/a:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var e=0,n=6e4,r=!1,i=null,a=32,u=d();u.yExtent().filter(function(t){var e=u.xValue()(t),n=u.xExtent().getExtent();return e<n[1]&&e>n[0]}),u.brush(!1),u.pointEvents(!1);/*
	 * Redraw the graphic
	 */
var l=u.redraw;return u.redraw=function(){
// Update the x domain (to the latest time window)
var t=new Date;return u.xExtent().overrideValue([t-e-n,t-e]),l(),u},u.start=function(){if(!r)return r=!0,t(),u},u.stop=function(){return r=!1,null!=i&&window.clearTimeout(i),u},u.restart=function(){return u.stop(),u.start(),u},u.interval=function(t){return arguments.length?(n=t,u):n},u.delay=function(t){return arguments.length?(e=t,u):e},u.fps=function(t){return arguments.length?(a=t,r&&u.restart(),u):a},u.brush=function(t){return!1},u},t.chartVerticalBars=function(){function t(t,e){d.call("mouseover",this,t,e)}function n(t,e){d.call("mouseout",this,t,e)}function i(t,e){d.call("click",this,t,e)}
// Chart create/init method
function a(t){}
// Layout properties
var u=100,l=24,o=2,s=.1,g=500,d=e.dispatch("mouseover","mouseout","click"),f={key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},h={x:r.scaleLinear(),y:r.scaleLinear()},m={width:c({defaultValue:[0,10],getValue:function(t,e){return f.value(t,e)}})},p={div:void 0},v=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return a.init=function(t){
// Create the DIV element
return p.div=t.append("div").attr("class","sentio bars-vertical"),a.resize(),a},a.data=function(t){return arguments.length?(v=null!=t?t:[],a):v},a.resize=function(){
// Set up the x scale (y is fixed)
return h.x.range([u*s,u]),a},a.redraw=function(){
// Update the x domain
h.x.domain(m.width.getExtent(v)),
// Update the y domain (based on configuration and data)
h.y.domain([0,v.length]),h.y.range([0,(l+o)*v.length]);
// Data Join
var e=p.div.selectAll("div.bar").data(v,f.key),r=e.enter().append("div").attr("class","bar").style("top",h.y.range()[1]-l+"px").style("height",l+"px").on("mouseover",t).on("mouseout",n).on("click",i).style("opacity","0.01"),u=r.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return r.merge(e).transition().duration(g).style("opacity","1").style("width",function(t,e){return h.x(f.value(t,e))+"px"}).style("top",function(t,e){return h.y(e)+"px"}).style("left","0px"),u.merge(e.select("div.bar-label")).html(f.label).style("max-width",h.x.range()[1]-10+"px"),e.exit().transition().duration(g).style("opacity","0.01").style("top",h.y.range()[1]-l+"px").remove(),p.div.style("height",h.y.range()[1]+"px"),a},a.width=function(t){return arguments.length?(u=t,a):u},a.barWidthMinRatio=function(t){return arguments.length?(s=t,a):s},a.barHeight=function(t){return arguments.length?(l=t,a):l},a.barPadding=function(t){return arguments.length?(o=t,a):o},a.key=function(t){return arguments.length?(f.key=t,a):f.key},a.value=function(t){return arguments.length?(f.value=t,a):f.value},a.label=function(t){return arguments.length?(f.label=t,a):f.label},a.widthExtent=function(t){return arguments.length?(m.width=t,m.width.getValue(function(t,e){return f.value(t,e)}),a):m.width},a.dispatch=function(t){return arguments.length?a:d},a.duration=function(t){return arguments.length?(g=t,a):g},a},t.controllerRealtimeBins=/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(t){/**
	 * Private Functions
	 */
function e(){
// Assume the hwm is now plus two binSize
var t=Date.now()+2*u.size();
// Trunc the hwm down to a round value based on the binSize
return(t=Math.floor(t/u.size())*u.size())-u.size()*u.count()}function n(){!0===l&&(
// need to update the lwm
u.lwm(e()),window.setTimeout(n,u.size()))}function r(){l||(
// Start the update loop
l=!0,n())}function i(){
// Setting running to false will stop the update loop
l=!1}
// create/init method
function a(t){if(null==t||null==t.binCount||null==t.binSize)throw new Error("You must provide an initial binSize and binCount");o.binSize=Number(t.binSize),o.binCount=Number(t.binCount),null!=t.delay&&(o.delay=Number(t.delay)),(u=f({size:o.binSize,count:o.binCount+2,lwm:0})).lwm(e()),r()}/**
	 * Private variables
	 */
var u,l,o={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return a.model=function(){return u},a.bins=function(){return u.bins()},a.start=function(){return r(),a},a.stop=function(){return i(),a},a.running=function(){return l},a.add=function(t){return u.add(t),a},a.clear=function(){return u.clear(),a},a.binSize=function(t){if(!arguments.length)return o.binSize;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");return o.binSize=t,u.size(t),u.lwm(e()),a},a.binCount=function(t){if(!arguments.length)return o.binCount;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");return o.binCount=t,u.count(t+2),u.lwm(e()),a},a(t),a},t.controllerResponsiveUnits=/**
 *
 */
function(t){/**
	 * Private Functions
	 */
function e(t,e){var n=(t[1]-t[0])/e.value;return n>=r.maxTrigger?1:n<=r.minTrigger?-1:0}/*
	 * Constructor/initialization method
	 */
function n(t){null==t&&(t={}),null!=t.minTrigger&&(r.minTrigger=t.minTrigger),null!=t.maxTrigger&&(r.maxTrigger=t.maxTrigger)}/**
	 * Private variables
	 */
// Configuration
var r={minTrigger:30,maxTrigger:400},i=[{key:"second",value:1e3},{key:"minute",value:6e4},{key:"hour",value:36e5},{key:"day",value:864e5},{key:"month",value:2592e6},{key:"year",value:31536e6}],a=i[0];/**
	 * Public API
	 */
// Initialize the model
return n.getUnit=function(t){if(0===e(t,a))return a;
// Loop while there's too many points
for(
// We weren't good, so find a new unit by searching smallest to largest
var n=0;n<i.length&&0<e(t,i[n]);)n++;return a=i[Math.min(n,i.length-1)]},n.units=function(t){return arguments.length?(i=t,n):i},n.currentUnit=function(t){return arguments.length?(a=t,n):a},n.minTrigger=function(t){return arguments.length?(r.minTrigger=t,n):r.minTrigger},n.maxTrigger=function(t){return arguments.length?(r.maxTrigger=t,n):r.maxTrigger},n(t),n},t.timelineBrush=g,t.modelBins=f,t.modelExtent=c,t.modelMultiExtent=s,Object.defineProperty(t,"__esModule",{value:!0})});