/*! @asymmetrik/sentio - 5.0.0 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("d3-dispatch"),require("d3-interpolate"),require("d3-scale"),require("d3-shape"),require("d3-axis"),require("d3-brush"),require("d3-selection")):"function"==typeof define&&define.amd?define(["exports","d3-dispatch","d3-interpolate","d3-scale","d3-shape","d3-axis","d3-brush","d3-selection"],t):t(e.sentio={},e.d3,e.d3,e.d3,e.d3,e.d3,e.d3,e.d3)}(this,function(e,t,n,r,a,u,i,l){"use strict";function o(e){/**
	 * Private Functions
	 */
function t(e){if(null==e||2!==e.length||isNaN(e[0])||isNaN(e[1])||e[0]>=e[1])throw new Error("Default extent must be a two element ordered array of numbers");l.defaultValue=e}function n(e){if(null!=e&&2!==e.length)throw new Error("Extent override must be a two element array or null/undefined");l.overrideValue=e}function r(e){if(null!=e&&2!==e.length)throw new Error("Extent padding must be a two element array or null/undefined");l.paddingValue=e}function a(e){if("function"!=typeof e)throw new Error("Value getter must be a function");o.getValue=e}function u(e){if("function"!=typeof e)throw new Error("Filter must be a function");o.filter=e}/*
	 * Constructor/initialization method
	 */
function i(e){null!=e&&(null!=e.defaultValue&&t(e.defaultValue),null!=e.overrideValue&&n(e.overrideValue),null!=e.paddingValue&&r(e.paddingValue),null!=e.getValue&&a(e.getValue),null!=e.filter&&u(e.filter))}/**
	 * Private variables
	 */
// Configuration
var l={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(e){return e},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return i.defaultValue=function(e){return arguments.length?(t(e),i):l.defaultValue},i.overrideValue=function(e){return arguments.length?(n(e),i):l.overrideValue},i.paddingValue=function(e){return arguments.length?(r(e),i):l.paddingValue},i.getValue=function(e){return arguments.length?(a(e),i):o.getValue},i.filter=function(e){return arguments.length?(u(e),i):o.filter},i.getExtent=function(e){var t,n=l.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
t=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=e&&
// Iterate over each element of the data
e.forEach(function(e,n){
// If the element passes the filter, then update the extent
if(o.filter(e,n)){r=!0;var a=o.getValue(e,n);t[0]=Math.min(t[0],a),t[1]=Math.max(t[1],a)}}),
// If we didn't find any data, use the default values
r||(t=l.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(t[0]=n[0]),null!=n[1]&&(t[1]=n[1]));var a=l.paddingValue;null==a||null==a[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
t[0]-=l.paddingValue[0]),null==a||null==a[1]||null!=n&&null!=n[1]||(t[1]+=l.paddingValue[1])}else
// Since the override is fully specified, use it
t=n;
// Verify that the extent is valid
return t[0]>t[1]&&(t[1]=t[0]),t},i(e),i}function c(e){/**
	 * Private Functions
	 */
function t(e){a=e}/*
	 * Constructor/initialization method
	 */
function n(e){null!=e&&null!=e.extent&&t(e.extent)}/**
	 * Private variables
	 */
var r={values:function(e){return e.values}},a=o();/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return n.extent=function(e){return arguments.length?(t(e),n):a},n.values=function(e){return arguments.length?(r.values=e,n):r.values},n.getExtent=function(e){var t;
// In case there was no data
return e.forEach(function(e,n){var u=a.getExtent(r.values(e,n));null==t?t=u:(t[0]=Math.min(t[0],u[0]),t[1]=Math.max(t[1],u[1]))}),null==t&&(t=a.getExtent([])),t},n(e),n}function s(e){/**
	 * Private Functions
	 */
function n(e){
// Should probably fire event for new brush state
v=e}function r(){return v&&null!=d}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function a(e){return null!=e&&Array.isArray(e)&&(e=e.map(function(e){return+e})),e}/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function u(e){return(!Array.isArray(e)||2!=e.length||isNaN(e[0])||isNaN(e[1]))&&(e=void 0),e}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function o(e){return function(t){var n=null!=l.event.selection?a(l.event.selection.map(g.invert)):void 0,r=m,u=!((n===r||null!=n&&null!=r&&n[0]===r[0]&&n[1]===r[1])&&p);
// Store the new selection only on the 'end' event
"end"===e&&(
// Reset the selection
m=n,
// Reset the flag
p=!1),
// Suppress event if it's duplicate and programmatic
u&&h.apply(e,this,t)}}function c(e){var t=void 0;return v&&null!=e&&null!=g&&(t=null!=(t=i.brushSelection(e))&&Array.isArray(t)?a(t.map(g.invert)):void 0),t}function s(e,t){var n=null==(t=u(t))||t[0]>=t[1];
// either clear the filter or move it
p=!0,n?d.move(e,void 0):d.move(e,t.map(g))}function f(e){if(null==e)throw new Error("Must provide a brush and a scale");if(null==e.brush)throw new Error("Must provide a brush");if((d=e.brush).on("brush",o("brush")).on("start",o("start")).on("end",o("end")),null==e.scale)throw new Error("Must provide a scale");g=e.scale,null!=e.enabled&&n(e.enabled)}/**
	 * Private variables
	 */
// The brush object
var d,g,h=t.dispatch("brush","start","end"),m=void 0,v=!1,p=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return f.scale=function(e){return arguments.length?(g=e,f):g},f.dispatch=function(){return h},f.brush=function(){return d},f.enabled=function(e){return arguments.length?(n(e),f):r()},f.getSelection=function(e){return c(e)},f.setSelection=function(e,t){return s(e,t)},f(e),f}function f(){/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function e(){
// Try to get the node from the brush group selection
var e=null!=A.g.brush?A.g.brush.node():null;
// Get the current brush selection
return S.getSelection(e)}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function n(e){S.setSelection(A.g.brush,e)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in brush change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function l(e){
// If there was no previous extent, then there is no brush to update
if(null!=e){
// Derive the overall plot extent from the collection of series
var t=k.extent(w.x).getExtent(C);n(null!=t&&Array.isArray(t)&&2==t.length?[Math.max(t[0],e[0]),Math.min(t[1],e[1])]:void 0)}A.g.brush.style("display",S.enabled()?"unset":"none").call(S.brush())}
// Chart create/init method
function f(){}function d(){null!=z.x&&A.g.xAxis.call(z.x),null!=z.y&&A.g.yAxis.call(z.y)}function g(){
// Join
var e=A.g.plots.selectAll(".plot").data(C,y.seriesKey),t=e.enter().append("g").attr("class","plot"),n=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" line"}),r=t.append("g").append("path").attr("class",function(e){return(e.cssClass?e.cssClass:"")+" area"}),a=e.select(".line"),u=e.select(".area");
// Enter + Update
n.merge(a).datum(y.seriesValues).attr("d",M),r.merge(u).datum(y.seriesValues).attr("d",E.y0(V.y.range()[0])),e.exit().remove()}function h(){
// Join
var e=A.g.markers.selectAll(".marker").data(T.values,y.markerValueX),t=e.enter().append("g").attr("class","marker").on("mouseover",function(e,t){B.call("markerMouseover",this,e,t)}).on("mouseout",function(e,t){B.call("markerMouseout",this,e,t)}).on("click",function(e,t){B.call("markerClick",this,e,t)}),n=t.append("line"),r=t.append("text");n.attr("y1",function(e){return V.y.range()[1]}).attr("y2",function(e){return V.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(y.markerValueLabel);
// Enter + Update
var a=e.select("line"),u=e.select("text");n.merge(a).attr("x1",function(e,t){return V.x(y.markerValueX(e,t))}).attr("x2",function(e,t){return V.x(y.markerValueX(e))}),r.merge(u).attr("x",function(e,t){return V.x(y.markerValueX(e))}),
// Exit
e.exit().remove()}var m="timeline_line_"+Date.now(),v={top:10,right:10,bottom:20,left:40},p=100,x=600,y={valueX:function(e){return e[0]},valueY:function(e){return e[1]},markerValueX:function(e){return e[0]},markerLabel:function(e){return e[1]},seriesKey:function(e){return e.key},seriesValues:function(e){return e.values},seriesLabel:function(e){return e.label}},b=Date.now(),w={x:o({defaultValue:[b-3e5,b],getValue:function(e,t){return y.valueX(e,t)}}),y:o({getValue:function(e,t){return y.valueY(e,t)}})},k=c().values(function(e,t){return y.seriesValues(e,t)}),V={x:r.scaleTime(),y:r.scaleLinear()},z={x:u.axisBottom().scale(V.x),y:u.axisLeft().scale(V.y).ticks(3)},A={svg:void 0,g:{container:void 0,plots:void 0,xAxis:void 0,yAxis:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,markerClipPath:void 0},M=a.line();M.x(function(e,t){return V.x(y.valueX(e,t))}),M.y(function(e,t){return V.y(y.valueY(e,t))});
// Area generator for the plot
var E=a.area();E.x(function(e,t){return V.x(y.valueX(e,t))}),E.y1(function(e,t){return V.y(y.valueY(e,t))});
// Brush Management
var S=s({brush:i.brushX(),scale:V.x});S.dispatch().on("end",function(){B.call("brushend",this,e())}).on("start",function(){B.call("brushstart",this,e())}).on("brush",function(){B.call("brush",this,e())});
// The dispatch object and all events
var B=t.dispatch("brush","brushstart","brushend","markerClick","markerMouseover","markerMouseout"),C=[],T={values:[]};/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return f.init=function(e){
// Create a container div
A.div=e.append("div").attr("class","sentio timeline"),
// Create the SVG element
A.svg=A.div.append("svg");
// Add the defs and add the clip path definition
var t=A.svg.append("defs");
// Append a container for everything
// Append the path group (which will have the clip path and the line path
// Add the brush element
// Append a group for the markers
// Append groups for the axes
return A.plotClipPath=t.append("clipPath").attr("id","plot_"+m).append("rect"),A.markerClipPath=t.append("clipPath").attr("id","marker_"+m).append("rect"),A.g.container=A.svg.append("g"),A.g.plots=A.g.container.append("g").attr("class","plots").attr("clip-path","url(#plot_"+m+")"),A.g.brush=A.g.container.append("g").attr("class","x brush").attr("clip-path","url(#marker_"+m+")"),A.g.markers=A.g.container.append("g").attr("class","markers").attr("clip-path","url(#marker_"+m+")"),A.g.xAxis=A.g.container.append("g").attr("class","x axis"),A.g.yAxis=A.g.container.append("g").attr("class","y axis"),f.resize(),f},f.data=function(e){return arguments.length?(C=null!=e?e:[],f):C},f.markers=function(e){return arguments.length?(T.values=null!=e?e:[],f):T.values},f.resize=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Set up the scales
// Append the clip path
// Now update the size of the svg pane
// Update the positions of the axes
// update the margins on the main draw group
// Update the size of the brush
return V.x.range([0,Math.max(0,x-v.left-v.right)]),V.y.range([Math.max(0,p-v.top-v.bottom),0]),A.plotClipPath.attr("transform","translate(0, -"+v.top+")").attr("width",Math.max(0,x-v.left-v.right)).attr("height",Math.max(0,p-v.bottom)),A.markerClipPath.attr("transform","translate(0, -"+v.top+")").attr("width",Math.max(0,x-v.left-v.right)).attr("height",Math.max(0,p-v.bottom)),A.svg.attr("width",x).attr("height",p),A.g.xAxis.attr("transform","translate(0,"+V.y.range()[0]+")"),A.g.yAxis.attr("class","y axis"),A.g.container.attr("transform","translate("+v.left+","+v.top+")"),A.g.brush.selectAll("rect").attr("y",0).attr("x",0).attr("height",x-v.left-v.right).attr("height",p-v.top-v.bottom+4),S.brush().extent([[0,-1],[x-v.left-v.right,p-v.top-v.bottom+2]]),l(t),f},f.redraw=function(){
// Need to grab the brush extent before we change anything
var t=e();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
// Update the plot elements
return V.x.domain(k.extent(w.x).getExtent(C)),V.y.domain(k.extent(w.y).getExtent(C)),d(),g(),h(),l(t),f},f.width=function(e){return arguments.length?(x=e,f):x},f.height=function(e){return arguments.length?(p=e,f):p},f.margin=function(e){return arguments.length?(v=e,f):v},f.curve=function(e){return arguments.length?(M.curve(e),E.curve(e),f):M.curve()},f.xAxis=function(e){return arguments.length?(z.x=e,f):z.x},f.yAxis=function(e){return arguments.length?(z.y=e,f):z.y},f.xScale=function(e){return arguments.length?(V.x=e,null!=z.x&&z.x.scale(e),null!=S&&S.scale(e),f):V.x},f.yScale=function(e){return arguments.length?(V.y=e,null!=z.y&&z.y.scale(e),f):V.y},f.xValue=function(e){return arguments.length?(y.valueX=e,f):y.valueX},f.yValue=function(e){return arguments.length?(y.valueY=e,f):y.valueY},f.yExtent=function(e){return arguments.length?(w.y=e,f):w.y},f.xExtent=function(e){return arguments.length?(w.x=e,f):w.x},f.seriesKey=function(e){return arguments.length?(y.seriesKey=e,f):y.seriesKey},f.seriesLabel=function(e){return arguments.length?(y.seriesLabel=e,f):y.seriesLabel},f.seriesValues=function(e){return arguments.length?(y.seriesValues=e,f):y.seriesValues},f.markerXValue=function(e){return arguments.length?(y.markerValueX=e,f):y.markerValueX},f.markerLabel=function(e){return arguments.length?(y.markerValueLabel=e,f):y.markerValueLabel},f.dispatch=function(e){return arguments.length?f:B},f.brush=function(e){return arguments.length?(S.enabled(e),f):S.enabled()},f.setBrush=function(e){return n(e),f},f.getBrush=function(){return e()},f}function d(e){/**
	 * Private Functions
	 */
// Get the index given the value
function t(e){return null==l.size||null==l.lwm?0:Math.floor((e-l.lwm)/l.size)}function n(){l.hwm=l.lwm+l.count*l.size}function r(){
// drop stuff below the lwm
for(var e,t=s;c.length>0&&c[0][0]<l.lwm;)e=c.shift(),s-=o.countBin(e);
// drop stuff above the hwm
for(;c.length>0&&c[c.length-1][0]>=l.hwm;)e=c.pop(),s-=o.countBin(e);
// if we emptied the array, add an element for the lwm
0===c.length&&c.push([l.lwm,o.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=c[0][0]-l.size;n>=l.lwm;n-=l.size)c.unshift([n,o.createSeed()]);
// pad above the hwm
for(;c[c.length-1][0]<l.hwm-l.size;)c.push([c[c.length-1][0]+l.size,o.createSeed()]);o.afterUpdate&&o.afterUpdate.call(i,c,s,t)}function a(e){var n=s;e.forEach(function(e,n){var r=t(o.getKey(e,n));if(r>=0&&r<c.length){var a=o.getValue(e,n),u=o.countBin(c[r]);o.updateBin.call(i,c[r],a,n),s+=o.countBin(c[r])-u}}),o.afterAdd&&o.afterAdd.call(i,c,s,n)}function u(){c.length=0,s=0}/*
	 * Constructor/initialization method
	 */
function i(e){if(null==e||null==e.size||null==e.count||null==e.lwm)throw new Error("You must provide an initial size, count, and lwm");l.size=Number(e.size),l.count=Number(e.count),l.lwm=Number(e.lwm),null!=e.createSeed&&(o.createSeed=e.createSeed),null!=e.getKey&&(o.getKey=e.getKey),null!=e.getValue&&(o.getValue=e.getValue),null!=e.updateBin&&(o.updateBin=e.updateBin),null!=e.countBin&&(o.countBin=e.countBin),null!=e.afterAdd&&(o.afterAdd=e.afterAdd),null!=e.afterUpdate&&(o.afterUpdate=e.afterUpdate),n(),r()}/**
	 * Private variables
	 */
// Configuration
var l={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},o={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(e){return e},
// The default value function
getValue:function(e){return e},
// The default function for updating a bin given a new value
updateBin:function(e,t){e[1].push(t)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(e){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof e[1]?e[1]:e[1].hasOwnProperty("length")?e[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(e,t,n){},
// The default function to be called after the bins are updated
afterUpdate:function(e,t,n){}},c=[],s=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return i.set=function(e){return u(),r(),a(e),i},i.clear=function(){return u(),r(),i},i.add=function(e){return a(e),i},i.lwm=function(e){if(!arguments.length)return l.lwm;var t=l.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return l.lwm=Number(e),n(),(t-l.lwm)%l.size!=0&&u(),r(),i},i.hwm=function(){return l.hwm},i.getKey=function(e){return arguments.length?(o.getKey=e,u(),r(),i):o.getKey},i.getValue=function(e){return arguments.length?(o.getValue=e,u(),r(),i):o.getValue},i.updateBin=function(e){return arguments.length?(o.updateBin=e,u(),r(),i):o.updateBin},i.createSeed=function(e){return arguments.length?(o.createSeed=e,u(),r(),i):o.createSeed},i.countBin=function(e){return arguments.length?(o.countBin=e,u(),r(),i):o.countBin},i.afterAdd=function(e){return arguments.length?(o.afterAdd=e,i):o.afterAdd},i.afterUpdate=function(e){return arguments.length?(o.afterUpdate=e,i):o.afterUpdate},i.size=function(e){if(!arguments.length)return l.size;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return e!==l.size&&(l.size=e,n(),u(),r()),i},i.count=function(e){if(!arguments.length)return l.count;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return e!==l.count&&(l.count=Math.floor(e),n(),r()),i},i.bins=function(){return c},i.itemCount=function(){return s},i.clearBin=function(e){if(e>=0&&e<c.length){var t=o.countBin(c[e]);return s-=t,c[e][1]=o.createSeed(),t}return 0},i(e),i}e.chartDonut=function(){
// Chart create/init method
function e(e){}/**
	 * Private functions
	 */
function u(){/*
		 * Join the data
		 */
var e=y.gChart.selectAll("path.arc").data(x.pie(b),function(e,t){return v.key(e.data,t)}),t=e.enter().append("path").attr("class","arc").on("mouseover",v.mouseover).on("mouseout",v.mouseout).on("click",v.click).each(function(e){this._current={startAngle:0,endAngle:0}}).merge(e);t.transition().duration(g).attrTween("d",function(e){var t=n.interpolate(this._current,e);return this._current=t(0),function(e){return x.arc(t(e))}}),t.attr("key",function(e,t){return v.key(e.data,t)}).attr("fill",function(e,t){return p.color(v.key(e.data,t))}),/*
		 * Exit
		 */
e.exit().remove()}function i(){var e=h.markSize+h.markMargin;
// Only option is 'center' for now
if("center"===h.position){
// The center position of the chart
var t=f.left+o,n=f.top+o;return"translate("+(t-(null==y.gLegend._maxWidth?0:y.gLegend._maxWidth)/2)+","+(n-(e*b.length+h.markMargin)/2)+")"}}function l(){/*
		 * Join the data
		 */
var e=y.gLegend.selectAll("g.entry").data(b,v.key),t=e.enter().append("g").attr("class","entry").attr("transform",function(e,t){return"translate(0, "+t*(h.markSize+h.markMargin)+")"}).on("mouseover",v.mouseover).on("mouseout",v.mouseout).on("click",v.click),n=t.append("rect").attr("width",h.markSize).attr("height",h.markSize);/*
		 * Enter + Update
		 */
t.append("text").attr("x",h.markSize+h.markMargin).attr("y",h.markSize-h.labelOffset).merge(e.select("text")).text(v.label),n.merge(e.select("rect")).style("fill",function(e,t){return p.color(v.key(e,t))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
t.merge(e).each(function(e,t){
// Reset
y.gLegend._maxWidth=0===t?this.getBBox().width:Math.max(this.getBBox().width,y.gLegend._maxWidth)}),
// Reassert the legend position
y.gLegend.attr("transform",i()),/*
		 * Exit
		 */
e.exit().remove()}
// Chart height/width
var o,c=400,s=400,f={top:2,bottom:2,right:2,left:2},d=.7,g=500,h={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},m=t.dispatch("mouseover","mouseout","click"),v={getEventElement:function(e,t){return null!=e&&null!=e.data?e.data:e},updateActiveElement:function(e,t){var n=y.gLegend.selectAll("g.entry"),r=y.gChart.selectAll("path.arc");if(null!=e){
// Set the highlight on the row
var a=v.key(e,t);n.classed("active",function(e,t){return v.key(e,t)==a}),r.classed("active",function(e,t){return v.key(e.data,t)==a})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(e,t){e=v.getEventElement(e,t),v.updateActiveElement(e,t),m.call("mouseover",this,e,t)},mouseout:function(e,t){e=v.getEventElement(e,t),v.updateActiveElement(),m.call("mouseout",this,e,t)},click:function(e,t){e=v.getEventElement(e,t),m.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},p={color:r.scaleOrdinal(r.schemeCategory10)},x={arc:a.arc().padAngle(.01),pie:a.pie().value(function(e,t){return v.value(e,t)}).sort(null)},y={div:void 0,svg:void 0,gChart:void 0,legend:void 0},b=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return y.div=t.append("div").attr("class","sentio donut"),y.svg=y.div.append("svg"),y.gChart=y.svg.append("g").attr("class","chart"),y.gLegend=y.svg.append("g").attr("class","legend"),e.resize(),e},e.data=function(t){return arguments.length?(b=null!=t?t:[],e):b},e.resize=function(){var t=c-f.right-f.left,n=s-f.top-f.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return o=Math.min(n,t)/2,y.svg.attr("width",c).attr("height",s),y.gChart.attr("transform","translate("+(f.left+o)+","+(f.top+o)+")"),x.arc.innerRadius(o*d).outerRadius(o),y.gLegend.attr("transform",i()),e},e.redraw=function(){return u(),h.enabled&&l(),e},e.width=function(t){return arguments.length?(c=t,e):c},e.height=function(t){return arguments.length?(s=t,e):s},e.innerRadiusRatio=function(t){return arguments.length?(d=t,e):d},e.duration=function(t){return arguments.length?(g=t,e):g},e.key=function(t){return arguments.length?(v.key=t,e):v.key},e.value=function(t){return arguments.length?(v.value=t,e):v.value},e.label=function(t){return arguments.length?(v.label=t,e):v.label},e.colorScale=function(t){return arguments.length?(p.color=t,e):p.color},e.dispatch=function(){return m},e.legend=function(t){return arguments.length?(h=t,e):h},e},e.chartMatrix=function(){
// Chart dimensions
var e=16,n=1,a={top:20,right:2,bottom:2,left:64},i=500,l=t.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),s={updateActiveSeries:function(e,t){var n=h.g.chart.selectAll(".row text");if(null!=e){
// Set the highlight on the row
var r=s.seriesKey(e,t);n.classed("active",function(e,t){return s.seriesKey(e,t)==r})}else
// Now update the style
n.classed("active",!1)},rowMouseover:function(e,t){s.updateActiveSeries(e,t),l.call("rowMouseover",this,e,t)},rowMouseout:function(e,t){s.updateActiveSeries(),l.call("rowMouseout",this,e,t)},rowClick:function(e,t){l.call("rowClick",this,e,t)},cellMouseover:function(e,t){l.call("cellMouseover",this,e,t)},cellMouseout:function(e,t){l.call("cellMouseout",this,e,t)},cellClick:function(e,t){l.call("cellClick",this,e,t)},seriesKey:function(e){return e.key},seriesLabel:function(e){return e.label},seriesValues:function(e){return e.values},key:function(e){return e.key},value:function(e){return e.value}},f={x:o().getValue(function(e,t){return s.key(e,t)}),value:o().getValue(function(e,t){return s.value(e,t)}),multi:c()},d={x:r.scaleLinear(),y:r.scaleOrdinal(),color:r.scaleLinear().range(["#e7e7e7","#008500"])},g={x:u.axisTop().scale(d.x).tickSizeOuter(0).tickSizeInner(2)},h={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},m=[],v=function(){};return v.init=function(e){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return h.div=e.append("div").attr("class","sentio matrix"),h.svg=h.div.append("svg"),h.g.xAxis=h.svg.append("g").attr("class","x axis"),h.g.chart=h.svg.append("g").attr("class","chart"),v.resize(),v},v.data=function(e){return arguments.length?(m=null!=e?e:[],v):m},v.resize=function(){},v.redraw=function(){
// Determine the number of rows to render
var t=m.length,r=[];t>0&&(r=s.seriesValues(m[0]));var u=r.length,l=n+e,o=u*l+n,c=t*l+n;
// scale the svg to the right size
h.svg.attr("width",o+a.left+a.right).attr("height",c+a.top+a.bottom),
// Configure the scales
d.x.domain(f.x.getExtent(r)).range([0,o-n-l]),d.color.domain(f.multi.values(s.seriesValues).extent(f.value).getExtent(m)),
// Draw the x axis
h.g.xAxis.attr("transform","translate("+(a.left+n+e/2)+","+a.top+")"),h.g.xAxis.call(g.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var p=h.g.chart.selectAll("g.row").data(m,s.seriesKey),x=p.enter().append("g");x.style("opacity","0.1").attr("class","row").attr("transform",function(e,t){return"translate("+a.left+","+(a.top+l*t)+")"}).on("mouseover",s.rowMouseover).on("mouseout",s.rowMouseout).on("click",s.rowClick),
// Also must append the label of the row
x.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",n+e/2).attr("dy",".32em"),
// Also must append a line
x.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",n+e/2).attr("y2",n+e/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var y=x.merge(p);y.transition().duration(i).style("opacity","1").attr("transform",function(e,t){return"translate("+a.left+","+(a.top+l*t)+")"}),
// Update the series labels in case they changed
y.select("text.series.label").text(s.seriesLabel),/*
		 * Row Exit
		 */
p.exit().transition().duration(i).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var b=y.selectAll("rect.cell").data(s.seriesValues,s.key);/*
		 * Cell Remove
		 */
return b.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(e,t){return d.color(s.value(e,t))}).attr("x",function(e,t){return d.x(s.key(e,t))+n}).attr("y",n).attr("height",e).attr("width",e).on("mouseover",s.cellMouseover).on("mouseout",s.cellMouseout).on("click",s.cellClick).merge(b).transition().duration(i).style("opacity","1").attr("x",function(e,t){return d.x(s.key(e,t))+n}).style("fill",function(e,t){return d.color(s.value(e,t))}),b.exit().transition().duration(i).attr("width",0).style("opacity","0.1").remove(),v},v.cellSize=function(t){return arguments.length?(e=t,v):e},v.cellMargin=function(e){return arguments.length?(n=e,v):n},v.margin=function(e){return arguments.length?(a=e,v):a},v.duration=function(e){return arguments.length?(i=e,v):i},v.seriesKey=function(e){return arguments.length?(s.seriesKey=e,v):s.seriesKey},v.seriesLabel=function(e){return arguments.length?(s.seriesLabel=e,v):s.seriesLabel},v.seriesValues=function(e){return arguments.length?(s.seriesValues=e,v):s.seriesValues},v.key=function(e){return arguments.length?(s.key=e,v):s.key},v.value=function(e){return arguments.length?(s.value=e,v):s.value},v.colorScale=function(e){return arguments.length?(d.color=e,v):d.color},v.xScale=function(e){return arguments.length?(d.xScale=e,g.x.scale(e),v):d.xScale},v.yScale=function(e){return arguments.length?(d.yScale=e,v):d.yScale},v.xExtent=function(e){return arguments.length?(f.x=e,f.x.getValue(function(t,n){return e(t,n)}),v):f.x},v.valueExtent=function(e){return arguments.length?(f.value=e,f.value.getValue(function(t,n){return e(t,n)}),v):f.value},v.dispatch=function(){return l},v},e.chartTimeline=f,e.chartAutoBrushTimeline=function(){function e(e){var t=e;
// Crop the brush to max extent
// Make a new copy
// Crop the brush using the max extent
return null!=t&&((t=e.slice())[0]=Math.max(t[0],d[0]),t[1]=Math.min(t[1],d[1])),t}/**
	 * Handle a change to the brush (whether from the timeline or manual)
	 * - Crop the brush if necessary based on maxExtent
	 * - Ensure the brush is valid.
	 * - Update the brush and recalculate the extent.
	 *
	 * @param newBrush
	 */
function n(t){
// Ensure the brush is valid
null!=(t=e(t))&&t[1]-t[0]>s?(
// Update the brush
i=t,v.setBrush(t),
// Update the extent as necessary
r(),
// Fire the brush change event
h.call("brushChange",this,t)):
// Don't allow them to apply an invalid brush
v.setBrush(i),m.redraw()}/**
	 * Update the extent
	 */
function r(){var e=a(i);if(e.pan||e.zoom){
// Update the Extent and fire the event
var t=u(i,e);m.xExtent().overrideValue(t),h.call("extentChange",this,t)}}/**
	 * Check to see if the extent needs to change
	 * - Checks boundaries and zoom level
	 * - Returns a status to indicate how the extent needs to change
	 *
	 * @param brush
	 * @returns { pan: boolean, zoom: boolean }
	 */
function a(e){var t={pan:!1,zoom:!1};if(null!=e){var n=m.xScale(),r=n.domain()[0],a=e[0],u=e[1],i=n.domain()[1],l=i-r,o=(u-a)/l,s=(a-r)/l<=c.edgeTrigger&&a>d[0],f=(i-u)/l<=c.edgeTrigger&&u<d[1];
// Should we resize and/or recenter?
t.zoom=o>=c.zoomOutTrigger||o<=c.zoomInTrigger,t.pan=s||f}return t}/**
	 * Given the brush, determine the new xExtent that should be applied
	 * @param brush The brush for which to determine the extent
	 * @param transform What kind of transform we should apply (whether zoom or pan)
	 * @returns {[*,*]}
	 */
function u(e,t){var n=m.xScale().domain()[0],r=e[0],a=e[1],u=m.xScale().domain()[1]-n;
// If we're zooming, change the target width
t.zoom&&(
// Calculate the new width of the extent (and make sure it isn't smaller than the max zoom)
u=Math.max((a-r)/c.zoomTarget,s));
// Determine the current center of the brush
var i=r+(a-r)/2,l=Math.max(i-u/2,d[0]);
// Track how much of the width we successfully applied to the new lower bound
u-=i-l;
// Determine the new upper bound as as much of the width as we can apply above the center
var o=Math.min(i+u,d[1]);
// Track how much of the width we applied to the upper bound
// If newWidthE is greater than zero, it means that clipping kept us from applying
// all of the width, so we should try to apply the rest to the lower bound
return u-=o-i,l=Math.max(l-u,d[0]),[l,o]}var i,l="autobrush_timeline_"+Date.now(),o=Date.now(),c={edgeTrigger:.01,zoomInTrigger:.05,zoomOutTrigger:.8,zoomTarget:.2},s=864e5,d=[o-31536e7,o],g=[o-15552e6,o],h=t.dispatch("extentChange","brushChange"),m=f(),v={element:{},brush:m.brush,dispatch:m.dispatch,init:m.init,resize:m.resize,redraw:m.redraw,setBrush:m.setBrush,xAxis:m.xAxis};
// Set up default look and feel
// Initialization of the timline and auto brush
// Redraw the auto brush
// Resize
// Basic Getters/Setters
// Cannot disable the brush
return m.margin({top:2,right:10,bottom:2,left:10}),m.xAxis().ticks(6),m.yAxis(null),m.init=function(e){
// Initialize the timeline
// Turn on brushing and register for brush events
// Grab and persist some important elements
// Set the initial brush
// Add a clip path for the axis
// Attach the clip path to the axis
return v.init(e),v.brush(!0),v.dispatch().on("brushend.internal",n),v.element.div=e.select("div.sentio.timeline"),null==i&&(i=g,m.setBrush(i)),v.element.axisClipPath=e.select("svg defs").append("clipPath").attr("id","axis_"+l).append("rect"),v.element.div.select("g.x.axis").attr("clip-path","url(#axis_"+l+")"),m.resize(),m},m.redraw=function(){
// Let the timeline redraw like normal
/*
		 * Update the X Axis
		 */
// Set the x Axis ticks to be full height
// Update text position to be on the chart
// Call it to redraw
return v.redraw(),m.xAxis().tickSize(-m.height()+m.margin().top+m.margin().bottom),v.element.div.selectAll("g.x.axis g.tick text").attr("y","3").attr("dy","-0.71em").attr("dx","0.35em").attr("text-anchor","start").attr("pointer-events","none"),null!=m.xAxis()&&v.element.div.select("g.x.axis").call(m.xAxis()),m},m.resize=function(){
// Need to be defensive here since parent init calls resize
if(v.resize(),null!=v.element.axisClipPath){var e=m.margin(),t=m.width(),n=m.height();
// Update the size of the xAxis clip path
v.element.axisClipPath.attr("transform","translate(0, -"+(n+e.top)+")").attr("width",Math.max(0,t-e.left-e.right)).attr("height",Math.max(0,n+e.bottom+e.top))}},m.edgeTrigger=function(e){return arguments.length?(c.edgeTrigger=e,m):c.edgeTrigger},m.zoomInTrigger=function(e){return arguments.length?(c.zoomInTrigger=e,m):c.zoomInTrigger},m.zoomOutTrigger=function(e){return arguments.length?(c.zoomOutTrigger=e,m):c.zoomOutTrigger},m.zoomTarget=function(e){return arguments.length?(c.zoomTarget=e,m):c.zoomTarget},m.maxExtent=function(e){return arguments.length?(d=e,m):d},m.maxZoom=function(e){return arguments.length?(s=e,m):s},m.setBrush=function(e){return n(e),m},m.dispatch=function(){return h},m.rawDispatch=function(){return v.dispatch},m.brush=function(){return!0},m},e.chartRealtimeTimeline=function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function e(){
// If not running, let the loop die
r&&(i.redraw(),
// Schedule the next update
a=window.setTimeout(e,u>0?1e3/u:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var t=0,n=6e4,r=!1,a=null,u=32,i=f();i.yExtent().filter(function(e){var t=i.xValue()(e),n=i.xExtent().getExtent();return t<n[1]&&t>n[0]});/*
	 * Redraw the graphic
	 */
var l=i.redraw;return i.redraw=function(){
// Update the x domain (to the latest time window)
var e=new Date;return i.xExtent().overrideValue([e-t-n,e-t]),l(),i},i.start=function(){if(!r)return r=!0,e(),i},i.stop=function(){return r=!1,null!=a&&window.clearTimeout(a),i},i.restart=function(){return i.stop(),i.start(),i},i.interval=function(e){return arguments.length?(n=e,i):n},i.delay=function(e){return arguments.length?(t=e,i):t},i.fps=function(e){return arguments.length?(u=e,r&&i.restart(),i):u},i},e.chartVerticalBars=function(){
// Chart create/init method
function e(e){}
// Layout properties
var n=100,a=24,u=2,i=500,l=t.dispatch("mouseover","mouseout","click"),c={mouseover:function(e,t){l.call("mouseover",this,e,t)},mouseout:function(e,t){l.call("mouseout",this,e,t)},click:function(e,t){l.call("click",this,e,t)},key:function(e){return e.key},value:function(e){return e.value},label:function(e){return e.key+" ("+e.value+")"}},s={x:r.scaleLinear(),y:r.scaleLinear()},f={width:o({defaultValue:[0,10],getValue:function(e,t){return c.value(e,t)}})},d={div:void 0},g=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return e.init=function(t){
// Create the DIV element
return d.div=t.append("div").attr("class","sentio bars-vertical"),e.resize(),e},e.data=function(t){return arguments.length?(g=null!=t?t:[],e):g},e.resize=function(){
// Set up the x scale (y is fixed)
return s.x.range([0,n]),e},e.redraw=function(){
// Update the x domain
s.x.domain(f.width.getExtent(g)),
// Update the y domain (based on configuration and data)
s.y.domain([0,g.length]),s.y.range([0,(a+u)*g.length]);
// Data Join
var t=d.div.selectAll("div.bar").data(g,c.key),n=t.enter().append("div").attr("class","bar").style("top",s.y.range()[1]-a+"px").style("height",a+"px").on("mouseover",c.mouseover).on("mouseout",c.mouseout).on("click",c.click).style("opacity","0.01"),r=n.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return n.merge(t).transition().duration(i).style("opacity","1").style("width",function(e,t){return s.x(c.value(e,t))+"px"}).style("top",function(e,t){return s.y(t)+"px"}).style("left","0px"),r.merge(t.select("div.bar-label")).html(c.label).style("max-width",s.x.range()[1]-10+"px"),t.exit().transition().duration(i).style("opacity","0.01").style("top",s.y.range()[1]-a+"px").remove(),d.div.style("height",s.y.range()[1]+"px"),e},e.width=function(t){return arguments.length?(n=t,e):n},e.barHeight=function(t){return arguments.length?(a=t,e):a},e.barPadding=function(t){return arguments.length?(u=t,e):u},e.key=function(t){return arguments.length?(c.key=t,e):c.key},e.value=function(t){return arguments.length?(c.value=t,e):c.value},e.label=function(t){return arguments.length?(c.label=t,e):c.label},e.widthExtent=function(t){return arguments.length?(f.width=t,f.width.getValue(function(e,t){return c.value(e,t)}),e):f.width},e.dispatch=function(t){return arguments.length?e:l},e.duration=function(t){return arguments.length?(i=t,e):i},e},e.controllerRealtimeBins=/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function(e){/**
	 * Private Functions
	 */
function t(){
// Assume the hwm is now plus two binSize
var e=Date.now()+2*i.size();
// Trunc the hwm down to a round value based on the binSize
return(e=Math.floor(e/i.size())*i.size())-i.size()*i.count()}function n(){!0===l&&(
// need to update the lwm
i.lwm(t()),window.setTimeout(n,i.size()))}function r(){l||(
// Start the update loop
l=!0,n())}function a(){
// Setting running to false will stop the update loop
l=!1}
// create/init method
function u(e){if(null==e||null==e.binCount||null==e.binSize)throw new Error("You must provide an initial binSize and binCount");o.binSize=Number(e.binSize),o.binCount=Number(e.binCount),null!=e.delay&&(o.delay=Number(e.delay)),(i=d({size:o.binSize,count:o.binCount+2,lwm:0})).lwm(t()),r()}/**
	 * Private variables
	 */
var i,l,o={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return u.model=function(){return i},u.bins=function(){return i.bins()},u.start=function(){return r(),u},u.stop=function(){return a(),u},u.running=function(){return l},u.add=function(e){return i.add(e),u},u.clear=function(){return i.clear(),u},u.binSize=function(e){if(!arguments.length)return o.binSize;if((e=Number(e))<1)throw new Error("Bin size must be a positive integer");return o.binSize=e,i.size(e),i.lwm(t()),u},u.binCount=function(e){if(!arguments.length)return o.binCount;if((e=Number(e))<1)throw new Error("Bin count must be a positive integer");return o.binCount=e,i.count(e+2),i.lwm(t()),u},u(e),u},e.timelineBrush=s,e.modelBins=d,e.modelExtent=o,e.modelMultiExtent=c,Object.defineProperty(e,"__esModule",{value:!0})});