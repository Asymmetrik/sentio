/*! @asymmetrik/sentio - 5.0.0-alpha.18 - Copyright Asymmetrik, Ltd. 2007-2017 - All Rights Reserved. */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("d3-dispatch"),require("d3-interpolate"),require("d3-scale"),require("d3-shape"),require("d3-axis"),require("d3-brush"),require("d3-voronoi"),require("d3-selection")):"function"==typeof define&&define.amd?define(["exports","d3-dispatch","d3-interpolate","d3-scale","d3-shape","d3-axis","d3-brush","d3-voronoi","d3-selection"],e):e(t.sentio={},t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3,t.d3)}(this,function(t,e,n,r,a,i,u,l,o){"use strict";function c(){
// Chart create/init method
function t(t){}function i(){var t=d.markSize+d.markMargin;
// Only option is 'center' for now
if("center"===d.position){
// The center position of the chart
var e=c.left+u,n=c.top+u;return"translate("+(e-(null==v.gLegend._maxWidth?0:v.gLegend._maxWidth)/2)+","+(n-(t*x.length+d.markMargin)/2)+")"}}
// Chart height/width
var u,l=400,o=400,c={top:2,bottom:2,right:2,left:2},s=.7,g=500,d={enabled:!0,markSize:16,markMargin:8,labelOffset:2,position:"center",// only option right now
layout:"vertical"},f=e.dispatch("mouseover","mouseout","click"),h={getEventElement:function(t,e){return null!=t&&null!=t.data?t.data:t},updateActiveElement:function(t,e){var n=v.gLegend.selectAll("g.entry"),r=v.gChart.selectAll("path.arc");if(null!=t){
// Set the highlight on the row
var a=h.key(t,e);n.classed("active",function(t,e){return h.key(t,e)==a}),r.classed("active",function(t,e){return h.key(t.data,e)==a})}else n.classed("active",!1),r.classed("active",!1)},mouseover:function(t,e){t=h.getEventElement(t,e),h.updateActiveElement(t,e),f.call("mouseover",this,t,e)},mouseout:function(t,e){t=h.getEventElement(t,e),h.updateActiveElement(),f.call("mouseout",this,t,e)},click:function(t,e){t=h.getEventElement(t,e),f.call("click",this,t,e)},key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},p={color:r.scaleOrdinal(r.schemeCategory10)},m={arc:a.arc().padAngle(.01),pie:a.pie().value(function(t,e){return h.value(t,e)}).sort(null)},v={div:void 0,svg:void 0,gChart:void 0,legend:void 0},x=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return t.init=function(e){
// Create the DIV element
// Create the svg element
// Create the main chart group
// Create a group for the legend
return v.div=e.append("div").attr("class","sentio donut"),v.svg=v.div.append("svg"),v.gChart=v.svg.append("g").attr("class","chart"),v.gLegend=v.svg.append("g").attr("class","legend"),t.resize(),t},t.data=function(e){return arguments.length?(x=null!=e?e:[],t):x},t.resize=function(){var e=l-c.right-c.left,n=o-c.top-c.bottom;
// The outer radius is half of the lesser of the two (chartWidth/chartHeight)
// Update legend positioning
return u=Math.min(n,e)/2,v.svg.attr("width",l).attr("height",o),v.gChart.attr("transform","translate("+(c.left+u)+","+(c.top+u)+")"),m.arc.innerRadius(u*s).outerRadius(u),v.gLegend.attr("transform",i()),t},t.redraw=function(){/**
	 * Private functions
	 */
return function(){/*
		 * Join the data
		 */
var t=v.gChart.selectAll("path.arc").data(m.pie(x),function(t,e){return h.key(t.data,e)}),e=t.enter().append("path").attr("class","arc").on("mouseover",h.mouseover).on("mouseout",h.mouseout).on("click",h.click).each(function(t){this._current={startAngle:0,endAngle:0}}).merge(t);e.transition().duration(g).attrTween("d",function(t){var e=n.interpolate(this._current,t);return this._current=e(0),function(t){return m.arc(e(t))}}),e.attr("key",function(t,e){return h.key(t.data,e)}).attr("fill",function(t,e){return p.color(h.key(t.data,e))}),/*
		 * Exit
		 */
t.exit().remove()}(),d.enabled&&function(){/*
		 * Join the data
		 */
var t=v.gLegend.selectAll("g.entry").data(x,h.key),e=t.enter().append("g").attr("class","entry").attr("transform",function(t,e){return"translate(0, "+e*(d.markSize+d.markMargin)+")"}).on("mouseover",h.mouseover).on("mouseout",h.mouseout).on("click",h.click),n=e.append("rect").attr("width",d.markSize).attr("height",d.markSize);/*
		 * Enter + Update
		 */
e.append("text").attr("x",d.markSize+d.markMargin).attr("y",d.markSize-d.labelOffset).merge(t.select("text")).text(h.label),n.merge(t.select("rect")).style("fill",function(t,e){return p.color(h.key(t,e))}),
// Position each rect on both enter and update to fully account for changing widths and sizes
e.merge(t).each(function(t,e){
// Reset
v.gLegend._maxWidth=0===e?this.getBBox().width:Math.max(this.getBBox().width,v.gLegend._maxWidth)}),
// Reassert the legend position
v.gLegend.attr("transform",i()),/*
		 * Exit
		 */
t.exit().remove()}(),t},t.width=function(e){return arguments.length?(l=e,t):l},t.height=function(e){return arguments.length?(o=e,t):o},t.innerRadiusRatio=function(e){return arguments.length?(s=e,t):s},t.duration=function(e){return arguments.length?(g=e,t):g},t.key=function(e){return arguments.length?(h.key=e,t):h.key},t.value=function(e){return arguments.length?(h.value=e,t):h.value},t.label=function(e){return arguments.length?(h.label=e,t):h.label},t.colorScale=function(e){return arguments.length?(p.color=e,t):p.color},t.dispatch=function(){return f},t.legend=function(e){return arguments.length?(d=e,t):d},t}function s(t){/**
	 * Private Functions
	 */
function e(t){if(null==t||2!==t.length||isNaN(t[0])||isNaN(t[1])||t[0]>=t[1])throw new Error("Default extent must be a two element ordered array of numbers");l.defaultValue=t}function n(t){if(null!=t&&2!==t.length)throw new Error("Extent override must be a two element array or null/undefined");l.overrideValue=t}function r(t){if(null!=t&&2!==t.length)throw new Error("Extent padding must be a two element array or null/undefined");l.paddingValue=t}function a(t){if("function"!=typeof t)throw new Error("Value getter must be a function");o.getValue=t}function i(t){if("function"!=typeof t)throw new Error("Filter must be a function");o.filter=t}/*
	 * Constructor/initialization method
	 */
function u(t){null!=t&&(null!=t.defaultValue&&e(t.defaultValue),null!=t.overrideValue&&n(t.overrideValue),null!=t.paddingValue&&r(t.paddingValue),null!=t.getValue&&a(t.getValue),null!=t.filter&&i(t.filter))}/**
	 * Private variables
	 */
// Configuration
var l={defaultValue:[0,10],overrideValue:void 0,paddingValue:[0,0]},o={getValue:function(t){return t},filter:function(){return!0}};/**
	 * Public API
	 */
/*
	 * Get/Set the default value for the extent
	 */
/*
	 * Get/Set the override value for the extent
	 */
/*
	 * Get/Set the padding value for the extent
	 */
/*
	 * Get/Set the value accessor for the extent
	 */
/*
	 * Get/Set the filter fn for the extent
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return u.defaultValue=function(t){return arguments.length?(e(t),u):l.defaultValue},u.overrideValue=function(t){return arguments.length?(n(t),u):l.overrideValue},u.paddingValue=function(t){return arguments.length?(r(t),u):l.paddingValue},u.getValue=function(t){return arguments.length?(a(t),u):o.getValue},u.filter=function(t){return arguments.length?(i(t),u):o.filter},u.getExtent=function(t){var e,n=l.overrideValue;
// Check to see if we need to calculate the extent (if override isn't fully specified)
if(null==n||null==n[0]||null==n[1]){
// Since the override isn't complete, we need to calculate the extent
e=[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];var r=!1;null!=t&&
// Iterate over each element of the data
t.forEach(function(t,n){
// If the element passes the filter, then update the extent
if(o.filter(t,n)){r=!0;var a=o.getValue(t,n);e[0]=Math.min(e[0],a),e[1]=Math.max(e[1],a)}}),
// If we didn't find any data, use the default values
r||(e=l.defaultValue),
// Apply the overrides
// - Since we're in this conditional, only one or zero overrides were specified
null!=n&&(null!=n[0]&&(e[0]=n[0]),null!=n[1]&&(e[1]=n[1]));var a=l.paddingValue;null==a||null==a[0]||null!=n&&null!=n[0]||(
// Only apply the padding if there was no override
e[0]-=l.paddingValue[0]),null==a||null==a[1]||null!=n&&null!=n[1]||(e[1]+=l.paddingValue[1])}else
// Since the override is fully specified, use it
e=n;
// Verify that the extent is valid
return e[0]>e[1]&&(e[1]=e[0]),e},u(t),u}function g(t){function e(t){r=t}/*
	 * Constructor/initialization method
	 */
function n(t){null!=t&&(null!=t.extent&&e(t.extent),null!=t.series&&function(t){a=t}(t.series))}var r=s(),a=[];/**
	 * Public API
	 */
/*
	 * Get/Set the extent to use
	 */
/*
	 * Get/Set the values accessor function
	 */
/*
	 * Calculate the extent given some data.
	 * - Default values are used in the absence of data
	 * - Override values are used to clamp or extend the extent
	 */
// Initialize the model
return n.extent=function(t){return arguments.length?(e(t),n):r},n.series=function(t){return arguments.length?(a=t,n):a},n.getExtent=function(t){var e;
// Iterate over each series
// In case there was no data
return a.forEach(function(n){
// Update the extent to set the value getter
r.getValue(n.getValue);
// Get the extent of the current series
var a=r.getExtent(t);
// If it's null, use the new extent
null==e?e=a:(e[0]=Math.min(e[0],a[0]),e[1]=Math.max(e[1],a[1]))}),null==e&&(e=r.getExtent([])),e},n(t),n}function d(t){/**
	 * Private Functions
	 */
function n(t){
// Should probably fire event for new brush state
f=t}/**
	 * Convert a brushSelection to ms epoch time
	 * @param brushSelection Null, or an array brushSelection that may be in either Date or ms epoch
	 *        time representation
	 * @returns {*} Brush selection in ms epoch time form
	 */
function r(t){return null!=t&&Array.isArray(t)&&(t=t.map(function(t){return+t})),t}/**
	 * Wrapper for event handler to filter out duplicate events
	 * @param eventType
	 * @returns {Function}
	 */
function a(t){return function(e){var n=null!=o.event.selection?r(o.event.selection.map(s.invert)):void 0,a=d,i=!((n===a||null!=n&&null!=a&&n[0]===a[0]&&n[1]===a[1])&&h);
// Store the new selection only on the 'end' event
"end"===t&&(
// Reset the selection
d=n,
// Reset the flag
h=!1),
// Suppress event if it's duplicate and programmatic
i&&g.apply(t,this,e)}}function i(t,e){var n=null==(e=/**
	 * Clean selection to make sure it's valid or set it to undefined if it's invalid
	 * @param selection
	 * @returns {*}
	 */
function(t){return(!Array.isArray(t)||2!=t.length||isNaN(t[0])||isNaN(t[1]))&&(t=void 0),t}(e))||e[0]>=e[1];
// either clear the filter or move it
h=!0,n?c.move(t,void 0):c.move(t,e.map(s))}function l(t){if(null==t)throw new Error("Must provide a brush and a scale");if(null==t.brush)throw new Error("Must provide a brush");if((c=t.brush).on("brush",a("brush")).on("start",a("start")).on("end",a("end")),null==t.scale)throw new Error("Must provide a scale");s=t.scale,null!=t.enabled&&n(t.enabled)}/**
	 * Private variables
	 */
// The brush object
var c,s,g=e.dispatch("brush","start","end"),d=void 0,f=!1,h=!1;/**
	 * Public API
	 */
// Get/Set enabled state
// Initialize the model
return l.scale=function(t){return arguments.length?(s=t,l):s},l.dispatch=function(){return g},l.brush=function(){return c},l.enabled=function(t){return arguments.length?(n(t),l):f&&null!=c},l.getBrushSelection=function(t){return u.brushSelection(t)},l.getSelection=function(t){return function(t){var e=void 0;return f&&null!=t&&null!=s&&(e=null!=(e=u.brushSelection(t))&&Array.isArray(e)?r(e.map(s.invert)):void 0),e}(t)},l.setSelection=function(t,e){return i(t,e)},l(t),l}/**
 *
 *  data: []
 *  series: [ {label, x, y} ]
 *
 */
function f(){function t(t){if(null!=t){var e=_.g.points.selectAll("circle").data(L.map(function(e){return{x:z.valueX(t.data),y:e.getValue(t.data),category:e.category}})),n=e.enter().append("circle"),r=e.selectAll("circle");n.merge(r).attr("class",function(t,e){return t.category}).attr("cx",function(t,e){return M.x(t.x)}).attr("cy",function(t,e){return M.y(t.y)}).attr("r",3)}else _.g.points.selectAll("circle").remove()}function n(e,n){var r=w.pointEvents;"value"===r?e.data:"values"===r?t(e.data):"series"===r&&e.data,N.call("pointMouseover",this,e.data,n)}function o(e,n){var r=w.pointEvents;"value"===r||"values"===r&&t(),N.call("pointMouseout",this,e.data,n)}function c(t,e){N.call("pointClick",this,t.data,e)}/**
	 * Get the current brush state in terms of the x data domain, in ms epoch time
	 */
function f(){
// Try to get the node from the brush group selection
var t=null!=_.g.brush?_.g.brush.node():null;
// Get the current brush selection
return G.getSelection(t)}function h(t){var e=M.y.range()[0]/2+6;return"M4 "+e+" c 0 4, "+-8+" 4, "+-8+" 0 v0 "+-12+" c 0 "+-4+", 8 "+-4+", 8 0 Z M0 "+e+" v"+-12}/**
	 * Set the current brush state in terms of the x data domain
	 * @param v The new value of the brush
	 *
	 */
function p(t){G.setSelection(_.g.brush,t)}/**
	 * Update the state of the brush (as part of redrawing everything)
	 *
	 * The purpose of this function is to update the state of the brush to reflect changes
	 * to the rest of the chart as part of a normal update/redraw cycle. When the x extent
	 * changes, the brush needs to move to stay correctly aligned with the x axis. Normally,
	 * we are only updating the drawn position of the brush, so the brushSelection doesn't
	 * actually change. However, if the change results in the brush extending partially or
	 * wholly outside of the x extent, we might have to clip or clear the brush, which will
	 * result in brush change events being propagated.
	 *
	 * @param previousExtent The previous state of the brush extent. Must be provided to
	 *        accurately determine the extent of the brush in terms of the x data domain
	 */
function m(t){
// If there was no previous extent, then there is no brush to update
if(null!=t){
// Derive the overall plot extent from the collection of series
var e=E.x.getExtent(P);if(null!=e&&Array.isArray(e)&&2==e.length){p([Math.max(e[0],t[0]),Math.min(e[1],t[1])])}else
// There is no plot/data so just clear the brush
p(void 0)}_.g.brush.style("display",G.enabled()?"unset":"none").call(G.brush());/*
		 * Update the clip path for the brush plot
		 */
var n=function(){
// Try to get the node from the brush group selection
var t=null!=_.g.brush?_.g.brush.node():null;
// Get the current brush selection
return G.getBrushSelection(t)}();if(null!=n){var r=M.y.range()[0];
// Update the brush clip path
_.plotBrushClipPath.attr("transform","translate("+n[0]+", -1)").attr("width",Math.max(0,n[1]-n[0])).attr("height",Math.max(0,r)+2);
// Create/Update the handles
var a=_.g.brush.selectAll(".resize-handle").data([{type:"w"},{type:"e"}]),i=a.enter().append("g").attr("class","resize-handle").attr("cursor","ew-resize");i.append("path").attr("class","handle-line"),i.append("path").attr("class","handle-grip");var u=i.merge(a);u.attr("transform",function(t,e){return"translate("+n[e]+", 0)"}),u.select(".handle-line").attr("d","M0 "+r+" v"+-r),u.select(".handle-grip").attr("d",h)}else
// Empty the clip path
_.plotBrushClipPath.attr("transform","translate(-1, -1)").attr("width",0).attr("height",0),
// Remove the handles
_.g.brush.selectAll(".resize-handle").remove()}
// Chart create/init method
function v(){}var x="timeline_line_"+Date.now(),y={top:10,right:10,bottom:20,left:40},b=100,k=600,w={xGrid:!1,yGrid:!1,pointEvents:!1},z={valueX:function(t){return t[0]},markerValueX:function(t){return t[0]},markerLabel:function(t){return t[1]},pointRadius:function(){return 2}},A=Date.now(),E={x:s({defaultValue:[A-3e5,A],getValue:function(t,e){return z.valueX(t,e)}}),y:s({filter:function(t,e){var n=z.valueX(t,e);return n>=M.x.domain()[0]&&n<=M.x.domain()[1]}})},V=g(),M={x:r.scaleTime(),y:r.scaleLinear()},S={x:i.axisBottom().scale(M.x),y:i.axisLeft().ticks(3).scale(M.y),xGrid:i.axisBottom().tickFormat("").tickSizeOuter(0).scale(M.x),yGrid:i.axisLeft().tickFormat("").tickSizeOuter(0).ticks(3).scale(M.y)},B=a.line().x(function(t,e){return M.x(z.valueX(t,e))}),T=a.area().x(function(t,e){return M.x(z.valueX(t,e))}),C=l.voronoi().x(function(t,e){return M.x(t.x,e)}).y(function(t,e){return M.y(t.y,e)}),G=d({brush:u.brushX(),scale:M.x});G.dispatch().on("end",function(){m(),N.call("brushEnd",this,f())}).on("start",function(){m(),N.call("brushStart",this,f())}).on("brush",function(){m(),N.call("brush",this,f())});
// The dispatch object and all events
var N=e.dispatch("brush","brushStart","brushEnd","markerClick","markerMouseover","markerMouseout","pointMouseover","pointMouseout","pointClick"),_={svg:void 0,g:{container:void 0,plots:void 0,plotBrushes:void 0,points:void 0,voronoi:void 0,xAxis:void 0,yAxis:void 0,xAxisGrid:void 0,yAxisGrid:void 0,markers:void 0,brush:void 0},plotClipPath:void 0,plotBrushClipPath:void 0,markerClipPath:void 0},P=[],L=[],I=[];/**
	 * Initialize the chart (only called once). Performs all initial chart creation/setup
	 *
	 * @param container The container element to which to apply the chart
	 * @returns {_instance} Instance of the chart
	 */
/*
	 * Set the data to drive the chart
	 */
/*
	 * Define the series to show on the chart
	 */
/*
	 * Set the markers data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return v.init=function(t){
// Create a container div
_.div=t.append("div").attr("class","sentio timeline"),
// Create the SVG element
_.svg=_.div.append("svg");
// Add the defs and add the clip path definition
var e=_.svg.append("defs");
// Append a container for everything
// Append the grid
// Append the path group (which will have the clip path and the line path
// Append the path group (which will have the clip path and the line path
// Append groups for the axes
// Append a group for the voronoi and the points
// Append a group for the markers
// Add the brush element
return _.plotBrushClipPath=e.append("clipPath").attr("id","plotBrush_"+x).append("rect"),_.plotClipPath=e.append("clipPath").attr("id","plot_"+x).append("rect"),_.markerClipPath=e.append("clipPath").attr("id","marker_"+x).append("rect"),_.g.container=_.svg.append("g"),_.g.grid=_.g.container.append("g").attr("class","grid"),_.g.xAxisGrid=_.g.grid.append("g").attr("class","x"),_.g.yAxisGrid=_.g.grid.append("g").attr("class","y"),_.g.plots=_.g.container.append("g").attr("class","plots"),_.g.plots.attr("clip-path","url(#plot_"+x+")"),_.g.plotBrushes=_.g.container.append("g").attr("class","plot-brushes"),_.g.plotBrushes.attr("clip-path","url(#plotBrush_"+x+")"),_.g.plotBrushHandles=_.g.container.append("g").attr("class","plot-brush-handles"),_.g.axes=_.g.container.append("g").attr("class","axis"),_.g.xAxis=_.g.axes.append("g").attr("class","x"),_.g.yAxis=_.g.axes.append("g").attr("class","y"),_.g.points=_.g.container.append("g").attr("class","points"),_.g.points.attr("clip-path","url(#marker_"+x+")"),_.g.voronoi=_.g.container.append("g").attr("class","voronoi"),_.g.markers=_.g.container.append("g").attr("class","markers"),_.g.markers.attr("clip-path","url(#marker_"+x+")"),_.g.brush=_.g.container.append("g").attr("class","x brush"),v.resize(),v},v.data=function(t){return arguments.length?(P=null!=t?t:[],v):P},v.series=function(t){return arguments.length?(L=null!=t?t:[],v):L},v.markers=function(t){return arguments.length?(I=null!=t?t:[],v):I},v.resize=function(){
// Need to grab the brush extent before we change anything
var t=f();
// Resize the SVG Pane
// Update the margins on the main draw group
// Resize Scales
/**
		 * Resize clip paths
		 */
// Plot Brush clip path is only the plot pane
// Plot clip path is only the plot pane
// Marker clip path includes top margin by default
// Resize the clip extent of the plot
/**
		 * Update axis and grids
		 */
// Reset axis and grid positions
// Resize the x grid ticks
// Resize the y grid ticks
/**
		 * Update the brush
		 */
// Resize and position the brush g element
// Resize the brush
return _.svg.attr("width",k).attr("height",b),_.g.container.attr("transform","translate("+y.left+","+y.top+")"),M.x.range([0,Math.max(0,k-y.left-y.right)]),M.y.range([Math.max(0,b-y.top-y.bottom),0]),_.plotBrushClipPath.attr("transform","translate(-1, -1)").attr("width",Math.max(0,M.x.range()[1])+2).attr("height",Math.max(0,M.y.range()[0])+2),_.plotClipPath.attr("transform","translate(-1, -1)").attr("width",Math.max(0,M.x.range()[1])+2).attr("height",Math.max(0,M.y.range()[0])+2),_.markerClipPath.attr("transform","translate(0, -"+y.top+")").attr("width",Math.max(0,k-y.left-y.right)).attr("height",Math.max(0,b-y.bottom)),C.extent([[0,0],[k-y.left-y.right,b-y.top-y.bottom]]),_.g.xAxis.attr("transform","translate(0,"+M.y.range()[0]+")"),_.g.xAxisGrid.attr("transform","translate(0,"+M.y.range()[0]+")"),w.xGrid?S.xGrid.tickSizeInner(-(b-y.top-y.bottom)):S.xGrid.tickSizeInner(0),w.yGrid?S.yGrid.tickSizeInner(-(k-y.left-y.right)):S.yGrid.tickSizeInner(0),_.g.brush.selectAll("rect").attr("y",-1).attr("x",0).attr("width",M.x.range()[1]).attr("height",M.y.range()[0]+2),G.brush().extent([[0,0],[M.x.range()[1],M.y.range()[0]+2]]),m(t),v},v.redraw=function(){
// Need to grab the brush extent before we change anything
var t=f();
// Update the x domain (to the latest time window)
// Update the y domain (based on configuration and data)
return M.x.domain(E.x.getExtent(P)),M.y.domain(V.extent(E.y).series(L).getExtent(P)),null!=S.x&&_.g.xAxis.call(S.x),null!=S.xGrid&&w.xGrid&&_.g.xAxisGrid.call(S.xGrid),null!=S.y&&_.g.yAxis.call(S.y),null!=S.yGrid&&w.yGrid&&_.g.yAxisGrid.call(S.yGrid),function(){
// Join
var t=_.g.plots.selectAll(".plot").data(L,function(t){return t.key}),e=t.enter().append("g").attr("class","plot"),r=e.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" line"}),a=e.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" area"}),i=t.select(".line"),u=t.select(".area");if(
// Enter + Update
r.merge(i).attr("d",function(t){return B.y(function(e,n){return M.y(t.getValue(e,n))})(P)}),a.merge(u).attr("d",function(t){return T.y0(M.y.range()[0]).y1(function(e,n){return M.y(t.getValue(e,n))})(P)}),
// Remove the previous voronoi
_.g.voronoi.selectAll("path").remove(),w.pointEvents){
// check range against width
var l=M.x.domain(),s=/**
	 * Explodes the data into an array with one point per unique point
	 * in the data (according to the series).
	 *
	 * I.e.,
	 *
	 * data: [{ x: 0, y1: 1, y2: 2}]
	 * series: [
	 *     { key: 's1', getValue: function(d) { return d.y1; } },
	 *     { key: 's2', getValue: function(d) { return d.y2; } }
	 * ]
	 *
	 * ==>
	 *
	 * [
	 *     { x: 0, y: 1, series: { key: 's1', ... }, data: { x: 0, y1: 1, y2: 2 },
	 *     { x: 0, y: 2, series: { key: 's2', ... }, data: { x: 0, y1: 1, y2: 2 },
	 * ]
	 *
	 * @param series
	 * @param data
	 */
function(t,e,n){var r=[];
// Loop over each series
return t.forEach(function(t,a){
// Convert the data to x/y series
r=r.concat(e.map(function(e,r){return{x:n(e,r),y:t.getValue(e,r),series:t,data:e}}))}),r}(L,P,z.valueX).filter(function(t){
// Filter out points that are outside of the extent
return l[0]<=t.x&&t.x<=l[1]});
// Filter out paths that are null
s=C.polygons(s).filter(function(t){return null!=t}),
// Draw the voronoi overlay polygons
_.g.voronoi.selectAll("path").data(s).enter().append("path").attr("d",function(t){return null!=t?"M"+t.join("L")+"Z":null}).on("mouseover",n).on("mouseout",o).on("click",c)}t.exit().remove()}(),function(){
// Join
var t=_.g.plotBrushes.selectAll(".plot-brush").data(G.enabled()?L:[],function(t){return t.key}),e=t.enter().append("g").attr("class","plot plot-brush"),n=e.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" line"}),r=e.append("g").append("path").attr("class",function(t){return(t.category?t.category:"")+" area"}),a=t.select(".line"),i=t.select(".area");
// Enter + Update
n.merge(a).attr("d",function(t){return B.y(function(e,n){return M.y(t.getValue(e,n))})(P)}),r.merge(i).attr("d",function(t){return T.y0(M.y.range()[0]).y1(function(e,n){return M.y(t.getValue(e,n))})(P)}),t.exit().remove()}(),function(){
// Join
var t=_.g.markers.selectAll(".marker").data(I,z.markerValueX),e=t.enter().append("g").attr("class","marker").on("mouseover",function(t,e){N.call("markerMouseover",this,t,e)}).on("mouseout",function(t,e){N.call("markerMouseout",this,t,e)}).on("click",function(t,e){N.call("markerClick",this,t,e)}),n=e.append("line"),r=e.append("text");n.attr("y1",function(t){return M.y.range()[1]}).attr("y2",function(t){return M.y.range()[0]}),r.attr("dy","0em").attr("y",-3).attr("text-anchor","middle").text(z.markerLabel);
// Enter + Update
var a=t.select("line"),i=t.select("text");n.merge(a).attr("x1",function(t,e){return M.x(z.markerValueX(t,e))}).attr("x2",function(t,e){return M.x(z.markerValueX(t))}),r.merge(i).attr("x",function(t,e){return M.x(z.markerValueX(t))}),
// Exit
t.exit().remove()}(),m(t),v},v.width=function(t){return arguments.length?(k=t,v):k},v.height=function(t){return arguments.length?(b=t,v):b},v.margin=function(t){return arguments.length?(y=t,v):y},v.showXGrid=function(t){return arguments.length?(w.xGrid=t,v):w.xGrid},v.showYGrid=function(t){return arguments.length?(w.yGrid=t,v):w.yGrid},v.showGrid=function(t){return w.xGrid=w.yGrid=t,v},v.pointEvents=function(t){return arguments.length?(w.pointEvents=t,v):w.pointEvents},v.curve=function(t){return arguments.length?(B.curve(t),T.curve(t),v):B.curve()},v.xAxis=function(t){return arguments.length?(S.x=t,v):S.x},v.xGridAxis=function(t){return arguments.length?(S.xGrid=t,v):S.xGrid},v.yAxis=function(t){return arguments.length?(S.y=t,v):S.y},v.yGridAxis=function(t){return arguments.length?(S.yGrid=t,v):S.yGrid},v.xScale=function(t){return arguments.length?(M.x=t,null!=S.x&&S.x.scale(t),null!=S.xGrid&&S.xGrid.scale(t),null!=G&&G.scale(t),v):M.x},v.yScale=function(t){return arguments.length?(M.y=t,null!=S.y&&S.y.scale(t),null!=S.yGrid&&S.yGrid.scale(t),v):M.y},v.xValue=function(t){return arguments.length?(z.valueX=t,v):z.valueX},v.yExtent=function(t){return arguments.length?(E.y=t,v):E.y},v.xExtent=function(t){return arguments.length?(E.x=t,v):E.x},v.markerXValue=function(t){return arguments.length?(z.markerValueX=t,v):z.markerValueX},v.markerLabel=function(t){return arguments.length?(z.markerLabel=t,v):z.markerLabel},v.dispatch=function(t){return arguments.length?v:N},v.brush=function(t){return arguments.length?(G.enabled(t),v):G.enabled()},v.setBrush=function(t){return p(t),v},v.getBrush=function(){return f()},v}function h(){/**
	 * Handle a change to the brush (whether from the timeline or manual)
	 * - Crop the brush if necessary based on maxExtent
	 * - Ensure the brush is valid.
	 * - Update the brush and recalculate the extent.
	 *
	 * @param newBrush
	 */
function t(t){
// Ensure the brush is valid
if(t=function(t){var e=t;
// Crop the brush to max extent
if(null!=e){
// Crop the brush using the max extent
(
// Make a new copy
e=t.slice())[0]=Math.max(e[0],l[0]),e[1]=Math.min(e[1],l[1]);
// What brush width do we need to obtain
var r=e[1]-e[0],a=r;null!=c&&(a=Math.min(r,c)),null!=o&&(a=Math.max(a,o)),
// If the width has to change
a!=r&&(e[0]===n[0]?
// We should move the upper bound
e[1]=e[0]+a:e[1]===n[1]&&(
// We should move the lower bound
e[0]=e[1]-a))}return e}(t),function(t){return null!=t&&(null==c||t[1]-t[0]<=c)&&(null==o||t[1]-t[0]>=o)}(t)){var e=null==n||n[0]!=t[0]||n[1]!=t[1];
// Update the brush
n=t,
// Update the extent as necessary
/**
	 * Update the extent
	 */
function(){var t=/**
	 * Check to see if the extent needs to change
	 * - Checks boundaries and zoom level
	 * - Returns a status to indicate how the extent needs to change
	 *
	 * @param brush
	 * @returns { pan: boolean, zoom: boolean }
	 */
function(t){var e={pan:!1,zoom:!1};if(null!=t){var n=d.xScale(),r=n.domain()[0],a=t[0],u=t[1],o=n.domain()[1],c=o-r,s=(u-a)/c,g=a<r||(a-r)/c<=i.edgeTrigger&&a>l[0],f=u>o||(o-u)/c<=i.edgeTrigger&&u<l[1];
// Should we resize and/or recenter?
e.zoom=s>=i.zoomOutTrigger||s<=i.zoomInTrigger,e.pan=g||f}return e}(n);if(t.pan||t.zoom){
// Update the Extent and fire the event
var e=/**
	 * Given the brush, determine the new xExtent that should be applied
	 * @param brush The brush for which to determine the extent
	 * @param transform What kind of transform we should apply (whether zoom or pan)
	 * @returns {[*,*]}
	 */
function(t,e){var n=d.xScale().domain()[0],r=t[0],a=t[1],o=d.xScale().domain()[1]-n;
// If we're zooming, change the target width
e.zoom&&(
// Calculate the new width of the extent (and make sure it isn't smaller than the max zoom)
o=Math.max((a-r)/i.zoomTarget,u));
// Determine the current center of the brush
var c=r+(a-r)/2,s=Math.max(c-o/2,l[0]);
// Track how much of the width we successfully applied to the new lower bound
o-=c-s;
// Determine the new upper bound as as much of the width as we can apply above the center
var g=Math.min(c+o,l[1]);
// Track how much of the width we applied to the upper bound
// If newWidthE is greater than zero, it means that clipping kept us from applying
// all of the width, so we should try to apply the rest to the lower bound
return o-=g-c,s=Math.max(s-o,l[0]),[s,g]}(n,t);d.xExtent().overrideValue(e),g.call("extentChange",this,e)}}(),
// Set the brush on the base timeline
h.setBrush(n),
// Only fire the brush event if it actually changed
e&&g.call("brushChange",this,n)}else
// Don't allow them to apply an invalid brush
h.setBrush(n)}var n,r="autobrush_timeline_"+Date.now(),a=Date.now(),i={edgeTrigger:.01,zoomInTrigger:.05,zoomOutTrigger:.8,zoomTarget:.2},u=6e4,l=[a-31536e9,a],o=1e3,c=void 0,s=[a-15552e6,a],g=e.dispatch("extentChange","brushChange"),d=f();
// Turn on brushing and register for brush events
d.brush(!0),d.dispatch().on("brushEnd.internal",function(e){t(e),d.redraw()}),
// Turn off pointer events by default
d.pointEvents(!1);var h={element:{g:{container:void 0},axisClipPath:void 0},brush:d.brush,dispatch:d.dispatch,init:d.init,resize:d.resize,redraw:d.redraw,setBrush:d.setBrush,xAxis:d.xAxis};
// Set up default look and feel
// Initialization of the timeline and auto brush
// Redraw the auto brush
// Resize
// Basic Getters/Setters
// Cannot disable the brush
return d.margin({top:2,right:10,bottom:2,left:10}),d.xAxis().ticks(5),d.yAxis(null),d.init=function(e){
// Store the container
// Initialize the timeline
// Set the initial brush
// Add a clip path for the axis
// Attach the clip path to the axis
return h.element.g.container=e,h.init(e),null==n&&t(s),h.element.axisClipPath=e.select("svg defs").append("clipPath").attr("id","axis_"+r).append("rect"),h.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("clip-path","url(#axis_"+r+")"),d.resize(),d},d.redraw=function(){
// Let the timeline redraw like normal
h.redraw(),/*
		 * Update the X Axis
		 */
// Set the x Axis ticks to be full height
d.xAxis().tickSize(-d.height()+d.margin().top+d.margin().bottom);
// Update text position to be on the chart
var t=h.element.g.container.select("div.sentio.timeline").select("g.axis .x").attr("pointer-events","none");
// Set the x Axis ticks to be full height
// Call it to redraw
return t.selectAll("g.tick text").attr("y","3").attr("dy","-0.71em").attr("dx","0.35em").attr("text-anchor","start"),d.xAxis().tickSize(-d.height()+d.margin().top+d.margin().bottom),null!=d.xAxis()&&t.call(d.xAxis()),d},d.resize=function(){
// Need to be defensive here since parent init calls resize
if(h.resize(),null!=h.element.axisClipPath){var t=d.margin(),e=d.width(),n=d.height();
// Update the size of the xAxis clip path
h.element.axisClipPath.attr("transform","translate(0, -"+(n+t.top)+")").attr("width",Math.max(0,e-t.left-t.right+2)).attr("height",Math.max(0,n+t.bottom+t.top))}},d.edgeTrigger=function(t){return arguments.length?(i.edgeTrigger=t,d):i.edgeTrigger},d.zoomInTrigger=function(t){return arguments.length?(i.zoomInTrigger=t,d):i.zoomInTrigger},d.zoomOutTrigger=function(t){return arguments.length?(i.zoomOutTrigger=t,d):i.zoomOutTrigger},d.zoomTarget=function(t){return arguments.length?(i.zoomTarget=t,d):i.zoomTarget},d.maxExtent=function(t){return arguments.length?(l=t,d):l},d.minExtent=function(t){return arguments.length?(u=t,d):u},d.minBrush=function(t){return arguments.length?(o=t,d):o},d.maxBrush=function(t){return arguments.length?(c=t,d):c},d.setBrush=function(e){return t(e),d},d.dispatch=function(){return g},d.timelineDispatch=function(){return h.dispatch},d.brush=function(){return!0},d}/**
 * Binning model for timelines
 *
 * This data model is responsible for subdiving a period of time into an array of sequential bins.
 * As data objects are added to the model, they are aggregated into the bins.
 *
 */
function p(t){function e(){u.hwm=u.lwm+u.count*u.size}function n(){
// drop stuff below the lwm
for(var t,e=c;o.length>0&&o[0][0]<u.lwm;)t=o.shift(),c-=l.countBin(t);
// drop stuff above the hwm
for(;o.length>0&&o[o.length-1][0]>=u.hwm;)t=o.pop(),c-=l.countBin(t);
// if we emptied the array, add an element for the lwm
0===o.length&&o.push([u.lwm,l.createSeed()]);
// fill in any missing values from the lowest bin to the lwm
for(var n=o[0][0]-u.size;n>=u.lwm;n-=u.size)o.unshift([n,l.createSeed()]);
// pad above the hwm
for(;o[o.length-1][0]<u.hwm-u.size;)o.push([o[o.length-1][0]+u.size,l.createSeed()]);l.afterUpdate&&l.afterUpdate.call(i,o,c,e)}function r(t){var e=c;t.forEach(function(t,e){var n=/**
	 * Private Functions
	 */
// Get the index given the value
function(t){return null==u.size||null==u.lwm?0:Math.floor((t-u.lwm)/u.size)}(l.getKey(t,e));if(n>=0&&n<o.length){var r=l.getValue(t,e),a=l.countBin(o[n]);l.updateBin.call(i,o[n],r,e),c+=l.countBin(o[n])-a}}),l.afterAdd&&l.afterAdd.call(i,o,c,e)}function a(){o.length=0,c=0}/*
	 * Constructor/initialization method
	 */
function i(t){if(null==t||null==t.size||null==t.count||null==t.lwm)throw new Error("You must provide an initial size, count, and lwm");u.size=Number(t.size),u.count=Number(t.count),u.lwm=Number(t.lwm),null!=t.createSeed&&(l.createSeed=t.createSeed),null!=t.getKey&&(l.getKey=t.getKey),null!=t.getValue&&(l.getValue=t.getValue),null!=t.updateBin&&(l.updateBin=t.updateBin),null!=t.countBin&&(l.countBin=t.countBin),null!=t.afterAdd&&(l.afterAdd=t.afterAdd),null!=t.afterUpdate&&(l.afterUpdate=t.afterUpdate),e(),n()}/**
	 * Private variables
	 */
// Configuration
var u={
// The number of bins in our model
count:1,
// The size of a bin in key value units
size:void 0,
// The min and max bins
lwm:void 0,hwm:void 0},l={
// The default function for creating the seed value for a bin
createSeed:function(){return[]},
// The default key function
getKey:function(t){return t},
// The default value function
getValue:function(t){return t},
// The default function for updating a bin given a new value
updateBin:function(t,e){t[1].push(e)},
// The default function for counting the contents of the bins (includes code for backward compatibility)
countBin:function(t){
// If the bin contains a number, just return it
// If the bin contains a number, just return it
// If the bin contains an array of data, return the number of items
return"number"==typeof t[1]?t[1]:t[1].hasOwnProperty("length")?t[1].length:0},
// The default function to be called after items are added to the bins
afterAdd:function(t,e,n){},
// The default function to be called after the bins are updated
afterUpdate:function(t,e,n){}},o=[],c=0;/**
	 * Public API
	 */
/**
	 * Resets the model with the new data
	 */
/**
	 * Clears the data currently in the bin model
	 */
/**
	 * Add an array of data objects to the bins
	 */
/**
	 * Get/Set the low water mark value
	 */
/**
	 * Get the high water mark
	 */
/**
	 * Get/Set the key function used to determine the key value for indexing into the bins
	 */
/**
	 * Get/Set the value function for determining what value is added to the bin
	 */
/**
	 * Get/Set the Update bin function for determining how to update the state of a bin when a new value is added to it
	 */
/**
	 * Get/Set the seed function for populating
	 */
/**
	 * Get/Set the countBin function for populating
	 */
/**
	 * Get/Set the afterAdd callback function
	 */
/**
	 * Get/Set the afterUpdate callback function
	 */
/**
	 * Get/Set the bin size configuration
	 */
/**
	 * Get/Set the bin count configuration
	 */
/**
	 * Accessor for the bins of data
	 * @returns {Array} Returns the complete array of bins
	 */
/**
	 * Accessor for the cached count of all the data in the bins, calculated for each bin by the countBin() function
	 * @returns {number} The count of data in the bins
	 */
/**
	 * Clears all the data in the bin with the given index
	 * @param {number} i The index into the bins array of the bin to clear
	 * @returns {number} The number of items in the bin that was cleared, as returned by countBin() function
	 */
// Initialize the model
return i.set=function(t){return a(),n(),r(t),i},i.clear=function(){return a(),n(),i},i.add=function(t){return r(t),i},i.lwm=function(t){if(!arguments.length)return u.lwm;var r=u.lwm;
// the difference between watermarks is not a multiple of the bin size, so we need to reset
return u.lwm=Number(t),e(),(r-u.lwm)%u.size!=0&&a(),n(),i},i.hwm=function(){return u.hwm},i.getKey=function(t){return arguments.length?(l.getKey=t,a(),n(),i):l.getKey},i.getValue=function(t){return arguments.length?(l.getValue=t,a(),n(),i):l.getValue},i.updateBin=function(t){return arguments.length?(l.updateBin=t,a(),n(),i):l.updateBin},i.createSeed=function(t){return arguments.length?(l.createSeed=t,a(),n(),i):l.createSeed},i.countBin=function(t){return arguments.length?(l.countBin=t,a(),n(),i):l.countBin},i.afterAdd=function(t){return arguments.length?(l.afterAdd=t,i):l.afterAdd},i.afterUpdate=function(t){return arguments.length?(l.afterUpdate=t,i):l.afterUpdate},i.size=function(t){if(!arguments.length)return u.size;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");
// Only change stuff if the size actually changes
return t!==u.size&&(u.size=t,e(),a(),n()),i},i.count=function(t){if(!arguments.length)return u.count;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");
// Only change stuff if the count actually changes
return t!==u.count&&(u.count=Math.floor(t),e(),n()),i},i.bins=function(){return o},i.itemCount=function(){return c},i.clearBin=function(t){if(t>=0&&t<o.length){var e=l.countBin(o[t]);return c-=e,o[t][1]=l.createSeed(),e}return 0},i(t),i}/*
 * Controller wrapper for the bin model. Assumes binSize is in milliseconds.
 * Every time binSize elapses, updates the lwm to keep the bins shifting.
 */
function m(t){/**
	 * Private Functions
	 */
function e(){
// Assume the hwm is now plus two binSize
var t=Date.now()+2*i.size();
// Trunc the hwm down to a round value based on the binSize
return(t=Math.floor(t/i.size())*i.size())-i.size()*i.count()}function n(){!0===u&&(
// need to update the lwm
i.lwm(e()),window.setTimeout(n,i.size()))}function r(){u||(
// Start the update loop
u=!0,n())}
// create/init method
function a(t){if(null==t||null==t.binCount||null==t.binSize)throw new Error("You must provide an initial binSize and binCount");l.binSize=Number(t.binSize),l.binCount=Number(t.binCount),null!=t.delay&&(l.delay=Number(t.delay)),(i=p({size:l.binSize,count:l.binCount+2,lwm:0})).lwm(e()),r()}/**
	 * Private variables
	 */
var i,u,l={delay:0,binSize:0,binCount:0};/**
	 * Public API
	 */
/*
	 * Get the model bins
	 */
// Initialize the layout
return a.model=function(){return i},a.bins=function(){return i.bins()},a.start=function(){return r(),a},a.stop=function(){
// Setting running to false will stop the update loop
return u=!1,a},a.running=function(){return u},a.add=function(t){return i.add(t),a},a.clear=function(){return i.clear(),a},a.binSize=function(t){if(!arguments.length)return l.binSize;if((t=Number(t))<1)throw new Error("Bin size must be a positive integer");return l.binSize=t,i.size(t),i.lwm(e()),a},a.binCount=function(t){if(!arguments.length)return l.binCount;if((t=Number(t))<1)throw new Error("Bin count must be a positive integer");return l.binCount=t,i.count(t+2),i.lwm(e()),a},a(t),a}t.chartDonut=c,t.chartMatrix=function(){function t(t,e){var n=b.g.chart.selectAll(".row text");if(null!=t){
// Set the highlight on the row
var r=t.key;n.classed("active",function(t){return t.key==r})}else
// Now update the style
n.classed("active",!1)}function n(e,n){t(e),z.call("rowMouseover",this,e,n)}function a(e,n){t(),z.call("rowMouseout",this,e,n)}function u(t,e){z.call("rowClick",this,t,e)}function l(t,e){z.call("cellMouseover",this,t,e)}function o(t,e){z.call("cellMouseout",this,t,e)}function c(t,e){z.call("cellClick",this,t,e)}/**
	 * Style stuff
	 */
// Cell dimensions
var d=16,f=1,h={top:20,right:2,bottom:2,left:64},p=500,m={key:function(t){return t.key},value:function(t){return t.value}},v={x:s().getValue(function(t,e){return m.key(t,e)}),value:s(),multi:g()},x={x:r.scaleLinear(),y:r.scaleOrdinal(),color:r.scaleLinear().range(["#e7e7e7","#008500"])},y={x:i.axisTop().scale(x.x).tickSizeOuter(0).tickSizeInner(2)},b={div:void 0,svg:void 0,g:{chart:void 0,xAxis:void 0}},k=[],w=[],z=e.dispatch("cellMouseover","cellMouseout","cellClick","rowMouseover","rowMouseout","rowClick"),A=function(){};return A.init=function(t){
// Add the svg element
// Add the axis
// Add a group for the chart itself
return b.div=t.append("div").attr("class","sentio matrix"),b.svg=b.div.append("svg"),b.g.xAxis=b.svg.append("g").attr("class","x axis"),b.g.chart=b.svg.append("g").attr("class","chart"),A},A.resize=function(){},A.redraw=function(){
// Determine the number of rows/boxes to render
var t=w.length,e=k.length,r=f+d,i=e*r+f,s=t*r+f;
// scale the svg to the right size
b.svg.attr("width",i+h.left+h.right).attr("height",s+h.top+h.bottom),
// Configure the scales
x.x.domain(v.x.getExtent(k)).range([0,i-f-r]),x.color.domain(v.multi.extent(v.value).series(w).getExtent(k)),
// Draw the x axis
b.g.xAxis.attr("transform","translate("+(h.left+f+d/2)+","+h.top+")"),b.g.xAxis.call(y.x);/**
		 * Chart Manipulation
		 */
/*
		 * Row Join
		 */
var g=b.g.chart.selectAll("g.row").data(w,function(t){return t.key}),z=g.enter().append("g");z.style("opacity","0.1").attr("class","row").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}).on("mouseover",n).on("mouseout",a).on("click",u),
// Also must append the label of the row
z.append("text").attr("class","series label").style("text-anchor","end").attr("x",-6).attr("y",f+d/2).attr("dy",".32em"),
// Also must append a line
z.append("line").attr("class","series tick").attr("x1",-3).attr("x2",0).attr("y1",f+d/2).attr("y2",f+d/2);/*
		 * Row Enter + Update
		 */
// Transition rows to their new positions
var E=z.merge(g);E.transition().duration(p).style("opacity","1").attr("transform",function(t,e){return"translate("+h.left+","+(h.top+r*e)+")"}),
// Update the series labels in case they changed
E.select("text.series.label").text(function(t){return t.label}),/*
		 * Row Exit
		 */
g.exit().transition().duration(p).style("opacity","0.1").remove();/*
		 * Cell Join - Will be done on row enter + exit
		 */
var V=E.selectAll("rect.cell").data(function(t){return k.map(function(e,n){return{key:m.key(e,n),value:t.getValue(e,n)}})},m.key);/*
		 * Cell Remove
		 */
return V.enter().append("rect").attr("class","cell").style("opacity","0.1").style("fill",function(t,e){return x.color(t.value)}).attr("x",function(t,e){return x.x(t.key)+f}).attr("y",f).attr("height",d).attr("width",d).on("mouseover",l).on("mouseout",o).on("click",c).merge(V).transition().duration(p).style("opacity","1").attr("x",function(t,e){return x.x(t.key)+f}).style("fill",function(t,e){return x.color(t.value)}),V.exit().transition().duration(p).attr("width",0).style("opacity","0.1").remove(),A},A.data=function(t){return arguments.length?(k=null!=t?t:[],A):k},A.series=function(t){return arguments.length?(w=null!=t?t:[],A):w},A.cellSize=function(t){return arguments.length?(d=t,A):d},A.cellMargin=function(t){return arguments.length?(f=t,A):f},A.margin=function(t){return arguments.length?(h=t,A):h},A.duration=function(t){return arguments.length?(p=t,A):p},A.key=function(t){return arguments.length?(m.key=t,A):m.key},A.colorScale=function(t){return arguments.length?(x.color=t,A):x.color},A.xScale=function(t){return arguments.length?(x.xScale=t,y.x.scale(t),A):x.xScale},A.yScale=function(t){return arguments.length?(x.yScale=t,A):x.yScale},A.xExtent=function(t){return arguments.length?(v.x=t,v.x.getValue(function(e,n){return t(e,n)}),A):v.x},A.valueExtent=function(t){return arguments.length?(v.value=t,A):v.value},A.dispatch=function(){return z},A},t.chartTimeline=f,t.chartAutoBrushTimeline=h,t.chartRealtimeTimeline=function(){/*
	 * This is the main update loop function. It is called every time the
	 * _instance is updating to proceed through time.
	 */
function t(){
// If not running, let the loop die
r&&(u.redraw(),
// Schedule the next update
a=window.setTimeout(t,i>0?1e3/i:0))}
// Default data delay, this is the difference between now and the latest tick shown on the timeline
var e=0,n=6e4,r=!1,a=null,i=32,u=f();u.yExtent().filter(function(t){var e=u.xValue()(t),n=u.xExtent().getExtent();return e<n[1]&&e>n[0]}),u.brush(!1),u.pointEvents(!1);/*
	 * Redraw the graphic
	 */
var l=u.redraw;return u.redraw=function(){
// Update the x domain (to the latest time window)
var t=new Date;return u.xExtent().overrideValue([t-e-n,t-e]),l(),u},u.start=function(){if(!r)return r=!0,t(),u},u.stop=function(){return r=!1,null!=a&&window.clearTimeout(a),u},u.restart=function(){return u.stop(),u.start(),u},u.interval=function(t){return arguments.length?(n=t,u):n},u.delay=function(t){return arguments.length?(e=t,u):e},u.fps=function(t){return arguments.length?(i=t,r&&u.restart(),u):i},u.brush=function(t){return!1},u},t.chartVerticalBars=function(){function t(t,e){d.call("mouseover",this,t,e)}function n(t,e){d.call("mouseout",this,t,e)}function a(t,e){d.call("click",this,t,e)}
// Chart create/init method
function i(t){}
// Layout properties
var u=100,l=24,o=2,c=.1,g=500,d=e.dispatch("mouseover","mouseout","click"),f={key:function(t){return t.key},value:function(t){return t.value},label:function(t){return t.key+" ("+t.value+")"}},h={x:r.scaleLinear(),y:r.scaleLinear()},p={width:s({defaultValue:[0,10],getValue:function(t,e){return f.value(t,e)}})},m={div:void 0},v=[];/*
	 * Initialize the chart (should only call this once). Performs all initial chart
	 * creation and setup
	 */
/*
	 * Set the _instance data
	 */
/*
	 * Updates all the elements that depend on the size of the various components
	 */
/*
	 * Redraw the graphic
	 */
// Basic Getters/Setters
return i.init=function(t){
// Create the DIV element
return m.div=t.append("div").attr("class","sentio bars-vertical"),i.resize(),i},i.data=function(t){return arguments.length?(v=null!=t?t:[],i):v},i.resize=function(){
// Set up the x scale (y is fixed)
return h.x.range([u*c,u]),i},i.redraw=function(){
// Update the x domain
h.x.domain(p.width.getExtent(v)),
// Update the y domain (based on configuration and data)
h.y.domain([0,v.length]),h.y.range([0,(l+o)*v.length]);
// Data Join
var e=m.div.selectAll("div.bar").data(v,f.key),r=e.enter().append("div").attr("class","bar").style("top",h.y.range()[1]-l+"px").style("height",l+"px").on("mouseover",t).on("mouseout",n).on("click",a).style("opacity","0.01"),u=r.append("div").attr("class","bar-label");
// Enter + Update
// Exit
// Update the size of the parent div
return r.merge(e).transition().duration(g).style("opacity","1").style("width",function(t,e){return h.x(f.value(t,e))+"px"}).style("top",function(t,e){return h.y(e)+"px"}).style("left","0px"),u.merge(e.select("div.bar-label")).html(f.label).style("max-width",h.x.range()[1]-10+"px"),e.exit().transition().duration(g).style("opacity","0.01").style("top",h.y.range()[1]-l+"px").remove(),m.div.style("height",h.y.range()[1]+"px"),i},i.width=function(t){return arguments.length?(u=t,i):u},i.barWidthMinRatio=function(t){return arguments.length?(c=t,i):c},i.barHeight=function(t){return arguments.length?(l=t,i):l},i.barPadding=function(t){return arguments.length?(o=t,i):o},i.key=function(t){return arguments.length?(f.key=t,i):f.key},i.value=function(t){return arguments.length?(f.value=t,i):f.value},i.label=function(t){return arguments.length?(f.label=t,i):f.label},i.widthExtent=function(t){return arguments.length?(p.width=t,p.width.getValue(function(t,e){return f.value(t,e)}),i):p.width},i.dispatch=function(t){return arguments.length?i:d},i.duration=function(t){return arguments.length?(g=t,i):g},i},t.controllerRealtimeBins=m,t.controllerResponsiveUnits=/**
 *
 */
function(t){/**
	 * Private Functions
	 */
function e(t,e){var n=(t[1]-t[0])/e.value;return n>=r.maxTrigger?1:n<=r.minTrigger?-1:0}/*
	 * Constructor/initialization method
	 */
function n(t){null==t&&(t={}),null!=t.minTrigger&&(r.minTrigger=t.minTrigger),null!=t.maxTrigger&&(r.maxTrigger=t.maxTrigger)}/**
	 * Private variables
	 */
// Configuration
var r={minTrigger:30,maxTrigger:400},a=[{key:"second",value:1e3},{key:"minute",value:6e4},{key:"hour",value:36e5},{key:"day",value:864e5},{key:"month",value:2592e6},{key:"year",value:31536e6}],i=a[0];/**
	 * Public API
	 */
// Initialize the model
return n.getUnit=function(t){if(0===e(t,i))return i;
// Loop while there's too many points
for(
// We weren't good, so find a new unit by searching smallest to largest
var n=0;n<a.length&&0<e(t,a[n]);)n++;return i=a[Math.min(n,a.length-1)]},n.units=function(t){return arguments.length?(a=t,n):a},n.currentUnit=function(t){return arguments.length?(i=t,n):i},n.minTrigger=function(t){return arguments.length?(r.minTrigger=t,n):r.minTrigger},n.maxTrigger=function(t){return arguments.length?(r.maxTrigger=t,n):r.maxTrigger},n(t),n},t.timelineBrush=d,t.modelBins=p,t.modelExtent=s,t.modelMultiExtent=g,Object.defineProperty(t,"__esModule",{value:!0})});