{"version":3,"sources":["sentio.js","realtime.js","donut.chart.directive.js","matrix.chart.directive.js","realtime.timeline.directive.js","timeline.line.directive.js","verticalBars.chart.directive.js"],"names":[],"mappings":"AAAA;ACAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sentio-angular.js","sourcesContent":["angular.module('sentio', []);","angular.module('sentio.realtime', []);","angular.module('sentio').directive('sentioDonutChart', [ '$document', '$window', '$timeout', '$log',\n\tfunction($document, $window, $timeout, $log) {\n\t\t'use strict';\n\n\t\treturn {\n\t\t\trestrict : 'A',\n\t\t\tscope : {\n\t\t\t\tmodel: '=sentioModel',\n\t\t\t\tduration: '=sentioDuration',\n\t\t\t\tcolor: '=sentioColor',\n\t\t\t\tapi: '=sentioApi',\n\t\t\t\tresizeWidth: '@sentioResizeWidth',\n\t\t\t\tresizeHeight: '@sentioResizeHeight',\n\t\t\t\tconfigureFn: '&sentioConfigureFn'\n\t\t\t},\n\t\t\treplace : false,\n\t\t\tlink : function(scope, element, attrs, controller) {\n\n\t\t\t\tvar chartElement = d3.select(element[0]);\n\t\t\t\tvar chart = sentio.chart.donut();\n\n\t\t\t\t// Extract the width of the chart\n\t\t\t\tvar width = element[0].style.width;\n\t\t\t\tif(null != width && '' !== width) {\n\t\t\t\t\twidth = parseFloat(width.substring(0, width.length-2));\n\t\t\t\t\tif(null != width && !isNaN(width)) {\n\t\t\t\t\t\tchart.width(width);\n\t\t\t\t\t\t// set height to match width in this case to keep the donut round\n\t\t\t\t\t\tchart.height(width);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tchart.init(chartElement);\n\n\t\t\t\tscope.$watchCollection('model', function(n, o){\n\t\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\t\tchart.data(n);\n\t\t\t\t\tredraw();\n\t\t\t\t});\n\n\n\t\t\t\tscope.$watch('configureFn', function(n, o){\n\t\t\t\t\tif(null != scope.configureFn){\n\t\t\t\t\t\tscope.configureFn({ chart: chart });\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tscope.$watch('duration', function(n, o){\n\t\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\t\tchart.duration(n);\n\t\t\t\t});\n\n\t\t\t\tscope.$watch('colorScale', function(n, o){\n\t\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\t\tchart.duration(n);\n\t\t\t\t}, true);\n\n\t\t\t\tscope.$watch('api', function(n, o) {\n\t\t\t\t\tif(null != scope.api) {\n\t\t\t\t\t\tscope.api.redraw = chart.redraw;\n\t\t\t\t\t\tscope.api.resize = doResize;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Manage resizing the chart\n\t\t\t\tvar resizeWidth = (null != attrs.sentioResizeWidth);\n\t\t\t\tvar resizeHeight = (null != attrs.sentioResizeHeight);\n\t\t\t\tvar resizeTimer;\n\t\t\t\tvar redrawTimer;\n\t\t\t\tvar window = angular.element($window);\n\n\t\t\t\t// Do the redraw only once when the $digest cycle has completed\n\t\t\t\tvar redraw = function() {\n\t\t\t\t\tif (null != redrawTimer) {\n\t\t\t\t\t\t$timeout.cancel(redrawTimer);\n\t\t\t\t\t}\n\t\t\t\t\tredrawTimer = $timeout(function () {\n\t\t\t\t\t\tchart.redraw();\n\t\t\t\t\t}, 0);\n\t\t\t\t};\n\n\t\t\t\tvar doResize = function() {\n\n\t\t\t\t\t// Get the raw body element\n\t\t\t\t\tvar body = $document[0].body;\n\n\t\t\t\t\t// Cache the old overflow style\n\t\t\t\t\tvar overflow = body.style.overflow;\n\t\t\t\t\tbody.style.overflow = 'hidden';\n\n\t\t\t\t\t// Get the raw parent\n\t\t\t\t\tvar rawElement = element[0];\n\t\t\t\t\t// Derive width of the parent (there are several ways to do this depending on the parent)\n\t\t\t\t\tvar parentWidth = rawElement.attributes.width | rawElement.style.width | rawElement.clientWidth;\n\n\t\t\t\t\t// Calculate the new width based on the parent and the resize size\n\t\t\t\t\tvar width = (resizeWidth)? parentWidth - attrs.sentioResizeWidth : undefined;\n\n\t\t\t\t\t// Set height to match width to keep donut round\n\t\t\t\t\tvar height = width;\n\n\t\t\t\t\t// Reapply the old overflow setting\n\t\t\t\t\tbody.style.overflow = overflow;\n\n\t\t\t\t\t// Get the old widths and heights\n\t\t\t\t\tvar oldHeight = chart.height();\n\t\t\t\t\tvar oldWidth = chart.width();\n\n\t\t\t\t\tif (height !== oldHeight || width !== oldWidth) {\n\t\t\t\t\t\t$log.debug('resize donut.chart width: ' + width);\n\t\t\t\t\t\t$log.debug('resize donut.chart height: ' + height);\n\n\t\t\t\t\t\t// Apply the new height\n\t\t\t\t\t\tif(resizeHeight){ chart.height(height);}\n\t\t\t\t\t\t// Apply the new width\n\t\t\t\t\t\tif(resizeWidth){ chart.width(width); }\n\t\t\t\t\t\tchart.resize();\n\t\t\t\t\t\tredraw();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$log.debug('resize donut.chart width unchanged: ' + width);\n\t\t\t\t\t\t$log.debug('resize donut.chart height unchanged: ' + height);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tvar delayResize = function(){\n\t\t\t\t\tif(undefined !== resizeTimer){\n\t\t\t\t\t\t$timeout.cancel(resizeTimer);\n\t\t\t\t\t}\n\t\t\t\t\tresizeTimer = $timeout(doResize, 0);\n\t\t\t\t};\n\n\t\t\t\tif(resizeWidth){\n\t\t\t\t\twindow.on('resize', delayResize);\n\t\t\t\t\tdelayResize();\n\t\t\t\t}\n\t\t\t\tscope.$on('$destroy', function () {\n\t\t\t\t\twindow.off('resize', delayResize);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}]);\n","angular.module('sentio').directive('sentioMatrixChart', [ '$document', '$window', '$timeout', '$log',\n\tfunction($document, $window, $timeout, $log) {\n\t\t'use strict';\n\n\t\treturn {\n\t\t\trestrict : 'A',\n\t\t\tscope : {\n\t\t\t\tmodel: '=sentioModel',\n\t\t\t\tconfigureFn: '&sentioConfigureFn'\n\t\t\t},\n\t\t\treplace : false,\n\t\t\tlink : function(scope, element, attrs, controller) {\n\n\t\t\t\tvar chartElement = d3.select(element[0]);\n\t\t\t\tvar chart = sentio.chart.matrix();\n\n\t\t\t\tchart.init(chartElement);\n\n\t\t\t\tscope.$watch('configureFn', function(n, o){\n\t\t\t\t\tif(null != scope.configureFn){\n\t\t\t\t\t\tscope.configureFn({ chart: chart });\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tscope.$watchCollection('model', function(n, o){\n\t\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\t\tchart.data(n);\n\t\t\t\t\tredraw();\n\t\t\t\t});\n\n\t\t\t\t// Redraw (we don't support resize on the matrix)\n\t\t\t\tvar redrawTimer;\n\n\t\t\t\t// Do the redraw only once when the $digest cycle has completed\n\t\t\t\tvar redraw = function() {\n\t\t\t\t\tif (null != redrawTimer) {\n\t\t\t\t\t\t$timeout.cancel(redrawTimer);\n\t\t\t\t\t}\n\t\t\t\t\tredrawTimer = $timeout(function () {\n\t\t\t\t\t\tchart.redraw();\n\t\t\t\t\t}, 0);\n\t\t\t\t};\n\n\t\t\t\tscope.$on('$destroy', function () {\n\t\t\t\t\tif(null != redrawTimer) {\n\t\t\t\t\t\t$timeout.cancel(redrawTimer);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}]);\n","angular.module('sentio.realtime').directive('sentioRtTimeline', [ '$document', '$window', '$timeout', '$log', \nfunction($document, $window, $timeout, $log) {\n\t'use strict';\n\n\treturn {\n\t\trestrict : 'A',\n\t\tscope : {\n\t\t\tmodel: '=sentioModel',\n\t\t\tmarkers: '=sentioMarkers',\n\t\t\tmarkerHover: '=sentioMarkerHover',\n\t\t\tinterval: '=sentioInterval',\n\t\t\tdelay: '=sentioDelay',\n\t\t\tyExtent: '=sentioYExtent',\n\t\t\tfps: '=sentioFps',\n\t\t\tapi: '=sentioApi',\n\t\t\tresizeWidth: '@sentioResizeWidth',\n\t\t\tresizeHeight: '@sentioResizeHeight',\n\t\t\tconfigure: '&sentioConfigureFn'\n\t\t},\n\t\treplace : false,\n\t\tlink : function(scope, element, attrs, controller) {\n\t\t\tvar timelineElement = d3.select(element[0]);\n\t\t\tvar timeline = sentio.realtime.timeline();\n\n\t\t\t// Extract the height and width of the chart\n\t\t\tvar width = element[0].style.width;\n\t\t\tif(null != width && '' !== width) { \n\t\t\t\twidth = parseFloat(width.substring(0, width.length-2));\n\t\t\t\tif(null != width && !isNaN(width)) { timeline.width(width); }\n\t\t\t}\n\t\t\tvar height = element[0].style.height;\n\t\t\tif(null != height && '' !== height) {\n\t\t\t\theight = parseFloat(height.substring(0, height.length-2));\n\t\t\t\tif(null != height && !isNaN(height)) { timeline.height(height); }\n\t\t\t}\n\n\t\t\ttimeline.init(timelineElement).data([]).start();\n\n\t\t\t// setup the marker callback method if one was provided\n\t\t\tif(null != scope.markerHover) {\n\t\t\t\ttimeline.dispatch().on('markerMouseover', scope.markerHover);\n\t\t\t}\n\n\t\t\tscope.$watch('configure', function(n, o){\n\t\t\t\tif(null != scope.configure){\n\t\t\t\t\tscope.configure({ timeline: timeline });\n\t\t\t\t\ttimeline.redraw();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Only want to watch when the collection object changes\n\t\t\tscope.$watch('model', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.data(n).redraw();\n\t\t\t});\n\n\t\t\t// Only want to watch when the collection object changes\n\t\t\tscope.$watch('markers', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.markers(n).redraw();\n\t\t\t});\n\n\t\t\tscope.$watch('interval', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.interval(n).redraw();\n\t\t\t});\n\n\t\t\tscope.$watch('delay', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.delay(n).redraw();\n\t\t\t});\n\n\t\t\tscope.$watchCollection('yExtent', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.yExtent().overrideValue(n);\n\t\t\t\ttimeline.redraw();\n\t\t\t});\n\n\t\t\tscope.$watch('fps', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.fps(n).redraw();\n\t\t\t});\n\n\t\t\tscope.$watch('api', function(n, o) {\n\t\t\t\tif(null != scope.api) {\n\t\t\t\t\tscope.api.start = timeline.start;\n\t\t\t\t\tscope.api.stop = timeline.stop;\n\t\t\t\t\tscope.api.restart = timeline.restart;\n\t\t\t\t\tscope.api.redraw = timeline.redraw;\n\t\t\t\t\tscope.api.resize = doResize;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Manage resizing the chart\n\t\t\tvar resizeWidth = (null != attrs.sentioResizeWidth);\n\t\t\tvar resizeHeight = (null != attrs.sentioResizeHeight);\n\t\t\tvar resizeTimer;\n\t\t\tvar window = angular.element($window);\n\n\t\t\tvar doResize = function() {\n\n\t\t\t\t// Get the raw body element\n\t\t\t\tvar body = $document[0].body;\n\n\t\t\t\t// Cache the old overflow style\n\t\t\t\tvar overflow = body.style.overflow;\n\t\t\t\tbody.style.overflow = 'hidden';\n\n\t\t\t\t// Get the raw parent\n\t\t\t\tvar rawElement = element[0];\n\t\t\t\t// Derive height/width of the parent (there are several ways to do this depending on the parent)\n\t\t\t\tvar parentWidth = rawElement.attributes.width | rawElement.style.width | rawElement.clientWidth;\n\t\t\t\tvar parentHeight = rawElement.attributes.height | rawElement.style.height | rawElement.clientHeight;\n\n\t\t\t\t// Calculate the new width/height based on the parent and the resize size\n\t\t\t\tvar width = (resizeWidth)? parentWidth - attrs.sentioResizeWidth : undefined;\n\t\t\t\tvar height = (resizeHeight)? parentHeight - attrs.sentioResizeHeight : undefined;\n\n\t\t\t\t// Reapply the old overflow setting\n\t\t\t\tbody.style.overflow = overflow;\n\n\t\t\t\t$log.debug('resize rt.timeline height: ' + height + ' width: ' + width);\n\n\t\t\t\t// Apply the new width and height\n\t\t\t\tif(resizeWidth){ timeline.width(width); }\n\t\t\t\tif(resizeHeight){ timeline.height(height); }\n\n\t\t\t\ttimeline.resize().redraw();\n\t\t\t};\n\t\t\tvar delayResize = function(){\n\t\t\t\tif(undefined !== resizeTimer){\n\t\t\t\t\t$timeout.cancel(resizeTimer);\n\t\t\t\t}\n\t\t\t\tresizeTimer = $timeout(doResize, 200);\n\t\t\t};\n\n\t\t\tif(resizeWidth || resizeHeight){\n\t\t\t\twindow.on('resize', delayResize);\n\t\t\t\tdelayResize();\n\t\t\t}\n\t\t\tscope.$on('$destroy', function () {\n\t\t\t\twindow.off('resize', delayResize);\n\t\t\t});\n\t\t\tscope.$on('$destroy', function() {\n\t\t\t\ttimeline.stop();\n\t\t\t});\n\t\t}\n\t};\n}]);\n","angular.module('sentio').directive('sentioTimeline', [ '$document', '$window', '$timeout', '$log', \nfunction($document, $window, $timeout, $log) {\n\t'use strict';\n\n\treturn {\n\t\trestrict : 'A',\n\t\tscope : {\n\t\t\tmodel: '=sentioModel',\n\t\t\tmarkers: '=sentioMarkers',\n\t\t\tyExtent: '=sentioYExtent',\n\t\t\txExtent: '=sentioXExtent',\n\t\t\tduration: '=sentioDuration',\n\t\t\tapi: '=sentioApi',\n\t\t\tresizeWidth: '@sentioResizeWidth',\n\t\t\tresizeHeight: '@sentioResizeHeight',\n\t\t\tconfigureFn: '&sentioConfigureFn',\n\t\t\tfilterFn: '&sentioFilterFn',\n\t\t\tfilterState: '=sentioFilterState'\n\t\t},\n\t\treplace : false,\n\t\tlink : function(scope, element, attrs, controller) {\n\n\t\t\tvar timelineElement = d3.select(element[0]);\n\t\t\tvar timeline = sentio.timeline.line();\n\n\t\t\t// Extract the height and width of the chart\n\t\t\tvar width = element[0].style.width;\n\t\t\tif(null != width && '' !== width) { \n\t\t\t\twidth = parseFloat(width.substring(0, width.length-2));\n\t\t\t\tif(null != width && !isNaN(width)) { timeline.width(width); }\n\t\t\t}\n\t\t\tvar height = element[0].style.height;\n\t\t\tif(null != height && '' !== height) {\n\t\t\t\theight = parseFloat(height.substring(0, height.length-2));\n\t\t\t\tif(null != height && !isNaN(height)) { timeline.height(height); }\n\t\t\t}\n\n\t\t\t// Check to see if filtering is enabled\n\t\t\tif (null != attrs.sentioFilterFn || attrs.sentioFilterState) {\n\t\t\t\ttimeline.filter(true);\n\t\t\t}\n\n\t\t\t// Store the filter state outside the scope as well as inside, to compare\n\t\t\tvar lastFilterState = null;\n\n\t\t\tscope.$watch('filterFn', function(n, o){\n\t\t\t\ttimeline.dispatch().on('filterend', function(filterState){\n\t\t\t\t\t$timeout(function(){\n\t\t\t\t\t\t// Call the function callback\n\t\t\t\t\t\tscope.filterFn({ filterState: filterState });\n\n\t\t\t\t\t\t// Set the two-way-bound scope parameter\n\t\t\t\t\t\tscope.filterState = filterState;\n\n\t\t\t\t\t\t// Store the filter state locally so we can suppress updates on our own changes\n\t\t\t\t\t\tlastFilterState = filterState;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t\tscope.$watch('filterState', function(n, o) {\n\t\t\t\t// If a filter was passed in and it is not the one we just set, do some updates\n\t\t\t\tif (null != n && n !== lastFilterState) {\n\n\t\t\t\t\t// If we're in the original format with 3 parameters, use the second two only\n\t\t\t\t\t// TODO: We should go ahead and get rid of the 3 parameter style\n\t\t\t\t\tif (n.length > 2) {\n\t\t\t\t\t\t// The first element indicates if we're disabled\n\t\t\t\t\t\tif (n[0]) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = n.slice(1, 3);\n\t\t\t\t\t}\n\t\t\t\t\ttimeline.setFilter(n);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\ttimeline.init(timelineElement);\n\n\t\t\tscope.$watch('configureFn', function(n, o){\n\t\t\t\tif(null != scope.configureFn){\n\t\t\t\t\tscope.configureFn({ timeline: timeline });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tscope.$watchCollection('model', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.data(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watchCollection('markers', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.markers(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watchCollection('yExtent', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.yExtent().overrideValue(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watchCollection('xExtent', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.xExtent().overrideValue(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watch('duration', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\ttimeline.duration(n);\n\t\t\t}, true);\n\n\t\t\tscope.$watch('api', function(n, o) {\n\t\t\t\tif(null != scope.api) {\n\t\t\t\t\tscope.api.start = timeline.start;\n\t\t\t\t\tscope.api.stop = timeline.stop;\n\t\t\t\t\tscope.api.restart = timeline.restart;\n\t\t\t\t\tscope.api.redraw = timeline.redraw;\n\t\t\t\t\tscope.api.resize = doResize;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Manage resizing the chart\n\t\t\tvar resizeWidth = (null != attrs.sentioResizeWidth);\n\t\t\tvar resizeHeight = (null != attrs.sentioResizeHeight);\n\t\t\tvar resizeTimer;\n\t\t\tvar redrawTimer;\n\t\t\tvar window = angular.element($window);\n\n\t\t\t// Do the redraw only once when the $digest cycle has completed\n\t\t\tvar redraw = function() {\n\t\t\t\tif (null != redrawTimer) {\n\t\t\t\t\t$timeout.cancel(redrawTimer);\n\t\t\t\t}\n\t\t\t\tredrawTimer = $timeout(function () {\n\t\t\t\t\ttimeline.redraw();\n\t\t\t\t}, 0);\n\t\t\t};\n\n\t\t\tvar doResize = function() {\n\n\t\t\t\t// Get the raw body element\n\t\t\t\tvar body = $document[0].body;\n\n\t\t\t\t// Cache the old overflow style\n\t\t\t\tvar overflow = body.style.overflow;\n\t\t\t\tbody.style.overflow = 'hidden';\n\n\t\t\t\t// Get the raw parent\n\t\t\t\tvar rawElement = element[0];\n\t\t\t\t// Derive height/width of the parent (there are several ways to do this depending on the parent)\n\t\t\t\tvar parentWidth = rawElement.attributes.width | rawElement.style.width | rawElement.clientWidth;\n\t\t\t\tvar parentHeight = rawElement.attributes.height | rawElement.style.height | rawElement.clientHeight;\n\n\t\t\t\t// Calculate the new width/height based on the parent and the resize size\n\t\t\t\tvar width = (resizeWidth)? parentWidth - attrs.sentioResizeWidth : undefined;\n\t\t\t\tvar height = (resizeHeight)? parentHeight - attrs.sentioResizeHeight : undefined;\n\n\t\t\t\t// Reapply the old overflow setting\n\t\t\t\tbody.style.overflow = overflow;\n\n\t\t\t\t$log.debug('resize rt.timeline height: ' + height + ' width: ' + width);\n\n\t\t\t\t// Apply the new width and height\n\t\t\t\tif(resizeWidth){ timeline.width(width); }\n\t\t\t\tif(resizeHeight){ timeline.height(height); }\n\n\t\t\t\ttimeline.resize();\n\t\t\t\tredraw();\n\t\t\t};\n\t\t\tvar delayResize = function(){\n\t\t\t\tif(undefined !== resizeTimer){\n\t\t\t\t\t$timeout.cancel(resizeTimer);\n\t\t\t\t}\n\t\t\t\tresizeTimer = $timeout(doResize, 200);\n\t\t\t};\n\n\t\t\tif(resizeWidth || resizeHeight){\n\t\t\t\twindow.on('resize', delayResize);\n\t\t\t\tdelayResize();\n\t\t\t}\n\t\t\tscope.$on('$destroy', function () {\n\t\t\t\twindow.off('resize', delayResize);\n\t\t\t});\n\t\t}\n\t};\n}]);\n","angular.module('sentio').directive('sentioVerticalBarChart', [ '$document', '$window', '$timeout', '$log', \nfunction($document, $window, $timeout, $log) {\n\t'use strict';\n\n\treturn {\n\t\trestrict : 'A',\n\t\tscope : {\n\t\t\tmodel: '=sentioModel',\n\t\t\twidthExtent: '=sentioWidthExtent',\n\t\t\tduration: '=sentioDuration',\n\t\t\tapi: '=sentioApi',\n\t\t\tresizeWidth: '@sentioResizeWidth',\n\t\t\tconfigureFn: '&sentioConfigureFn'\n\t\t},\n\t\treplace : false,\n\t\tlink : function(scope, element, attrs, controller) {\n\n\t\t\tvar chartElement = d3.select(element[0]);\n\t\t\tvar chart = sentio.chart.verticalBars();\n\n\t\t\t// Extract the width of the chart\n\t\t\tvar width = element[0].style.width;\n\t\t\tif(null != width && '' !== width) { \n\t\t\t\twidth = parseFloat(width.substring(0, width.length-2));\n\t\t\t\tif(null != width && !isNaN(width)) { chart.width(width); }\n\t\t\t}\n\n\t\t\tchart.init(chartElement);\n\n\t\t\tscope.$watch('configureFn', function(n, o){\n\t\t\t\tif(null != scope.configureFn){\n\t\t\t\t\tscope.configureFn({ chart: chart });\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tscope.$watchCollection('model', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\tchart.data(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watchCollection('widthExtent', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\tchart.widthExtent().overrideValue(n);\n\t\t\t\tredraw();\n\t\t\t});\n\n\t\t\tscope.$watch('duration', function(n, o){\n\t\t\t\tif(null == o && null == n){ return; }\n\n\t\t\t\tchart.duration(n);\n\t\t\t}, true);\n\n\t\t\tscope.$watch('api', function(n, o) {\n\t\t\t\tif(null != scope.api) {\n\t\t\t\t\tscope.api.value = chart.value;\n\t\t\t\t\tscope.api.label = chart.label;\n\t\t\t\t\tscope.api.key = chart.key;\n\t\t\t\t\tscope.api.dispatch = chart.dispatch;\n\t\t\t\t\tscope.api.redraw = chart.redraw;\n\t\t\t\t\tscope.api.resize = doResize;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Manage resizing the chart\n\t\t\tvar resizeWidth = (null != attrs.sentioResizeWidth);\n\t\t\tvar resizeTimer;\n\t\t\tvar redrawTimer;\n\t\t\tvar window = angular.element($window);\n\n\t\t\t// Do the redraw only once when the $digest cycle has completed\n\t\t\tvar redraw = function() {\n\t\t\t\tif (null != redrawTimer) {\n\t\t\t\t\t$timeout.cancel(redrawTimer);\n\t\t\t\t}\n\t\t\t\tredrawTimer = $timeout(function () {\n\t\t\t\t\tchart.redraw();\n\t\t\t\t}, 0);\n\t\t\t};\n\n\t\t\tvar doResize = function() {\n\n\t\t\t\t// Get the raw body element\n\t\t\t\tvar body = $document[0].body;\n\n\t\t\t\t// Cache the old overflow style\n\t\t\t\tvar overflow = body.style.overflow;\n\t\t\t\tbody.style.overflow = 'hidden';\n\n\t\t\t\t// Get the raw parent\n\t\t\t\tvar rawElement = element[0];\n\t\t\t\t// Derive width of the parent (there are several ways to do this depending on the parent)\n\t\t\t\tvar parentWidth = rawElement.attributes.width | rawElement.style.width | rawElement.clientWidth;\n\n\t\t\t\t// Calculate the new width based on the parent and the resize size\n\t\t\t\tvar width = (resizeWidth)? parentWidth - attrs.sentioResizeWidth : undefined;\n\n\t\t\t\t// Reapply the old overflow setting\n\t\t\t\tbody.style.overflow = overflow;\n\n\t\t\t\t$log.debug('resize verticalBars.chart width: ' + width);\n\n\t\t\t\t// Apply the new width\n\t\t\t\tif(resizeWidth){ chart.width(width); }\n\n\t\t\t\tchart.resize();\n\t\t\t\tredraw();\n\t\t\t};\n\t\t\tvar delayResize = function(){\n\t\t\t\tif(undefined !== resizeTimer){\n\t\t\t\t\t$timeout.cancel(resizeTimer);\n\t\t\t\t}\n\t\t\t\tresizeTimer = $timeout(doResize, 200);\n\t\t\t};\n\n\t\t\tif(resizeWidth){\n\t\t\t\twindow.on('resize', delayResize);\n\t\t\t\tdelayResize();\n\t\t\t}\n\t\t\tscope.$on('$destroy', function () {\n\t\t\t\twindow.off('resize', delayResize);\n\t\t\t});\n\t\t}\n\t};\n}]);\n"],"sourceRoot":"/source/"}